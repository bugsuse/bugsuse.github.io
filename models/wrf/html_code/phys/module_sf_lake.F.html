<HTML> <BODY BGCOLOR=#ddddee LINK=#0000aa VLINK=#0000ff ALINK=#ff0000 ><BASE TARGET="bottom_target"><PRE><a name='1'>
<A NAME='MODULE_SF_LAKE'><A href='../../html_code/phys/module_sf_lake.F.html#MODULE_SF_LAKE' TARGET='top_target'><IMG SRC="../../gif/bar_purple.gif" border=0></A><a name='2'>
<font color=#993300>MODULE </font><font color=#cc0000>module_sf_lake</font> <A href='../../call_to/MODULE_SF_LAKE.html' TARGET='index'>3</A><a name='3'>
<a name='4'>
<font color=#447700>! The lake scheme was retrieved from the Community Land Model version 4.5 <a name='5'></font>
<font color=#447700>! (Oleson et al. 2013) with some modifications by Gu et al. (2013). It is a <a name='6'></font>
<font color=#447700>! one-dimensional mass and energy balance scheme with 20-25 model layers, <a name='7'></font>
<font color=#447700>! including up to 5 snow layers on the lake ice, 10 water layers, and 10 soil <a name='8'></font>
<font color=#447700>! layers on the lake bottom. The lake scheme is used with actual lake points and <a name='9'></font>
<font color=#447700>! lake depth derived from the WPS, and it also can be used with user defined <a name='10'></font>
<font color=#447700>! lake points and lake depth in WRF (lake_min_elev and lakedepth_default). <a name='11'></font>
<font color=#447700>! The lake scheme is independent of a land surface scheme and therefore <a name='12'></font>
<font color=#447700>! can be used with any land surface scheme embedded in WRF. The lake scheme <a name='13'></font>
<font color=#447700>! developments and evaluations were included in Subin et al. (2012) and Gu et al. (2013) <a name='14'></font>
<font color=#447700>!<a name='15'></font>
<font color=#447700>!   Subin et al. 2012: Improved lake model for climate simulations, J. Adv. Model. <a name='16'></font>
<font color=#447700>!   Earth Syst., 4, M02001. DOI:10.1029/2011MS000072; <a name='17'></font>
<font color=#447700>!   Gu et al. 2013: Calibration and validation of lake surface temperature simulations <a name='18'></font>
<font color=#447700>!   with the coupled WRF-Lake model. Climatic Change, 1-13, 10.1007/s10584-013-0978-y. <a name='19'></font>
<a name='20'>
 USE <A href='../../html_code/frame/module_wrf_error.F.html#MODULE_WRF_ERROR'>module_wrf_error</A><A href='../../html_code/phys/module_sf_lake.F.html#module_sf_lake.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_WRF_ERROR_85"><a name='21'>
 USE <A href='../../html_code/share/module_model_constants.F.html#MODULE_MODEL_CONSTANTS'>module_model_constants</A><A href='../../html_code/phys/module_sf_lake.F.html#module_sf_lake.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_MODEL_CONSTANTS_92">, ONLY : rcp<a name='22'>
<a name='23'>
    implicit none <a name='24'>
    integer, parameter ::      r8 = selected_real_kind(12) <a name='25'>
<a name='26'>
    integer, parameter :: nlevsoil     =  10   <font color=#447700>! number of soil layers<a name='27'></font>
    integer, parameter :: nlevlake     =  10   <font color=#447700>! number of lake layers<a name='28'></font>
    integer, parameter :: nlevsnow     =   5   <font color=#447700>! maximum number of snow layers<a name='29'></font>
<a name='30'>
    integer,parameter  ::     lbp = 1                        <font color=#447700>! pft-index bounds<a name='31'></font>
    integer,parameter  ::     ubp = 1<a name='32'>
    integer,parameter  ::     lbc = 1                        <font color=#447700>! column-index bounds<a name='33'></font>
    integer,parameter  ::     ubc = 1<a name='34'>
    integer,parameter  ::     num_shlakec       = 1          <font color=#447700>! number of columns in lake filter<a name='35'></font>
    integer,parameter  ::     filter_shlakec(1) = 1          <font color=#447700>! lake filter (columns)<a name='36'></font>
    integer,parameter  ::     num_shlakep       = 1          <font color=#447700>! number of pfts in lake filter<a name='37'></font>
    integer,parameter  ::     filter_shlakep(1) = 1          <font color=#447700>! lake filter (pfts)<a name='38'></font>
    integer,parameter  ::     pcolumn(1)        = 1  <a name='39'>
    integer,parameter  ::     pgridcell(1)      = 1  <a name='40'>
    integer,parameter  ::     cgridcell(1)      = 1          <font color=#447700>! gridcell index of column<a name='41'></font>
    integer,parameter  ::     clandunit(1)      = 1          <font color=#447700>! landunit index of column<a name='42'></font>
  <a name='43'>
    integer,parameter  ::     begg = 1<a name='44'>
    integer,parameter  ::     endg = 1<a name='45'>
    integer,parameter  ::     begl = 1<a name='46'>
    integer,parameter  ::     endl = 1<a name='47'>
    integer,parameter  ::     begc = 1<a name='48'>
    integer,parameter  ::     endc = 1<a name='49'>
    integer,parameter  ::     begp = 1<a name='50'>
    integer,parameter  ::     endp = 1<a name='51'>
<a name='52'>
    integer,parameter  ::     column    =1<a name='53'>
    logical,parameter  ::     lakpoi(1) = .true.<a name='54'>
   <a name='55'>
<a name='56'>
<a name='57'>
<a name='58'>
<font color=#447700>!Initialize physical constants:<a name='59'></font>
    real(r8), parameter :: vkc    = 0.4_r8       <font color=#447700>!von Karman constant [-]<a name='60'></font>
    real(r8), parameter :: pie    = 3.141592653589793_r8 <font color=#447700>! pi<a name='61'></font>
    real(r8), parameter :: grav   = 9.80616_r8   <font color=#447700>!gravity constant [m/s2]<a name='62'></font>
    real(r8), parameter :: sb     = 5.67e-8_r8   <font color=#447700>!stefan-boltzmann constant  [W/m2/K4]<a name='63'></font>
    real(r8), parameter :: tfrz   = 273.16_r8    <font color=#447700>!freezing temperature [K]<a name='64'></font>
    real(r8), parameter :: denh2o = 1.000e3_r8   <font color=#447700>!density of liquid water [kg/m3]<a name='65'></font>
    real(r8), parameter :: denice = 0.917e3_r8   <font color=#447700>!density of ice [kg/m3]<a name='66'></font>
    real(r8), parameter :: cpice  = 2.11727e3_r8 <font color=#447700>!Specific heat of ice [J/kg-K]<a name='67'></font>
    real(r8), parameter :: cpliq  = 4.188e3_r8   <font color=#447700>!Specific heat of water [J/kg-K]<a name='68'></font>
    real(r8), parameter :: hfus   = 3.337e5_r8   <font color=#447700>!Latent heat of fusion for ice [J/kg]<a name='69'></font>
    real(r8), parameter :: hvap   = 2.501e6_r8   <font color=#447700>!Latent heat of evap for water [J/kg]<a name='70'></font>
    real(r8), parameter :: hsub   = 2.501e6_r8+3.337e5_r8 <font color=#447700>!Latent heat of sublimation    [J/kg]<a name='71'></font>
    real(r8), parameter :: rair   = 287.0423_r8  <font color=#447700>!gas constant for dry air [J/kg/K]<a name='72'></font>
    real(r8), parameter :: cpair  = 1.00464e3_r8 <font color=#447700>!specific heat of dry air [J/kg/K]<a name='73'></font>
    real(r8), parameter :: tcrit  = 2.5          <font color=#447700>!critical temperature to determine rain or snow<a name='74'></font>
    real(r8), parameter :: tkwat  = 0.6          <font color=#447700>!thermal conductivity of water [W/m/k]<a name='75'></font>
    real(r8), parameter :: tkice  = 2.290        <font color=#447700>!thermal conductivity of ice   [W/m/k]<a name='76'></font>
    real(r8), parameter :: tkairc = 0.023        <font color=#447700>!thermal conductivity of air   [W/m/k]<a name='77'></font>
    real(r8), parameter :: bdsno = 250.            <font color=#447700>!bulk density snow (kg/m**3)<a name='78'></font>
    <a name='79'>
    real(r8), public, parameter :: spval = 1.e36  <font color=#447700>!special value for missing data (ocean)<a name='80'></font>
<a name='81'>
    real, parameter  ::     depth_c = 50.          <font color=#447700>! below the level t_lake3d will be 277.0  !mchen<a name='82'></font>
<a name='83'>
    <a name='84'>
   <font color=#447700>! These are tunable constants<a name='85'></font>
    real(r8), parameter :: wimp   = 0.05    <font color=#447700>!Water impremeable if porosity less than wimp<a name='86'></font>
    real(r8), parameter :: ssi    = 0.033   <font color=#447700>!Irreducible water saturation of snow<a name='87'></font>
    real(r8), parameter :: cnfac  = 0.5     <font color=#447700>!Crank Nicholson factor between 0 and 1<a name='88'></font>
<a name='89'>
<a name='90'>
   <font color=#447700>! Initialize water type constants<a name='91'></font>
    integer,parameter :: istsoil = 1  <font color=#447700>!soil         "water" type<a name='92'></font>
    integer, private  :: i  <font color=#447700>! loop index <a name='93'></font>
    real(r8) :: dtime                                    <font color=#447700>! land model time step (sec)<a name='94'></font>
<a name='95'>
    real(r8) :: zlak(1:nlevlake)     <font color=#447700>!lake z  (layers)<a name='96'></font>
    real(r8) :: dzlak(1:nlevlake)    <font color=#447700>!lake dz (thickness)<a name='97'></font>
    real(r8) :: zsoi(1:nlevsoil)     <font color=#447700>!soil z  (layers)<a name='98'></font>
    real(r8) :: dzsoi(1:nlevsoil)    <font color=#447700>!soil dz (thickness)<a name='99'></font>
    real(r8) :: zisoi(0:nlevsoil)    <font color=#447700>!soil zi (interfaces)  <a name='100'></font>
<a name='101'>
<a name='102'>
    real(r8) :: sand(19)                           <font color=#447700>! percent sand<a name='103'></font>
    real(r8) :: clay(19)                           <font color=#447700>! percent clay<a name='104'></font>
<a name='105'>
    data(sand(i), i=1,19)/92.,80.,66.,20.,5.,43.,60.,&amp;<a name='106'>
      10.,32.,51., 6.,22.,39.7,0.,100.,54.,17.,100.,92./<a name='107'>
<a name='108'>
    data(clay(i), i=1,19)/ 3., 5.,10.,15.,5.,18.,27.,&amp;<a name='109'>
      33.,33.,41.,47.,58.,14.7,0., 0., 8.5,54.,  0., 3./<a name='110'>
<a name='111'>
<a name='112'>
  <font color=#447700>!  real(r8) :: dtime                  ! land model time step (sec)<a name='113'></font>
    real(r8) :: watsat(1,nlevsoil)      <font color=#447700>! volumetric soil water at saturation (porosity)<a name='114'></font>
    real(r8) :: tksatu(1,nlevsoil)      <font color=#447700>! thermal conductivity, saturated soil [W/m-K]<a name='115'></font>
    real(r8) :: tkmg(1,nlevsoil)        <font color=#447700>! thermal conductivity, soil minerals  [W/m-K]<a name='116'></font>
    real(r8) :: tkdry(1,nlevsoil)       <font color=#447700>! thermal conductivity, dry soil (W/m/Kelvin)<a name='117'></font>
    real(r8) :: csol(1,nlevsoil)        <font color=#447700>! heat capacity, soil solids (J/m**3/Kelvin)<a name='118'></font>
    CONTAINS<a name='119'>
 <a name='120'>
<a name='121'>
<A NAME='LAKE'><A href='../../html_code/phys/module_sf_lake.F.html#LAKE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='122'>
    <font color=#993300>SUBROUTINE </font><font color=#cc0000>Lake</font>( t_phy        ,p8w            ,dz8w         ,qvcurr          ,&amp;  <font color=#447700>!i <A href='../../call_to/LAKE.html' TARGET='index'>1</A>,<A href='../../call_from/LAKE.html' TARGET='index'>1</A><a name='123'></font>
                     u_phy        ,v_phy          , glw         ,emiss           ,&amp;<a name='124'>
                     rainbl       ,dtbl           ,swdown       ,albedo          ,&amp;<a name='125'>
                     xlat_urb2d   ,z_lake3d       ,dz_lake3d    ,lakedepth2d     ,&amp;<a name='126'>
                     watsat3d     ,csol3d         ,tkmg3d       ,tkdry3d         ,&amp;<a name='127'>
                     tksatu3d     ,ivgtyp         ,ht           ,xland           ,&amp; <a name='128'>
                     iswater, xice, xice_threshold, lake_min_elev                ,&amp;<a name='129'>
                     ids          ,ide            ,jds          ,jde             ,&amp;<a name='130'>
                     kds          ,kde            ,ims          ,ime             ,&amp;<a name='131'>
                     jms          ,jme            ,kms          ,kme             ,&amp;<a name='132'>
                     its          ,ite            ,jts          ,jte             ,&amp;<a name='133'>
                     kts          ,kte                                           ,&amp;<a name='134'>
                     h2osno2d     ,snowdp2d       ,snl2d        ,z3d             ,&amp;  <font color=#447700>!h<a name='135'></font>
                     dz3d         ,zi3d           ,h2osoi_vol3d ,h2osoi_liq3d    ,&amp;<a name='136'>
                     h2osoi_ice3d ,t_grnd2d       ,t_soisno3d   ,t_lake3d        ,&amp;<a name='137'>
                     savedtke12d  ,lake_icefrac3d                                ,&amp; <a name='138'>
#if (EM_CORE==1)<a name='139'>
             <font color=#447700>!        lakemask     ,lakeflag                                      ,&amp;<a name='140'></font>
                     lakemask                                          ,&amp;<a name='141'>
#endif<a name='142'>
                     hfx          ,lh             ,grdflx       ,tsk             ,&amp;  <font color=#447700>!o<a name='143'></font>
                     qfx          ,t2             ,th2          ,q2 )<a name='144'>
<a name='145'>
<font color=#447700>!==============================================================================<a name='146'></font>
<font color=#447700>! This subroutine was first edited by Hongping Gu and Jiming Jin for coupling<a name='147'></font>
<font color=#447700>! 07/20/2010<a name='148'></font>
<font color=#447700>!==============================================================================<a name='149'></font>
    IMPLICIT NONE<a name='150'>
    <a name='151'>
<font color=#447700>!in:<a name='152'></font>
    <a name='153'>
    INTEGER,  INTENT(IN   )   ::     ids,ide, jds,jde, kds,kde,  &amp;<a name='154'>
                                     ims,ime, jms,jme, kms,kme,  &amp;<a name='155'>
                                     its,ite, jts,jte, kts,kte<a name='156'>
    INTEGER , INTENT (IN) :: iswater<a name='157'>
    REAL,     INTENT(IN)  :: xice_threshold<a name='158'>
    REAL, DIMENSION( ims:ime , jms:jme ), INTENT(INOUT)::   XICE<a name='159'>
#if (EM_CORE==1)<a name='160'>
    REAL, DIMENSION( ims:ime , jms:jme ), INTENT(INOUT)::   LAKEMASK<a name='161'>
 <font color=#447700>!   INTEGER, INTENT(IN)::   LAKEFLAG<a name='162'></font>
#endif<a name='163'>
    <a name='164'>
    REAL,           DIMENSION( ims:ime, kms:kme, jms:jme ),INTENT(IN)  :: t_phy  <a name='165'>
    REAL,           DIMENSION( ims:ime, kms:kme, jms:jme ),INTENT(IN)  :: p8w    <a name='166'>
    REAL,           DIMENSION( ims:ime, kms:kme, jms:jme ),INTENT(IN)  :: dz8w<a name='167'>
    REAL,           DIMENSION( ims:ime, kms:kme, jms:jme ),INTENT(IN)  :: qvcurr<a name='168'>
    REAL, OPTIONAL, DIMENSION( ims:ime, kms:kme, jms:jme ),INTENT(IN)  :: U_PHY<a name='169'>
    REAL, OPTIONAL, DIMENSION( ims:ime, kms:kme, jms:jme ),INTENT(IN)  :: V_PHY<a name='170'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: glw<a name='171'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: emiss<a name='172'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: rainbl<a name='173'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: swdown<a name='174'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(INOUT)  :: albedo<a name='175'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: XLAND<a name='176'>
    REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: XLAT_URB2D<a name='177'>
    INTEGER,        DIMENSION( ims:ime, jms:jme )         ,INTENT(INOUT)  :: IVGTYP<a name='178'>
    REAL,                                                  INTENT(IN)  :: dtbl<a name='179'>
    <a name='180'>
    REAL,           DIMENSION( ims:ime,1:nlevlake,jms:jme ),INTENT(IN)  :: z_lake3d<a name='181'>
    REAL,           DIMENSION( ims:ime,1:nlevlake,jms:jme ),INTENT(IN)  :: dz_lake3d<a name='182'>
    REAL,           DIMENSION( ims:ime,1:nlevsoil,jms:jme ),INTENT(IN)  :: watsat3d<a name='183'>
    REAL,           DIMENSION( ims:ime,1:nlevsoil,jms:jme ),INTENT(IN)  :: csol3d<a name='184'>
    REAL,           DIMENSION( ims:ime,1:nlevsoil,jms:jme ),INTENT(IN)  :: tkmg3d<a name='185'>
    REAL,           DIMENSION( ims:ime,1:nlevsoil,jms:jme ),INTENT(IN)  :: tkdry3d<a name='186'>
    REAL,           DIMENSION( ims:ime,1:nlevsoil,jms:jme ),INTENT(IN)  :: tksatu3d<a name='187'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: lakedepth2d    <a name='188'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(IN)  :: ht<a name='189'>
    REAL                                                  ,INTENT(IN)  :: lake_min_elev<a name='190'>
<a name='191'>
<font color=#447700>!out:<a name='192'></font>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: HFX<a name='193'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: LH<a name='194'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: GRDFLX<a name='195'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: TSK<a name='196'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: QFX   <a name='197'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: T2<a name='198'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: TH2<a name='199'>
    REAL,           DIMENSION( ims:ime, jms:jme )         ,INTENT(OUT) :: Q2<a name='200'>
<a name='201'>
<font color=#447700>!in&amp;out:<a name='202'></font>
<a name='203'>
    real,           dimension(ims:ime,jms:jme )                ,intent(inout)  :: savedtke12d <a name='204'>
    real,           dimension(ims:ime,jms:jme )                ,intent(inout)  :: snowdp2d,       &amp;    <a name='205'>
                                                                                  h2osno2d,       &amp;    <a name='206'>
                                                                                  snl2d,          &amp;    <a name='207'>
                                                                                  t_grnd2d<a name='208'>
    <a name='209'>
    real,    dimension( ims:ime,1:nlevlake, jms:jme )           ,INTENT(inout)  :: t_lake3d,       &amp;    <a name='210'>
                                                                                  lake_icefrac3d<a name='211'>
    real,    dimension( ims:ime,-nlevsnow+1:nlevsoil, jms:jme )  ,INTENT(inout)  :: t_soisno3d,     &amp;    <a name='212'>
                                                                                  h2osoi_ice3d,   &amp;    <a name='213'>
                                                                                  h2osoi_liq3d,   &amp;    <a name='214'>
                                                                                  h2osoi_vol3d,   &amp;    <a name='215'>
                                                                                  z3d,            &amp;    <a name='216'>
                                                                                  dz3d <a name='217'>
    real,    dimension( ims:ime,-nlevsnow+0:nlevsoil, jms:jme )  ,INTENT(inout)  :: zi3d    <a name='218'>
       <a name='219'>
<a name='220'>
<font color=#447700>!local variable:<a name='221'></font>
<a name='222'>
    REAL     :: SFCTMP,PBOT,PSFC,ZLVL,Q2K,EMISSI,LWDN,PRCP,SOLDN,SOLNET<a name='223'>
    INTEGER  :: C,i,j,k<a name='224'>
<a name='225'>
<a name='226'>
      <font color=#447700>!tempory varibles in:<a name='227'></font>
      real(r8)  :: forc_t(1)          <font color=#447700>! atmospheric temperature (Kelvin)<a name='228'></font>
      real(r8)  :: forc_pbot(1)       <font color=#447700>! atm bottom level pressure (Pa) <a name='229'></font>
      real(r8)  :: forc_psrf(1)       <font color=#447700>! atmospheric surface pressure (Pa)<a name='230'></font>
      real(r8)  :: forc_hgt(1)        <font color=#447700>! atmospheric reference height (m)<a name='231'></font>
      real(r8)  :: forc_hgt_q(1)      <font color=#447700>! observational height of humidity [m]<a name='232'></font>
      real(r8)  :: forc_hgt_t(1)      <font color=#447700>! observational height of temperature [m]<a name='233'></font>
      real(r8)  :: forc_hgt_u(1)      <font color=#447700>! observational height of wind [m]<a name='234'></font>
      real(r8)  :: forc_q(1)          <font color=#447700>! atmospheric specific humidity (kg/kg)<a name='235'></font>
      real(r8)  :: forc_u(1)          <font color=#447700>! atmospheric wind speed in east direction (m/s)<a name='236'></font>
      real(r8)  :: forc_v(1)          <font color=#447700>! atmospheric wind speed in north direction (m/s)<a name='237'></font>
     <font color=#447700>! real(r8)  :: forc_rho(1)        ! density (kg/m**3)<a name='238'></font>
      real(r8)  :: forc_lwrad(1)      <font color=#447700>! downward infrared (longwave) radiation (W/m**2)<a name='239'></font>
      real(r8)  :: prec(1)               <font color=#447700>! snow or rain rate [mm/s]<a name='240'></font>
      real(r8)  :: sabg(1)            <font color=#447700>! solar radiation absorbed by ground (W/m**2)<a name='241'></font>
      real(r8)  :: lat(1)             <font color=#447700>! latitude (radians)<a name='242'></font>
      real(r8)  :: z_lake(1,nlevlake)  <font color=#447700>! layer depth for lake (m)<a name='243'></font>
      real(r8)  :: dz_lake(1,nlevlake)                  <font color=#447700>! layer thickness for lake (m)<a name='244'></font>
<a name='245'>
      real(r8)  :: lakedepth(1)       <font color=#447700>! column lake depth (m)<a name='246'></font>
      logical   :: do_capsnow(1)     <font color=#447700>! true =&gt; do snow capping<a name='247'></font>
<a name='248'>
      <font color=#447700>!in&amp;out<a name='249'></font>
      real(r8)  :: h2osoi_vol(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! volumetric soil water (0&lt;=h2osoi_vol&lt;=watsat)[m3/m3]<a name='250'></font>
      real(r8)  :: t_grnd(1)          <font color=#447700>! ground temperature (Kelvin)<a name='251'></font>
      real(r8)  :: h2osno(1)          <font color=#447700>! snow water (mm H2O)<a name='252'></font>
      real(r8)  :: snowdp(1)          <font color=#447700>! snow height (m)<a name='253'></font>
      real(r8)  :: z(1,-nlevsnow+1:nlevsoil)             <font color=#447700>! layer depth for snow &amp; soil (m)<a name='254'></font>
      real(r8)  :: dz(1,-nlevsnow+1:nlevsoil)            <font color=#447700>! layer thickness for soil or snow (m)<a name='255'></font>
      real(r8)  :: t_soisno(1,-nlevsnow+1:nlevsoil)      <font color=#447700>! soil (or snow) temperature (Kelvin)<a name='256'></font>
      real(r8)  :: t_lake(1,nlevlake)                   <font color=#447700>! lake temperature (Kelvin)<a name='257'></font>
      integer   :: snl(1)                              <font color=#447700>! number of snow layers<a name='258'></font>
      real(r8)  :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! liquid water (kg/m2)<a name='259'></font>
      real(r8)  :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! ice lens (kg/m2)<a name='260'></font>
      real(r8)  :: savedtke1(1)       <font color=#447700>! top level eddy conductivity from previous timestep (W/m.K)<a name='261'></font>
      real(r8)  :: zi(1,-nlevsnow+0:nlevsoil)            <font color=#447700>! interface level below a "z" level (m)<a name='262'></font>
      real(r8)  :: lake_icefrac(1,nlevlake)  <font color=#447700>! mass fraction of lake layer that is frozen<a name='263'></font>
<a name='264'>
<a name='265'>
      <font color=#447700>!out:<a name='266'></font>
      real(r8)  :: eflx_gnet(1)       <font color=#447700>!net heat flux into ground (W/m**2)<a name='267'></font>
      real(r8)  :: eflx_lwrad_net(1)  <font color=#447700>! net infrared (longwave) rad (W/m**2) [+ = to atm]<a name='268'></font>
      real(r8)  :: eflx_sh_tot(1)     <font color=#447700>! total sensible heat flux (W/m**2) [+ to atm]<a name='269'></font>
      real(r8)  :: eflx_lh_tot(1)     <font color=#447700>! total latent heat flux (W/m8*2)  [+ to atm]<a name='270'></font>
      real(r8)  :: t_ref2m(1)         <font color=#447700>! 2 m height surface air temperature (Kelvin)<a name='271'></font>
      real(r8)  :: q_ref2m(1)         <font color=#447700>! 2 m height surface specific humidity (kg/kg)<a name='272'></font>
      real(r8)  :: taux(1)            <font color=#447700>! wind (shear) stress: e-w (kg/m/s**2)<a name='273'></font>
      real(r8)  :: tauy(1)            <font color=#447700>! wind (shear) stress: n-s (kg/m/s**2)<a name='274'></font>
      real(r8)  :: ram1(1)            <font color=#447700>! aerodynamical resistance (s/m)<a name='275'></font>
                                               <font color=#447700>! for calculation of decay of eddy diffusivity with depth<a name='276'></font>
                                               <font color=#447700>! Change the type variable to pass back to WRF.<a name='277'></font>
      real(r8)  :: z0mg(1)            <font color=#447700>! roughness length over ground, momentum (m(<a name='278'></font>
<a name='279'>
<a name='280'>
      dtime = dtbl<a name='281'>
<a name='282'>
        DO J = jts,jte<a name='283'>
        DO I = its,ite<a name='284'>
<a name='285'>
           SFCTMP  = t_phy(i,1,j)<a name='286'>
           PBOT    = p8w(i,2,j)<a name='287'>
           PSFC    = P8w(i,1,j) <a name='288'>
           ZLVL    = 0.5 * dz8w(i,1,j) <a name='289'>
           Q2K     = qvcurr(i,1,j)/(1.0 + qvcurr(i,1,j))<a name='290'>
           EMISSI  = EMISS(I,J) <a name='291'>
           LWDN    = GLW(I,J)*EMISSI <a name='292'>
           PRCP    = RAINBL(i,j)/dtbl<a name='293'>
           SOLDN   = SWDOWN(I,J)                        <font color=#447700>! SOLDN is total incoming solar<a name='294'></font>
           SOLNET  = SOLDN*(1.-ALBEDO(I,J))             <font color=#447700>! use mid-day albedo to determine net downward solar<a name='295'></font>
                                                        <font color=#447700>! (no solar zenith angle correction) <a name='296'></font>
<font color=#447700>!        IF (XLAND(I,J).GT.1.5) THEN    <a name='297'></font>
<a name='298'>
       <font color=#447700>!  if ( xice(i,j).gt.xice_threshold) then<a name='299'></font>
       <font color=#447700>!   ivgtyp(i,j) = iswater<a name='300'></font>
       <font color=#447700>!   xland(i,j) = 2.<a name='301'></font>
       <font color=#447700>!   lake_icefrac3d(i,1,j) = xice(i,j)<a name='302'></font>
       <font color=#447700>!   endif<a name='303'></font>
<a name='304'>
#if (EM_CORE==1)<a name='305'>
        if (lakemask(i,j).eq.1) THEN<a name='306'>
#else<a name='307'>
        if (ivgtyp(i,j)==iswater.and.ht(i,j)&gt;= lake_min_elev ) THEN<a name='308'>
#endif<a name='309'>
    <a name='310'>
           do c = 1,column<a name='311'>
     <a name='312'>
            forc_t(c)          = SFCTMP           <font color=#447700>! [K]<a name='313'></font>
            forc_pbot(c)       = PBOT <a name='314'>
            forc_psrf(c)       = PSFC<a name='315'>
            forc_hgt(c)        = ZLVL             <font color=#447700>! [m]<a name='316'></font>
            forc_hgt_q(c)      = ZLVL             <font color=#447700>! [m]<a name='317'></font>
            forc_hgt_t(c)      = ZLVL             <font color=#447700>! [m]<a name='318'></font>
            forc_hgt_u(c)      = ZLVL             <font color=#447700>! [m]<a name='319'></font>
            forc_q(c)          = Q2K              <font color=#447700>! [kg/kg]<a name='320'></font>
            forc_u(c)          = U_PHY(I,1,J)<a name='321'>
            forc_v(c)          = V_PHY(I,1,J)<a name='322'>
           <font color=#447700>! forc_rho(c)        = SFCPRS / (287.04 * SFCTMP * (1.0+ 0.61 * Q2K)) ![kg/m/m/m] <a name='323'></font>
            forc_lwrad(c)      = LWDN             <font color=#447700>! [W/m/m]<a name='324'></font>
            prec(c)            = PRCP             <font color=#447700>! [mm/s]<a name='325'></font>
            sabg(c)            = SOLNET<a name='326'>
            lat(c)             = XLAT_URB2D(I,J)*pie/180  <font color=#447700>! [radian] <a name='327'></font>
            do_capsnow(c)      = .false.<a name='328'>
<a name='329'>
            lakedepth(c)           = lakedepth2d(i,j)<a name='330'>
            savedtke1(c)           = savedtke12d(i,j)<a name='331'>
            snowdp(c)              = snowdp2d(i,j)<a name='332'>
            h2osno(c)              = h2osno2d(i,j)<a name='333'>
            snl(c)                 = snl2d(i,j)<a name='334'>
            t_grnd(c)              = t_grnd2d(i,j)<a name='335'>
            do k = 1,nlevlake<a name='336'>
               t_lake(c,k)        = t_lake3d(i,k,j)<a name='337'>
               lake_icefrac(c,k)  = lake_icefrac3d(i,k,j)<a name='338'>
               z_lake(c,k)        = z_lake3d(i,k,j)<a name='339'>
               dz_lake(c,k)       = dz_lake3d(i,k,j)<a name='340'>
            enddo<a name='341'>
            do k = -nlevsnow+1,nlevsoil<a name='342'>
               t_soisno(c,k)      = t_soisno3d(i,k,j)<a name='343'>
	       h2osoi_ice(c,k)    = h2osoi_ice3d(i,k,j)<a name='344'>
               h2osoi_liq(c,k)    = h2osoi_liq3d(i,k,j)<a name='345'>
               h2osoi_vol(c,k)    = h2osoi_vol3d(i,k,j)<a name='346'>
               z(c,k)             = z3d(i,k,j)<a name='347'>
               dz(c,k)            = dz3d(i,k,j)<a name='348'>
            enddo   <a name='349'>
            do k = -nlevsnow+0,nlevsoil<a name='350'>
               zi(c,k)            = zi3d(i,k,j)<a name='351'>
            enddo<a name='352'>
            do k = 1,nlevsoil<a name='353'>
               watsat(c,k)        = watsat3d(i,k,j)<a name='354'>
               csol(c,k)          = csol3d(i,k,j)<a name='355'>
               tkmg(c,k)          = tkmg3d(i,k,j)<a name='356'>
               tkdry(c,k)         = tkdry3d(i,k,j)<a name='357'>
               tksatu(c,k)        = tksatu3d(i,k,j)<a name='358'>
            enddo<a name='359'>
            <a name='360'>
          enddo<a name='361'>
            CALL <A href='../../html_code/phys/module_sf_lake.F.html#LAKEMAIN'>LakeMain</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="LAKEMAIN_1">(forc_t,forc_pbot,forc_psrf,forc_hgt,forc_hgt_q,   &amp; <font color=#447700>!I  <a name='362'></font>
                          forc_hgt_t,forc_hgt_u,forc_q, forc_u,         &amp;<a name='363'>
                          forc_v,forc_lwrad,prec, sabg,lat,             &amp;<a name='364'>
                          z_lake,dz_lake,lakedepth,do_capsnow,          &amp;<a name='365'>
                          h2osno,snowdp,snl,z,dz,zi,                    &amp; <font color=#447700>!H<a name='366'></font>
                          h2osoi_vol,h2osoi_liq,h2osoi_ice,             &amp;<a name='367'>
                          t_grnd,t_soisno,t_lake,                       &amp;<a name='368'>
                          savedtke1,lake_icefrac,                       &amp;<a name='369'>
                          eflx_lwrad_net,eflx_gnet,                     &amp; <font color=#447700>!O <a name='370'></font>
                          eflx_sh_tot,eflx_lh_tot,                      &amp;<a name='371'>
                          t_ref2m,q_ref2m,                              &amp;<a name='372'>
                          taux,tauy,ram1,z0mg)<a name='373'>
<a name='374'>
<a name='375'>
           do c = 1,column<a name='376'>
            HFX(I,J)          = eflx_sh_tot(c)            <font color=#447700>![W/m/m]<a name='377'></font>
            LH(I,J)           = eflx_lh_tot(c)            <font color=#447700>!W/m/m]<a name='378'></font>
            GRDFLX(I,J)       = eflx_gnet(c)              <font color=#447700>!W/m/m]<a name='379'></font>
            TSK(I,J)          = t_grnd(c)                 <font color=#447700>![K]<a name='380'></font>
            T2(I,J)           = t_ref2m(c)<a name='381'>
            TH2(I,J)          = T2(I,J)*(1.E5/PSFC)**RCP<a name='382'>
            Q2(I,J)           = q_ref2m(c) <a name='383'>
            albedo(i,j)       = ( 0.6 * lake_icefrac(c,1) ) + ( (1.0-lake_icefrac(c,1)) * 0.08)  <a name='384'>
<a name='385'>
            if( tsk(i,j) &gt;= tfrz ) then<a name='386'>
                qfx(i,j)      = eflx_lh_tot(c)/hvap<a name='387'>
            else<a name='388'>
                qfx(i,j)      = eflx_lh_tot(c)/hsub       <font color=#447700>! heat flux (W/m^2)=&gt;mass flux(kg/(sm^2))<a name='389'></font>
            endif<a name='390'>
           enddo<a name='391'>
<a name='392'>
<font color=#447700>! Renew Lake State Varialbes:(14)<a name='393'></font>
           do c = 1,column<a name='394'>
<a name='395'>
            savedtke12d(i,j)         = savedtke1(c)<a name='396'>
            snowdp2d(i,j)            = snowdp(c)<a name='397'>
            h2osno2d(i,j)            = h2osno(c)<a name='398'>
	    snl2d(i,j)               = snl(c)<a name='399'>
            t_grnd2d(i,j)            = t_grnd(c)<a name='400'>
            do k = 1,nlevlake<a name='401'>
               t_lake3d(i,k,j)       = t_lake(c,k)<a name='402'>
	       lake_icefrac3d(i,k,j) = lake_icefrac(c,k)<a name='403'>
            enddo<a name='404'>
	    do k = -nlevsnow+1,nlevsoil<a name='405'>
	       z3d(i,k,j)            = z(c,k)<a name='406'>
	       dz3d(i,k,j)           = dz(c,k) <a name='407'>
	       t_soisno3d(i,k,j)     = t_soisno(c,k)<a name='408'>
	       h2osoi_liq3d(i,k,j)   = h2osoi_liq(c,k)<a name='409'>
	       h2osoi_ice3d(i,k,j)   = h2osoi_ice(c,k)<a name='410'>
               h2osoi_vol3d(i,k,j)   = h2osoi_vol(c,k)<a name='411'>
	   enddo<a name='412'>
           do k = -nlevsnow+0,nlevsoil<a name='413'>
               zi3d(i,k,j)           = zi(c,k)<a name='414'>
           enddo<a name='415'>
        <a name='416'>
         enddo<a name='417'>
<a name='418'>
        endif<a name='419'>
<font color=#447700>!        ENDIF    ! if xland = 2<a name='420'></font>
        ENDDO<a name='421'>
        ENDDO<a name='422'>
<a name='423'>
    END SUBROUTINE Lake<a name='424'>
<a name='425'>
<a name='426'>
<A NAME='LAKEMAIN'><A href='../../html_code/phys/module_sf_lake.F.html#LAKEMAIN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='427'>
    <font color=#993300>SUBROUTINE </font><font color=#cc0000>LakeMain</font>(forc_t,forc_pbot,forc_psrf,forc_hgt,forc_hgt_q,     &amp; <font color=#447700>!I   <A href='../../call_to/LAKEMAIN.html' TARGET='index'>1</A>,<A href='../../call_from/LAKEMAIN.html' TARGET='index'>3</A><a name='428'></font>
                          forc_hgt_t,forc_hgt_u,forc_q, forc_u,         &amp;   <a name='429'>
                          forc_v,forc_lwrad,prec, sabg,lat,             &amp;   <a name='430'>
                          z_lake,dz_lake,lakedepth,do_capsnow,          &amp;<a name='431'>
                          h2osno,snowdp,snl,z,dz,zi,                    &amp; <font color=#447700>!H<a name='432'></font>
                          h2osoi_vol,h2osoi_liq,h2osoi_ice,             &amp;<a name='433'>
                          t_grnd,t_soisno,t_lake,                       &amp;  <a name='434'>
                          savedtke1,lake_icefrac,                       &amp;<a name='435'>
                          eflx_lwrad_net,eflx_gnet,                     &amp; <font color=#447700>!O <a name='436'></font>
                          eflx_sh_tot,eflx_lh_tot,                      &amp;<a name='437'>
                          t_ref2m,q_ref2m,                              &amp;<a name='438'>
                          taux,tauy,ram1,z0mg)<a name='439'>
    implicit none<a name='440'>
<font color=#447700>!in: <a name='441'></font>
<a name='442'>
    real(r8),intent(in) :: forc_t(1)          <font color=#447700>! atmospheric temperature (Kelvin)<a name='443'></font>
    real(r8),intent(in) :: forc_pbot(1)       <font color=#447700>! atm bottom level pressure (Pa) <a name='444'></font>
    real(r8),intent(in) :: forc_psrf(1)       <font color=#447700>! atmospheric surface pressure (Pa)<a name='445'></font>
    real(r8),intent(in) :: forc_hgt(1)        <font color=#447700>! atmospheric reference height (m)<a name='446'></font>
    real(r8),intent(in) :: forc_hgt_q(1)      <font color=#447700>! observational height of humidity [m]<a name='447'></font>
    real(r8),intent(in) :: forc_hgt_t(1)      <font color=#447700>! observational height of temperature [m]<a name='448'></font>
    real(r8),intent(in) :: forc_hgt_u(1)      <font color=#447700>! observational height of wind [m]<a name='449'></font>
    real(r8),intent(in) :: forc_q(1)          <font color=#447700>! atmospheric specific humidity (kg/kg)<a name='450'></font>
    real(r8),intent(in) :: forc_u(1)          <font color=#447700>! atmospheric wind speed in east direction (m/s)<a name='451'></font>
    real(r8),intent(in) :: forc_v(1)          <font color=#447700>! atmospheric wind speed in north direction (m/s)<a name='452'></font>
   <font color=#447700>! real(r8),intent(in) :: forc_rho(1)        ! density (kg/m**3)<a name='453'></font>
    real(r8),intent(in) :: forc_lwrad(1)      <font color=#447700>! downward infrared (longwave) radiation (W/m**2)<a name='454'></font>
    real(r8),intent(in) :: prec(1)               <font color=#447700>! snow or rain rate [mm/s]<a name='455'></font>
    real(r8),intent(in) :: sabg(1)            <font color=#447700>! solar radiation absorbed by ground (W/m**2)<a name='456'></font>
    real(r8),intent(in) :: lat(1)             <font color=#447700>! latitude (radians)<a name='457'></font>
    real(r8),intent(in) :: z_lake(1,nlevlake)  <font color=#447700>! layer depth for lake (m)<a name='458'></font>
    real(r8),intent(in) :: dz_lake(1,nlevlake)                  <font color=#447700>! layer thickness for lake (m)<a name='459'></font>
<a name='460'>
    real(r8), intent(in) :: lakedepth(1)       <font color=#447700>! column lake depth (m)<a name='461'></font>
    <font color=#447700>!!!!!!!!!!!!!!!!tep(in),hydro(in)   <a name='462'></font>
   <font color=#447700>! real(r8), intent(in) :: watsat(1,1:nlevsoil)      ! volumetric soil water at saturation (porosity)<a name='463'></font>
    <font color=#447700>!!!!!!!!!!!!!!!!hydro<a name='464'></font>
    logical , intent(in) :: do_capsnow(1)     <font color=#447700>! true =&gt; do snow capping<a name='465'></font>
   <a name='466'>
<a name='467'>
<a name='468'>
<font color=#447700>!in&amp;out<a name='469'></font>
    real(r8),intent(inout) :: h2osoi_vol(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! volumetric soil water (0&lt;=h2osoi_vol&lt;=watsat)[m3/m3]<a name='470'></font>
    real(r8),intent(inout) :: t_grnd(1)          <font color=#447700>! ground temperature (Kelvin)<a name='471'></font>
    real(r8),intent(inout) :: h2osno(1)          <font color=#447700>! snow water (mm H2O)<a name='472'></font>
    real(r8),intent(inout) :: snowdp(1)          <font color=#447700>! snow height (m)<a name='473'></font>
    real(r8),intent(inout) :: z(1,-nlevsnow+1:nlevsoil)             <font color=#447700>! layer depth for snow &amp; soil (m)<a name='474'></font>
    real(r8),intent(inout) :: dz(1,-nlevsnow+1:nlevsoil)            <font color=#447700>! layer thickness for soil or snow (m)<a name='475'></font>
    real(r8),intent(inout) :: t_soisno(1,-nlevsnow+1:nlevsoil)      <font color=#447700>! soil (or snow) temperature (Kelvin)<a name='476'></font>
    real(r8),intent(inout) :: t_lake(1,nlevlake)                   <font color=#447700>! lake temperature (Kelvin)<a name='477'></font>
    integer ,intent(inout) :: snl(1)                              <font color=#447700>! number of snow layers<a name='478'></font>
    real(r8),intent(inout) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! liquid water (kg/m2)<a name='479'></font>
    real(r8),intent(inout) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! ice lens (kg/m2)<a name='480'></font>
    real(r8),intent(inout) :: savedtke1(1)       <font color=#447700>! top level eddy conductivity from previous timestep (W/m.K)<a name='481'></font>
    real(r8),intent(inout) :: zi(1,-nlevsnow+0:nlevsoil)            <font color=#447700>! interface level below a "z" level (m)<a name='482'></font>
    real(r8),intent(inout) :: lake_icefrac(1,nlevlake)  <font color=#447700>! mass fraction of lake layer that is frozen<a name='483'></font>
<a name='484'>
<a name='485'>
<font color=#447700>!out:<a name='486'></font>
    real(r8),intent(out) :: eflx_gnet(1)       <font color=#447700>!net heat flux into ground (W/m**2)<a name='487'></font>
    real(r8),intent(out) :: eflx_lwrad_net(1)  <font color=#447700>! net infrared (longwave) rad (W/m**2) [+ = to atm]<a name='488'></font>
    real(r8),intent(out) :: eflx_sh_tot(1)     <font color=#447700>! total sensible heat flux (W/m**2) [+ to atm]<a name='489'></font>
    real(r8),intent(out) :: eflx_lh_tot(1)     <font color=#447700>! total latent heat flux (W/m8*2)  [+ to atm]<a name='490'></font>
    real(r8),intent(out) :: t_ref2m(1)         <font color=#447700>! 2 m height surface air temperature (Kelvin)<a name='491'></font>
    real(r8),intent(out) :: q_ref2m(1)         <font color=#447700>! 2 m height surface specific humidity (kg/kg)<a name='492'></font>
    real(r8),intent(out) :: taux(1)            <font color=#447700>! wind (shear) stress: e-w (kg/m/s**2)<a name='493'></font>
    real(r8),intent(out) :: tauy(1)            <font color=#447700>! wind (shear) stress: n-s (kg/m/s**2)<a name='494'></font>
    real(r8),intent(out) :: ram1(1)            <font color=#447700>! aerodynamical resistance (s/m)<a name='495'></font>
                                               <font color=#447700>! for calculation of decay of eddy diffusivity with depth<a name='496'></font>
                                               <font color=#447700>! Change the type variable to pass back to WRF.<a name='497'></font>
    real(r8),intent(out) :: z0mg(1)            <font color=#447700>! roughness length over ground, momentum (m(<a name='498'></font>
<a name='499'>
<a name='500'>
<font color=#447700>!local output<a name='501'></font>
    <a name='502'>
    real(r8) :: begwb(1)           <font color=#447700>! water mass begining of the time step<a name='503'></font>
    real(r8) :: t_veg(1)           <font color=#447700>! vegetation temperature (Kelvin)<a name='504'></font>
    real(r8) :: eflx_soil_grnd(1)  <font color=#447700>! soil heat flux (W/m**2) [+ = into soil]<a name='505'></font>
    real(r8) :: eflx_lh_grnd(1)    <font color=#447700>! ground evaporation heat flux (W/m**2) [+ to atm]<a name='506'></font>
    real(r8) :: eflx_sh_grnd(1)    <font color=#447700>! sensible heat flux from ground (W/m**2) [+ to atm]<a name='507'></font>
    real(r8) :: eflx_lwrad_out(1)  <font color=#447700>! emitted infrared (longwave) radiation (W/m**2)<a name='508'></font>
    real(r8) :: qflx_evap_tot(1)   <font color=#447700>! qflx_evap_soi + qflx_evap_veg + qflx_tran_veg<a name='509'></font>
    real(r8) :: qflx_evap_soi(1)   <font color=#447700>! soil evaporation (mm H2O/s) (+ = to atm)<a name='510'></font>
    real(r8) :: qflx_prec_grnd(1)  <font color=#447700>! water onto ground including canopy runoff [kg/(m2 s)]<a name='511'></font>
    real(r8) :: forc_snow(1)       <font color=#447700>! snow rate [mm/s]<a name='512'></font>
    real(r8) :: forc_rain(1)       <font color=#447700>! rain rate [mm/s]<a name='513'></font>
    real(r8) :: ws(1)              <font color=#447700>! surface friction velocity (m/s)<a name='514'></font>
    real(r8) :: ks(1)              <font color=#447700>! coefficient passed to ShalLakeTemperature<a name='515'></font>
    real(r8) :: qflx_snomelt(1)    <font color=#447700>!snow melt (mm H2O /s) tem(out),snowwater(in)<a name='516'></font>
    integer  :: imelt(1,-nlevsnow+1:nlevsoil)      <font color=#447700>!flag for melting (=1), freezing (=2), Not=0 (new)<a name='517'></font>
    real(r8) :: endwb(1)         <font color=#447700>! water mass end of the time step<a name='518'></font>
    real(r8) :: snowage(1)       <font color=#447700>! non dimensional snow age [-]<a name='519'></font>
    real(r8) :: snowice(1)       <font color=#447700>! average snow ice lens<a name='520'></font>
    real(r8) :: snowliq(1)       <font color=#447700>! average snow liquid water<a name='521'></font>
    real(r8) :: t_snow(1)        <font color=#447700>! vertically averaged snow temperature<a name='522'></font>
    real(r8) :: qflx_drain(1)    <font color=#447700>! sub-surface runoff (mm H2O /s)<a name='523'></font>
    real(r8) :: qflx_surf(1)     <font color=#447700>! surface runoff (mm H2O /s)<a name='524'></font>
    real(r8) :: qflx_infl(1)     <font color=#447700>! infiltration (mm H2O /s)<a name='525'></font>
    real(r8) :: qflx_qrgwl(1)    <font color=#447700>! qflx_surf at glaciers, wetlands, lakes<a name='526'></font>
    real(r8) :: qcharge(1)       <font color=#447700>! aquifer recharge rate (mm/s)<a name='527'></font>
    real(r8) :: qflx_snowcap(1)       <font color=#447700>! excess precipitation due to snow capping (mm H2O /s) [+]<a name='528'></font>
    real(r8) :: qflx_snowcap_col(1)   <font color=#447700>! excess precipitation due to snow capping (mm H2O /s) [+]<a name='529'></font>
    real(r8) :: qflx_snow_grnd_pft(1) <font color=#447700>! snow on ground after interception (mm H2O/s) [+]<a name='530'></font>
    real(r8) :: qflx_snow_grnd_col(1) <font color=#447700>! snow on ground after interception (mm H2O/s) [+]<a name='531'></font>
    real(r8) :: qflx_rain_grnd(1)     <font color=#447700>! rain on ground after interception (mm H2O/s) [+]<a name='532'></font>
    real(r8) :: frac_iceold(1,-nlevsnow+1:nlevsoil)      <font color=#447700>! fraction of ice relative to the tot water<a name='533'></font>
    real(r8) :: qflx_evap_tot_col(1) <font color=#447700>!pft quantity averaged to the column (assuming one pft)<a name='534'></font>
    real(r8) :: soilalpha(1)     <font color=#447700>!factor that reduces ground saturated specific humidity (-)<a name='535'></font>
    real(r8) :: zwt(1)           <font color=#447700>!water table depth<a name='536'></font>
    real(r8) :: fcov(1)          <font color=#447700>!fractional area with water table at surface<a name='537'></font>
    real(r8) :: rootr_column(1,1:nlevsoil) <font color=#447700>!effective fraction of roots in each soil layer<a name='538'></font>
    real(r8) :: qflx_evap_grnd(1)  <font color=#447700>! ground surface evaporation rate (mm H2O/s) [+]<a name='539'></font>
    real(r8) :: qflx_sub_snow(1)   <font color=#447700>! sublimation rate from snow pack (mm H2O /s) [+]<a name='540'></font>
    real(r8) :: qflx_dew_snow(1)   <font color=#447700>! surface dew added to snow pack (mm H2O /s) [+]<a name='541'></font>
    real(r8) :: qflx_dew_grnd(1)   <font color=#447700>! ground surface dew formation (mm H2O /s) [+]<a name='542'></font>
    real(r8) :: qflx_rain_grnd_col(1)   <font color=#447700>!rain on ground after interception (mm H2O/s) [+]<a name='543'></font>
    <a name='544'>
<a name='545'>
<font color=#447700>!    lat  = lat*pie/180  ! [radian]<a name='546'></font>
<a name='547'>
    if (prec(1)&gt; 0.) then<a name='548'>
        if ( forc_t(1) &gt; (tfrz + tcrit)) then<a name='549'>
            forc_rain(1) = prec(1)<a name='550'>
            forc_snow(1) = 0.<a name='551'>
          <font color=#447700>!   flfall(1) = 1.<a name='552'></font>
         else<a name='553'>
            forc_rain(1) = 0.<a name='554'>
            forc_snow(1) = prec(1)<a name='555'>
<a name='556'>
          <font color=#447700>!  if ( forc_t(1) &lt;= tfrz) then<a name='557'></font>
          <font color=#447700>!      flfall(1) = 0.<a name='558'></font>
          <font color=#447700>!  else if ( forc_t(1) &lt;= tfrz+2.) then<a name='559'></font>
          <font color=#447700>!      flfall(1) = -54.632 + 0.2 *  forc_t(1)<a name='560'></font>
          <font color=#447700>!  else<a name='561'></font>
          <font color=#447700>!      flfall(1) = 0.4<a name='562'></font>
         endif<a name='563'>
    else<a name='564'>
         forc_rain(1) = 0.<a name='565'>
         forc_snow(1) = 0.<a name='566'>
       <font color=#447700>!  flfall(1) = 1.<a name='567'></font>
    endif<a name='568'>
<a name='569'>
    CALL <A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES'>ShalLakeFluxes</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SHALLAKEFLUXES_1">(forc_t,forc_pbot,forc_psrf,forc_hgt,forc_hgt_q,   &amp;  <font color=#447700>!i<a name='570'></font>
                          forc_hgt_t,forc_hgt_u,forc_q,                   &amp;<a name='571'>
                          forc_u,forc_v,forc_lwrad,forc_snow,             &amp;<a name='572'>
                          forc_rain,t_grnd,h2osno,snowdp,sabg,lat,        &amp;<a name='573'>
                          dz,dz_lake,t_soisno,t_lake,snl,h2osoi_liq,      &amp;<a name='574'>
                          h2osoi_ice,savedtke1,                           &amp;<a name='575'>
                          qflx_prec_grnd,qflx_evap_soi,qflx_evap_tot,     &amp;  <font color=#447700>!o<a name='576'></font>
                          eflx_sh_grnd,eflx_lwrad_out,eflx_lwrad_net,     &amp;<a name='577'>
                          eflx_soil_grnd,eflx_sh_tot,eflx_lh_tot,         &amp;<a name='578'>
                          eflx_lh_grnd,t_veg,t_ref2m,q_ref2m,taux,tauy,   &amp;<a name='579'>
                          ram1,ws,ks,eflx_gnet,z0mg)<a name='580'>
 <a name='581'>
<a name='582'>
    CALL <A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE'>ShalLakeTemperature</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SHALLAKETEMPERATURE_1">(t_grnd,h2osno,sabg,dz,dz_lake,z,zi,             &amp; <font color=#447700>!i<a name='583'></font>
                                 z_lake,ws,ks,snl,eflx_gnet,lakedepth,       &amp;<a name='584'>
                                 lake_icefrac,snowdp,                        &amp; <font color=#447700>!i&amp;o<a name='585'></font>
                                 eflx_sh_grnd,eflx_sh_tot,eflx_soil_grnd,    &amp; <font color=#447700>!o<a name='586'></font>
                                 t_lake,t_soisno,h2osoi_liq,                 &amp;<a name='587'>
                                 h2osoi_ice,savedtke1,                       &amp;<a name='588'>
                                 frac_iceold,qflx_snomelt,imelt)<a name='589'>
<a name='590'>
<a name='591'>
<a name='592'>
    CALL <A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY'>ShalLakeHydrology</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEMAIN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SHALLAKEHYDROLOGY_1">(dz_lake,forc_rain,forc_snow,                          &amp; <font color=#447700>!i<a name='593'></font>
                               begwb,qflx_evap_tot,forc_t,do_capsnow,            &amp;<a name='594'>
                               t_grnd,qflx_evap_soi,                             &amp;<a name='595'>
                               qflx_snomelt,imelt,frac_iceold,                   &amp; <font color=#447700>!i add by guhp<a name='596'></font>
                               z,dz,zi,snl,h2osno,snowdp,lake_icefrac,t_lake,      &amp; <font color=#447700>!i&amp;o<a name='597'></font>
                               endwb,snowage,snowice,snowliq,t_snow,             &amp; <font color=#447700>!o<a name='598'></font>
                               t_soisno,h2osoi_ice,h2osoi_liq,h2osoi_vol,        &amp;<a name='599'>
                               qflx_drain,qflx_surf,qflx_infl,qflx_qrgwl,        &amp;<a name='600'>
                               qcharge,qflx_prec_grnd,qflx_snowcap,              &amp;<a name='601'>
                               qflx_snowcap_col,qflx_snow_grnd_pft,              &amp;<a name='602'>
                               qflx_snow_grnd_col,qflx_rain_grnd,                &amp;<a name='603'>
                               qflx_evap_tot_col,soilalpha,zwt,fcov,             &amp;<a name='604'>
                               rootr_column,qflx_evap_grnd,qflx_sub_snow,        &amp;<a name='605'>
                               qflx_dew_snow,qflx_dew_grnd,qflx_rain_grnd_col)<a name='606'>
                       <a name='607'>
<font color=#447700>!==================================================================================<a name='608'></font>
<font color=#447700>! !DESCRIPTION:<a name='609'></font>
<font color=#447700>! Calculation of Shallow Lake Hydrology. Full hydrology of snow layers is<a name='610'></font>
<font color=#447700>! done. However, there is no infiltration, and the water budget is balanced with <a name='611'></font>
                       <a name='612'>
   END SUBROUTINE LakeMain<a name='613'>
<a name='614'>
<a name='615'>
<A NAME='SHALLAKEFLUXES'><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='616'>
<font color=#993300>SUBROUTINE </font><font color=#cc0000>ShalLakeFluxes</font>(forc_t,forc_pbot,forc_psrf,forc_hgt,forc_hgt_q,           &amp;  <font color=#447700>!i <A href='../../call_to/SHALLAKEFLUXES.html' TARGET='index'>1</A>,<A href='../../call_from/SHALLAKEFLUXES.html' TARGET='index'>10</A><a name='617'></font>
                          forc_hgt_t,forc_hgt_u,forc_q,                   &amp;<a name='618'>
                          forc_u,forc_v,forc_lwrad,forc_snow,             &amp;<a name='619'>
                          forc_rain,t_grnd,h2osno,snowdp,sabg,lat,        &amp;<a name='620'>
                          dz,dz_lake,t_soisno,t_lake,snl,h2osoi_liq,      &amp;<a name='621'>
                          h2osoi_ice,savedtke1,                           &amp;<a name='622'>
                          qflx_prec_grnd,qflx_evap_soi,qflx_evap_tot,     &amp;  <font color=#447700>!o<a name='623'></font>
                          eflx_sh_grnd,eflx_lwrad_out,eflx_lwrad_net,     &amp;<a name='624'>
                          eflx_soil_grnd,eflx_sh_tot,eflx_lh_tot,         &amp;<a name='625'>
                          eflx_lh_grnd,t_veg,t_ref2m,q_ref2m,taux,tauy,   &amp;<a name='626'>
                          ram1,ws,ks,eflx_gnet,z0mg)            <a name='627'>
<font color=#447700>!==============================================================================<a name='628'></font>
<font color=#447700>! DESCRIPTION:<a name='629'></font>
<font color=#447700>! Calculates lake temperatures and surface fluxes for shallow lakes.<a name='630'></font>
<font color=#447700>!<a name='631'></font>
<font color=#447700>! Shallow lakes have variable depth, possible snow layers above, freezing &amp; thawing of lake water,<a name='632'></font>
<font color=#447700>! and soil layers with active temperature and gas diffusion below.<a name='633'></font>
<font color=#447700>!<a name='634'></font>
<font color=#447700>! WARNING: This subroutine assumes lake columns have one and only one pft.<a name='635'></font>
<font color=#447700>!<a name='636'></font>
<font color=#447700>! REVISION HISTORY:<a name='637'></font>
<font color=#447700>! Created by Zack Subin, 2009<a name='638'></font>
<font color=#447700>! Reedited by Hongping Gu, 2010 <a name='639'></font>
<font color=#447700>!==============================================================================<a name='640'></font>
<a name='641'>
   <font color=#447700>! implicit none<a name='642'></font>
 <a name='643'>
    implicit none<a name='644'>
<a name='645'>
<font color=#447700>!in: <a name='646'></font>
<a name='647'>
    real(r8),intent(in) :: forc_t(1)          <font color=#447700>! atmospheric temperature (Kelvin)<a name='648'></font>
    real(r8),intent(in) :: forc_pbot(1)       <font color=#447700>! atmospheric pressure (Pa)<a name='649'></font>
    real(r8),intent(in) :: forc_psrf(1)       <font color=#447700>! atmospheric surface pressure (Pa)<a name='650'></font>
    real(r8),intent(in) :: forc_hgt(1)        <font color=#447700>! atmospheric reference height (m)<a name='651'></font>
    real(r8),intent(in) :: forc_hgt_q(1)      <font color=#447700>! observational height of humidity [m]<a name='652'></font>
    real(r8),intent(in) :: forc_hgt_t(1)      <font color=#447700>! observational height of temperature [m]<a name='653'></font>
    real(r8),intent(in) :: forc_hgt_u(1)      <font color=#447700>! observational height of wind [m]<a name='654'></font>
    real(r8),intent(in) :: forc_q(1)          <font color=#447700>! atmospheric specific humidity (kg/kg)<a name='655'></font>
    real(r8),intent(in) :: forc_u(1)          <font color=#447700>! atmospheric wind speed in east direction (m/s)<a name='656'></font>
    real(r8),intent(in) :: forc_v(1)          <font color=#447700>! atmospheric wind speed in north direction (m/s)<a name='657'></font>
    real(r8),intent(in) :: forc_lwrad(1)      <font color=#447700>! downward infrared (longwave) radiation (W/m**2)<a name='658'></font>
   <font color=#447700>! real(r8),intent(in) :: forc_rho(1)        ! density (kg/m**3)<a name='659'></font>
    real(r8),intent(in) :: forc_snow(1)       <font color=#447700>! snow rate [mm/s]<a name='660'></font>
    real(r8),intent(in) :: forc_rain(1)       <font color=#447700>! rain rate [mm/s]<a name='661'></font>
    real(r8),intent(in) :: h2osno(1)          <font color=#447700>! snow water (mm H2O)<a name='662'></font>
    real(r8),intent(in) :: snowdp(1)          <font color=#447700>! snow height (m)<a name='663'></font>
    real(r8),intent(in) :: sabg(1)            <font color=#447700>! solar radiation absorbed by ground (W/m**2)<a name='664'></font>
    real(r8),intent(in) :: lat(1)             <font color=#447700>! latitude (radians)<a name='665'></font>
    real(r8),intent(in) :: dz(1,-nlevsnow+1:nlevsoil)            <font color=#447700>! layer thickness for soil or snow (m)<a name='666'></font>
    real(r8),intent(in) :: dz_lake(1,nlevlake)                  <font color=#447700>! layer thickness for lake (m)<a name='667'></font>
    real(r8),intent(in) :: t_soisno(1,-nlevsnow+1:nlevsoil)      <font color=#447700>! soil (or snow) temperature (Kelvin)<a name='668'></font>
    real(r8),intent(in) :: t_lake(1,nlevlake)                   <font color=#447700>! lake temperature (Kelvin)<a name='669'></font>
    integer ,intent(in) :: snl(1)                              <font color=#447700>! number of snow layers<a name='670'></font>
    real(r8),intent(in) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! liquid water (kg/m2)<a name='671'></font>
    real(r8),intent(in) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! ice lens (kg/m2)<a name='672'></font>
    real(r8),intent(in) :: savedtke1(1)       <font color=#447700>! top level eddy conductivity from previous timestep (W/m.K)<a name='673'></font>
<a name='674'>
<font color=#447700>!inout:<a name='675'></font>
    real(r8),intent(inout) :: t_grnd(1)          <font color=#447700>! ground temperature (Kelvin)<a name='676'></font>
<font color=#447700>!out:<a name='677'></font>
    real(r8),intent(out):: qflx_prec_grnd(1)  <font color=#447700>! water onto ground including canopy runoff [kg/(m2 s)]<a name='678'></font>
    real(r8),intent(out):: qflx_evap_soi(1)   <font color=#447700>! soil evaporation (mm H2O/s) (+ = to atm)<a name='679'></font>
    real(r8),intent(out):: qflx_evap_tot(1)   <font color=#447700>! qflx_evap_soi + qflx_evap_veg + qflx_tran_veg<a name='680'></font>
    real(r8),intent(out):: eflx_sh_grnd(1)    <font color=#447700>! sensible heat flux from ground (W/m**2) [+ to atm]<a name='681'></font>
    real(r8),intent(out):: eflx_lwrad_out(1)  <font color=#447700>! emitted infrared (longwave) radiation (W/m**2)<a name='682'></font>
    real(r8),intent(out):: eflx_lwrad_net(1)  <font color=#447700>! net infrared (longwave) rad (W/m**2) [+ = to atm]<a name='683'></font>
    real(r8),intent(out):: eflx_soil_grnd(1)  <font color=#447700>! soil heat flux (W/m**2) [+ = into soil]<a name='684'></font>
    real(r8),intent(out):: eflx_sh_tot(1)     <font color=#447700>! total sensible heat flux (W/m**2) [+ to atm]<a name='685'></font>
    real(r8),intent(out):: eflx_lh_tot(1)     <font color=#447700>! total latent heat flux (W/m8*2)  [+ to atm]<a name='686'></font>
    real(r8),intent(out):: eflx_lh_grnd(1)    <font color=#447700>! ground evaporation heat flux (W/m**2) [+ to atm]<a name='687'></font>
    real(r8),intent(out):: t_veg(1)           <font color=#447700>! vegetation temperature (Kelvin)<a name='688'></font>
    real(r8),intent(out):: t_ref2m(1)         <font color=#447700>! 2 m height surface air temperature (Kelvin)<a name='689'></font>
    real(r8),intent(out):: q_ref2m(1)         <font color=#447700>! 2 m height surface specific humidity (kg/kg)<a name='690'></font>
    real(r8),intent(out):: taux(1)            <font color=#447700>! wind (shear) stress: e-w (kg/m/s**2)<a name='691'></font>
    real(r8),intent(out):: tauy(1)            <font color=#447700>! wind (shear) stress: n-s (kg/m/s**2)<a name='692'></font>
    real(r8),intent(out):: ram1(1)            <font color=#447700>! aerodynamical resistance (s/m)<a name='693'></font>
    real(r8),intent(out):: ws(1)              <font color=#447700>! surface friction velocity (m/s)<a name='694'></font>
    real(r8),intent(out):: ks(1)              <font color=#447700>! coefficient passed to ShalLakeTemperature<a name='695'></font>
                                               <font color=#447700>! for calculation of decay of eddy diffusivity with depth<a name='696'></font>
    real(r8),intent(out):: eflx_gnet(1)       <font color=#447700>!net heat flux into ground (W/m**2)<a name='697'></font>
                                               <font color=#447700>! Change the type variable to pass back to WRF.<a name='698'></font>
    real(r8),intent(out):: z0mg(1)            <font color=#447700>! roughness length over ground, momentum (m(<a name='699'></font>
<a name='700'>
<a name='701'>
<a name='702'>
<font color=#447700>!OTHER LOCAL VARIABLES:<a name='703'></font>
<a name='704'>
    integer , parameter :: islak  = 2       <font color=#447700>! index of lake, 1 = deep lake, 2 = shallow lake<a name='705'></font>
    integer , parameter :: niters = 3       <font color=#447700>! maximum number of iterations for surface temperature<a name='706'></font>
    real(r8), parameter :: beta1  = 1._r8   <font color=#447700>! coefficient of convective velocity (in computing W_*) [-]<a name='707'></font>
    real(r8), parameter :: emg    = 0.97_r8 <font color=#447700>! ground emissivity (0.97 for snow)<a name='708'></font>
    real(r8), parameter :: zii    = 1000._r8<font color=#447700>! convective boundary height [m]<a name='709'></font>
    real(r8), parameter :: tdmax  = 277._r8 <font color=#447700>! temperature of maximum water density<a name='710'></font>
    real(r8) :: forc_th(1)         <font color=#447700>! atmospheric potential temperature (Kelvin)<a name='711'></font>
    real(r8) :: forc_vp(1)         <font color=#447700>!atmospheric vapor pressure (Pa)<a name='712'></font>
    real(r8) :: forc_rho(1)        <font color=#447700>! density (kg/m**3)<a name='713'></font>
    integer  :: i,fc,fp,g,c,p           <font color=#447700>! do loop or array index<a name='714'></font>
    integer  :: fncopy                  <font color=#447700>! number of values in pft filter copy<a name='715'></font>
    integer  :: fnold                   <font color=#447700>! previous number of pft filter values<a name='716'></font>
    integer  :: fpcopy(num_shlakep)     <font color=#447700>! pft filter copy for iteration loop<a name='717'></font>
    integer  :: iter                    <font color=#447700>! iteration index<a name='718'></font>
    integer  :: nmozsgn(lbp:ubp)        <font color=#447700>! number of times moz changes sign<a name='719'></font>
    integer  :: jtop(lbc:ubc)           <font color=#447700>! top level for each column (no longer all 1)<a name='720'></font>
<font color=#447700>!    real(r8) :: dtime                   ! land model time step (sec)<a name='721'></font>
    real(r8) :: ax                      <font color=#447700>! used in iteration loop for calculating t_grnd (numerator of NR solution)<a name='722'></font>
    real(r8) :: bx                      <font color=#447700>! used in iteration loop for calculating t_grnd (denomin. of NR solution)<a name='723'></font>
    real(r8) :: degdT                   <font color=#447700>! d(eg)/dT<a name='724'></font>
    real(r8) :: dqh(lbp:ubp)            <font color=#447700>! diff of humidity between ref. height and surface<a name='725'></font>
    real(r8) :: dth(lbp:ubp)            <font color=#447700>! diff of virtual temp. between ref. height and surface<a name='726'></font>
    real(r8) :: dthv                    <font color=#447700>! diff of vir. poten. temp. between ref. height and surface<a name='727'></font>
    real(r8) :: dzsur(lbc:ubc)          <font color=#447700>! 1/2 the top layer thickness (m)<a name='728'></font>
    real(r8) :: eg                      <font color=#447700>! water vapor pressure at temperature T [pa]<a name='729'></font>
    real(r8) :: htvp(lbc:ubc)           <font color=#447700>! latent heat of vapor of water (or sublimation) [j/kg]<a name='730'></font>
    real(r8) :: obu(lbp:ubp)            <font color=#447700>! monin-obukhov length (m)<a name='731'></font>
    real(r8) :: obuold(lbp:ubp)         <font color=#447700>! monin-obukhov length of previous iteration<a name='732'></font>
    real(r8) :: qsatg(lbc:ubc)          <font color=#447700>! saturated humidity [kg/kg]<a name='733'></font>
    real(r8) :: qsatgdT(lbc:ubc)        <font color=#447700>! d(qsatg)/dT<a name='734'></font>
    real(r8) :: qstar                   <font color=#447700>! moisture scaling parameter<a name='735'></font>
    real(r8) :: ram(lbp:ubp)            <font color=#447700>! aerodynamical resistance [s/m]<a name='736'></font>
    real(r8) :: rah(lbp:ubp)            <font color=#447700>! thermal resistance [s/m]<a name='737'></font>
    real(r8) :: raw(lbp:ubp)            <font color=#447700>! moisture resistance [s/m]<a name='738'></font>
    real(r8) :: stftg3(lbp:ubp)         <font color=#447700>! derivative of fluxes w.r.t ground temperature<a name='739'></font>
    real(r8) :: temp1(lbp:ubp)          <font color=#447700>! relation for potential temperature profile<a name='740'></font>
    real(r8) :: temp12m(lbp:ubp)        <font color=#447700>! relation for potential temperature profile applied at 2-m<a name='741'></font>
    real(r8) :: temp2(lbp:ubp)          <font color=#447700>! relation for specific humidity profile<a name='742'></font>
    real(r8) :: temp22m(lbp:ubp)        <font color=#447700>! relation for specific humidity profile applied at 2-m<a name='743'></font>
    real(r8) :: tgbef(lbc:ubc)          <font color=#447700>! initial ground temperature<a name='744'></font>
    real(r8) :: thm(lbc:ubc)            <font color=#447700>! intermediate variable (forc_t+0.0098*forc_hgt_t)<a name='745'></font>
    real(r8) :: thv(lbc:ubc)            <font color=#447700>! virtual potential temperature (kelvin)<a name='746'></font>
    real(r8) :: thvstar                 <font color=#447700>! virtual potential temperature scaling parameter<a name='747'></font>
    real(r8) :: tksur                   <font color=#447700>! thermal conductivity of snow/soil (w/m/kelvin)<a name='748'></font>
    real(r8) :: tsur                    <font color=#447700>! top layer temperature<a name='749'></font>
    real(r8) :: tstar                   <font color=#447700>! temperature scaling parameter<a name='750'></font>
    real(r8) :: um(lbp:ubp)             <font color=#447700>! wind speed including the stablity effect [m/s]<a name='751'></font>
    real(r8) :: ur(lbp:ubp)             <font color=#447700>! wind speed at reference height [m/s]<a name='752'></font>
    real(r8) :: ustar(lbp:ubp)          <font color=#447700>! friction velocity [m/s]<a name='753'></font>
    real(r8) :: wc                      <font color=#447700>! convective velocity [m/s]<a name='754'></font>
    real(r8) :: zeta                    <font color=#447700>! dimensionless height used in Monin-Obukhov theory<a name='755'></font>
    real(r8) :: zldis(lbp:ubp)          <font color=#447700>! reference height "minus" zero displacement height [m]<a name='756'></font>
    real(r8) :: displa(lbp:ubp)         <font color=#447700>! displacement (always zero) [m]<a name='757'></font>
<font color=#447700>!    real(r8) :: z0mg(lbp:ubp)           ! roughness length over ground, momentum [m]<a name='758'></font>
    real(r8) :: z0hg(lbp:ubp)           <font color=#447700>! roughness length over ground, sensible heat [m]<a name='759'></font>
    real(r8) :: z0qg(lbp:ubp)           <font color=#447700>! roughness length over ground, latent heat [m]<a name='760'></font>
    real(r8) :: beta(2)                 <font color=#447700>! fraction solar rad absorbed at surface: depends on lake type<a name='761'></font>
    real(r8) :: u2m                     <font color=#447700>! 2 m wind speed (m/s)<a name='762'></font>
    real(r8) :: u10(1)         <font color=#447700>! 10-m wind (m/s) (for dust model)<a name='763'></font>
    real(r8) :: fv(1)          <font color=#447700>! friction velocity (m/s) (for dust model)<a name='764'></font>
<a name='765'>
    real(r8) :: fm(lbp:ubp)             <font color=#447700>! needed for BGC only to diagnose 10m wind speed<a name='766'></font>
    real(r8) :: bw                       <font color=#447700>! partial density of water (ice + liquid)<a name='767'></font>
    real(r8) :: t_grnd_temp              <font color=#447700>! Used in surface flux correction over frozen ground<a name='768'></font>
    real(r8) :: betaprime(lbc:ubc)       <font color=#447700>! Effective beta: 1 for snow layers, beta(islak) otherwise<a name='769'></font>
    character*256 :: message <a name='770'>
      <font color=#447700>! This assumes all radiation is absorbed in the top snow layer and will need<a name='771'></font>
      <font color=#447700>! to be changed for CLM 4.<a name='772'></font>
<font color=#447700>!<a name='773'></font>
<font color=#447700>! Constants for lake temperature model<a name='774'></font>
<font color=#447700>!<a name='775'></font>
    data beta/0.4_r8, 0.4_r8/  <font color=#447700>! (deep lake, shallow lake)<a name='776'></font>
    <font color=#447700>! This is the energy absorbed at the lake surface if no snow.<a name='777'></font>
<font color=#447700>!    data za  /0.6_r8, 0.5_r8/<a name='778'></font>
<font color=#447700>!    data eta /0.1_r8, 0.5_r8/<a name='779'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='780'></font>
<a name='781'>
<a name='782'>
<font color=#447700>!    dtime = get_step_size()<a name='783'></font>
<a name='784'>
<font color=#447700>! Begin calculations<a name='785'></font>
<a name='786'>
<font color=#447700>!dir$ concurrent<a name='787'></font>
<font color=#447700>!cdir nodep<a name='788'></font>
    forc_th(1)  = forc_t(1) * (forc_psrf(1)/ forc_pbot(1))**(rair/cpair)<a name='789'>
    forc_vp(1)  = forc_q(1) * forc_pbot(1)/ (0.622 + 0.378 * forc_q(1))<a name='790'>
    forc_rho(1) = (forc_pbot(1) - 0.378 * forc_vp(1)) / (rair * forc_t(1))<a name='791'>
<a name='792'>
    do fc = 1, num_shlakec<a name='793'>
       c = filter_shlakec(fc)<a name='794'>
       g = cgridcell(c)<a name='795'>
<a name='796'>
       <font color=#447700>! Surface temperature and fluxes<a name='797'></font>
<a name='798'>
       <font color=#447700>! Find top layer<a name='799'></font>
       if (snl(c) &gt; 0 .or. snl(c) &lt; -5) then<a name='800'>
         WRITE(message,*)  'snl is not defined in ShalLakeFluxesMod'<a name='801'>
         CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_898">(message)<a name='802'>
         CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1140">("snl: out of range value")<a name='803'>
       end if<a name='804'>
<font color=#447700>!       if (snl(c) /= 0) then<a name='805'></font>
<font color=#447700>!           write(6,*)'snl is not equal to zero in ShalLakeFluxesMod'<a name='806'></font>
<font color=#447700>!           call endrun()<a name='807'></font>
<font color=#447700>!       end if<a name='808'></font>
       jtop(c) = snl(c) + 1<a name='809'>
<a name='810'>
<a name='811'>
       if (snl(c) &lt; 0) then<a name='812'>
           betaprime(c) = 1._r8  <font color=#447700>!Assume all solar rad. absorbed at the surface of the top snow layer. <a name='813'></font>
           dzsur(c) = dz(c,jtop(c))/2._r8<a name='814'>
       else<a name='815'>
           betaprime(c) = <A href='../../html_code/phys/module_mp_nssl_2mom.F.html#BETA'>beta</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="BETA_3">(islak)<a name='816'>
           dzsur(c) = dz_lake(c,1)/2._r8<a name='817'>
       end if<a name='818'>
       <font color=#447700>! Originally this was 1*dz, but shouldn't it be 1/2?<a name='819'></font>
<a name='820'>
       <font color=#447700>! Saturated vapor pressure, specific humidity and their derivatives<a name='821'></font>
       <font color=#447700>! at lake surface<a name='822'></font>
<a name='823'>
       call <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>QSat</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_21">(t_grnd(c), forc_pbot(g), eg, degdT, qsatg(c), qsatgdT(c))<a name='824'>
<a name='825'>
       <font color=#447700>! Potential, virtual potential temperature, and wind speed at the<a name='826'></font>
       <font color=#447700>! reference height<a name='827'></font>
<a name='828'>
       thm(c) = forc_t(g) + 0.0098_r8*forc_hgt_t(g)   <font color=#447700>! intermediate variable<a name='829'></font>
       thv(c) = forc_th(g)*(1._r8+0.61_r8*forc_q(g))     <font color=#447700>! virtual potential T<a name='830'></font>
    end do<a name='831'>
<a name='832'>
<font color=#447700>!dir$ concurrent<a name='833'></font>
<font color=#447700>!cdir nodep<a name='834'></font>
    do fp = 1, num_shlakep<a name='835'>
       p = filter_shlakep(fp)<a name='836'>
       c = pcolumn(p)<a name='837'>
       g = pgridcell(p)<a name='838'>
<a name='839'>
       nmozsgn(p) = 0<a name='840'>
       obuold(p) = 0._r8<a name='841'>
       displa(p) = 0._r8<a name='842'>
<a name='843'>
       <font color=#447700>! Roughness lengths<a name='844'></font>
 <a name='845'>
<a name='846'>
<font color=#447700>! changed by Hongping Gu<a name='847'></font>
    <font color=#447700>!   if (t_grnd(c) &gt;= tfrz) then   ! for unfrozen lake<a name='848'></font>
    <font color=#447700>!      z0mg(p) = 0.01_r8<a name='849'></font>
    <font color=#447700>!   else                          ! for frozen lake<a name='850'></font>
    <font color=#447700>!   ! Is this okay even if it is snow covered?  What is the roughness over<a name='851'></font>
    <font color=#447700>!   non-veg. snow?<a name='852'></font>
    <font color=#447700>!      z0mg(p) = 0.04_r8<a name='853'></font>
    <font color=#447700>!   end if<a name='854'></font>
 <a name='855'>
       if (t_grnd(c) &gt;= tfrz) then   <font color=#447700>! for unfrozen lake<a name='856'></font>
          z0mg(p) = 0.001_r8        <font color=#447700>!original 0.01<a name='857'></font>
       else if(snl(c) == 0 ) then                         <font color=#447700>! for frozen lake<a name='858'></font>
       <font color=#447700>! Is this okay even if it is snow covered?  What is the roughness over<a name='859'></font>
       <font color=#447700>! non-veg. snow?<a name='860'></font>
          z0mg(p) = 0.005_r8          <font color=#447700>!original 0.04, now for frozen lake without snow<a name='861'></font>
       else                          <font color=#447700>! for frozen lake with snow   <a name='862'></font>
          z0mg(p) = 0.0024_r8<a name='863'>
       end if<a name='864'>
 <a name='865'>
 <a name='866'>
<a name='867'>
<a name='868'>
       z0hg(p) = z0mg(p)<a name='869'>
       z0qg(p) = z0mg(p)<a name='870'>
<a name='871'>
       <font color=#447700>! Latent heat<a name='872'></font>
<a name='873'>
#if (defined PERGRO)<a name='874'>
       htvp(c) = hvap<a name='875'>
#else<a name='876'>
       if (t_grnd(c) &gt; tfrz) then<a name='877'>
          htvp(c) = hvap<a name='878'>
       else<a name='879'>
          htvp(c) = hsub<a name='880'>
       end if<a name='881'>
#endif<a name='882'>
       <font color=#447700>! Zack Subin, 3/26/09: Shouldn't this be the ground temperature rather than the air temperature above?<a name='883'></font>
       <font color=#447700>! I'll change it for now.<a name='884'></font>
<a name='885'>
       <font color=#447700>! Initialize stability variables<a name='886'></font>
<a name='887'>
       ur(p)    = max(1.0_r8,sqrt(forc_u(g)*forc_u(g)+forc_v(g)*forc_v(g)))<a name='888'>
       dth(p)   = thm(c)-t_grnd(c)<a name='889'>
       dqh(p)   = forc_q(g)-qsatg(c)<a name='890'>
       dthv     = dth(p)*(1._r8+0.61_r8*forc_q(g))+0.61_r8*forc_th(g)*dqh(p)<a name='891'>
       zldis(p) = forc_hgt_u(g) - 0._r8<a name='892'>
<a name='893'>
       <font color=#447700>! Initialize Monin-Obukhov length and wind speed<a name='894'></font>
<a name='895'>
       call <A href='../../html_code/phys/module_sf_lake.F.html#MONINOBUKINI'>MoninObukIni</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MONINOBUKINI_4">(ur(p), thv(c), dthv, zldis(p), z0mg(p), um(p), obu(p))<a name='896'>
<a name='897'>
    end do<a name='898'>
<a name='899'>
    iter = 1<a name='900'>
    fncopy = num_shlakep<a name='901'>
    fpcopy(1:num_shlakep) = filter_shlakep(1:num_shlakep)<a name='902'>
<a name='903'>
    <font color=#447700>! Begin stability iteration<a name='904'></font>
<a name='905'>
    ITERATION : do while (iter &lt;= niters .and. fncopy &gt; 0)<a name='906'>
<a name='907'>
       <font color=#447700>! Determine friction velocity, and potential temperature and humidity<a name='908'></font>
       <font color=#447700>! profiles of the surface boundary layer<a name='909'></font>
<a name='910'>
       call <A href='../../html_code/phys/module_sf_lake.F.html#FRICTIONVELOCITY'>FrictionVelocity</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="FRICTIONVELOCITY_4">(pgridcell,forc_hgt,forc_hgt_u,          &amp; <font color=#447700>!i<a name='911'></font>
                             forc_hgt_t,forc_hgt_q,                  &amp; <font color=#447700>!i<a name='912'></font>
                             lbp, ubp, fncopy, fpcopy,               &amp; <font color=#447700>!i<a name='913'></font>
                             displa, z0mg, z0hg, z0qg,               &amp; <font color=#447700>!i<a name='914'></font>
                             obu, iter, ur, um,                      &amp; <font color=#447700>!i<a name='915'></font>
                             ustar,temp1, temp2, temp12m, temp22m,   &amp; <font color=#447700>!o<a name='916'></font>
                             u10,fv,                                 &amp; <font color=#447700>!o<a name='917'></font>
                             fm)  <font color=#447700>!i&amp;o<a name='918'></font>
<a name='919'>
<font color=#447700>!dir$ concurrent<a name='920'></font>
<font color=#447700>!cdir nodep<a name='921'></font>
       do fp = 1, fncopy<a name='922'>
          p = fpcopy(fp)<a name='923'>
          c = pcolumn(p)<a name='924'>
          g = pgridcell(p)<a name='925'>
<a name='926'>
          tgbef(c) = t_grnd(c)<a name='927'>
          if (t_grnd(c) &gt; tfrz .and. t_lake(c,1) &gt; tfrz .and. snl(c) == 0) then<a name='928'>
             tksur = savedtke1(c)<a name='929'>
             <font color=#447700>! Set this to the eddy conductivity from the last<a name='930'></font>
             <font color=#447700>! timestep, as the molecular conductivity will be orders of magnitude too small.<a name='931'></font>
             <font color=#447700>! Will have to deal with first timestep.<a name='932'></font>
             tsur = t_lake(c,1)<a name='933'>
          else if (snl(c) == 0) then  <font color=#447700>!frozen but no snow layers<a name='934'></font>
             tksur = tkice<a name='935'>
             tsur = t_lake(c,1)<a name='936'>
          else<a name='937'>
          <font color=#447700>!Need to calculate thermal conductivity of the top snow layer<a name='938'></font>
             bw = (h2osoi_ice(c,jtop(c))+h2osoi_liq(c,jtop(c)))/dz(c,jtop(c))<a name='939'>
             tksur = tkairc + (7.75e-5_r8 *bw + 1.105e-6_r8*bw*bw)*(tkice-tkairc)<a name='940'>
             tsur = t_soisno(c,jtop(c))<a name='941'>
          end if<a name='942'>
<a name='943'>
          <font color=#447700>! Determine aerodynamic resistances<a name='944'></font>
<a name='945'>
          ram(p)  = 1._r8/(ustar(p)*ustar(p)/um(p))<a name='946'>
          rah(p)  = 1._r8/(temp1(p)*ustar(p))<a name='947'>
          raw(p)  = 1._r8/(temp2(p)*ustar(p))<a name='948'>
          ram1(p) = ram(p)   <font color=#447700>!pass value to global variable<a name='949'></font>
<a name='950'>
          <font color=#447700>! Get derivative of fluxes with respect to ground temperature<a name='951'></font>
<a name='952'>
          stftg3(p) = emg*sb*tgbef(c)*tgbef(c)*tgbef(c)<a name='953'>
<a name='954'>
          <font color=#447700>! Changed surface temperature from t_lake(c,1) to tsur.<a name='955'></font>
          <font color=#447700>! Also adjusted so that if there are snow layers present, all radiation is absorbed in the top layer.<a name='956'></font>
          ax  = betaprime(c)*sabg(p) + emg*forc_lwrad(g) + 3._r8*stftg3(p)*tgbef(c) &amp;<a name='957'>
               + forc_rho(g)*cpair/rah(p)*thm(c) &amp;<a name='958'>
               - htvp(c)*forc_rho(g)/raw(p)*(qsatg(c)-qsatgdT(c)*tgbef(c) - forc_q(g)) &amp;<a name='959'>
               + tksur*tsur/dzsur(c)<a name='960'>
          <font color=#447700>!Changed sabg(p) and to betaprime(c)*sabg(p).<a name='961'></font>
          bx  = 4._r8*stftg3(p) + forc_rho(g)*cpair/rah(p) &amp;<a name='962'>
               + htvp(c)*forc_rho(g)/raw(p)*qsatgdT(c) + tksur/dzsur(c)<a name='963'>
<a name='964'>
          t_grnd(c) = ax/bx<a name='965'>
<a name='966'>
          <font color=#447700>! Update htvp<a name='967'></font>
#ifndef PERGRO<a name='968'>
       if (t_grnd(c) &gt; tfrz) then<a name='969'>
          htvp(c) = hvap<a name='970'>
       else<a name='971'>
          htvp(c) = hsub<a name='972'>
       end if<a name='973'>
#endif<a name='974'>
<a name='975'>
          <font color=#447700>! Surface fluxes of momentum, sensible and latent heat<a name='976'></font>
          <font color=#447700>! using ground temperatures from previous time step<a name='977'></font>
<a name='978'>
          eflx_sh_grnd(p) = forc_rho(g)*cpair*(t_grnd(c)-thm(c))/rah(p)<a name='979'>
          qflx_evap_soi(p) = forc_rho(g)*(qsatg(c)+qsatgdT(c)*(t_grnd(c)-tgbef(c))-forc_q(g))/raw(p)<a name='980'>
<a name='981'>
          <font color=#447700>! Re-calculate saturated vapor pressure, specific humidity and their<a name='982'></font>
          <font color=#447700>! derivatives at lake surface<a name='983'></font>
<a name='984'>
          call <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>QSat</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_22">(t_grnd(c), forc_pbot(g), eg, degdT, qsatg(c), qsatgdT(c))<a name='985'>
<a name='986'>
          dth(p)=thm(c)-t_grnd(c)<a name='987'>
          dqh(p)=forc_q(g)-qsatg(c)<a name='988'>
<a name='989'>
          tstar = temp1(p)*dth(p)<a name='990'>
          qstar = temp2(p)*dqh(p)<a name='991'>
<a name='992'>
          thvstar=tstar*(1._r8+0.61_r8*forc_q(g)) + 0.61_r8*forc_th(g)*qstar<a name='993'>
          zeta=zldis(p)*vkc * grav*thvstar/(ustar(p)**2*thv(c))<a name='994'>
<a name='995'>
          if (zeta &gt;= 0._r8) then     <font color=#447700>!stable<a name='996'></font>
             zeta = min(2._r8,max(zeta,0.01_r8))<a name='997'>
             um(p) = max(ur(p),0.1_r8)<a name='998'>
          else                     <font color=#447700>!unstable<a name='999'></font>
             zeta = max(-100._r8,min(zeta,-0.01_r8))<a name='1000'>
             wc = beta1*(-grav*ustar(p)*thvstar*zii/thv(c))**0.333_r8<a name='1001'>
             um(p) = sqrt(ur(p)*ur(p)+wc*wc)<a name='1002'>
          end if<a name='1003'>
          obu(p) = zldis(p)/zeta<a name='1004'>
<a name='1005'>
          if (obuold(p)*obu(p) &lt; 0._r8) nmozsgn(p) = nmozsgn(p)+1<a name='1006'>
<a name='1007'>
          obuold(p) = obu(p)<a name='1008'>
<a name='1009'>
       end do   <font color=#447700>! end of filtered pft loop<a name='1010'></font>
<a name='1011'>
       iter = iter + 1<a name='1012'>
       if (iter &lt;= niters ) then<a name='1013'>
          <font color=#447700>! Rebuild copy of pft filter for next pass through the ITERATION loop<a name='1014'></font>
<a name='1015'>
          fnold = fncopy<a name='1016'>
          fncopy = 0<a name='1017'>
          do fp = 1, fnold<a name='1018'>
             p = fpcopy(fp)<a name='1019'>
             if (nmozsgn(p) &lt; 3) then<a name='1020'>
                fncopy = fncopy + 1<a name='1021'>
                fpcopy(fncopy) = p<a name='1022'>
             end if<a name='1023'>
          end do   <font color=#447700>! end of filtered pft loop<a name='1024'></font>
       end if<a name='1025'>
<a name='1026'>
    end do ITERATION   <font color=#447700>! end of stability iteration<a name='1027'></font>
<a name='1028'>
<font color=#447700>!dir$ concurrent<a name='1029'></font>
<font color=#447700>!cdir nodep<a name='1030'></font>
    do fp = 1, num_shlakep<a name='1031'>
       p = filter_shlakep(fp)<a name='1032'>
       c = pcolumn(p)<a name='1033'>
       g = pgridcell(p)<a name='1034'>
<a name='1035'>
       <font color=#447700>! If there is snow on the ground and t_grnd &gt; tfrz: reset t_grnd = tfrz.<a name='1036'></font>
       <font color=#447700>! Re-evaluate ground fluxes.<a name='1037'></font>
       <font color=#447700>! h2osno &gt; 0.5 prevents spurious fluxes.<a name='1038'></font>
       <font color=#447700>! note that qsatg and qsatgdT should be f(tgbef) (PET: not sure what this<a name='1039'></font>
       <font color=#447700>! comment means)<a name='1040'></font>
       <font color=#447700>! Zack Subin, 3/27/09: Since they are now a function of whatever t_grnd was before cooling<a name='1041'></font>
       <font color=#447700>!    to freezing temperature, then this value should be used in the derivative correction term.<a name='1042'></font>
       <font color=#447700>! Should this happen if the lake temperature is below freezing, too? I'll assume that for now.<a name='1043'></font>
       <font color=#447700>! Also, allow convection if ground temp is colder than lake but warmer than 4C, or warmer than <a name='1044'></font>
       <font color=#447700>!    lake which is warmer than freezing but less than 4C.<a name='1045'></font>
<font color=#447700>!#ifndef SHLAKETEST<a name='1046'></font>
       if ( (h2osno(c) &gt; 0.5_r8 .or. t_lake(c,1) &lt;= tfrz) .and. t_grnd(c) &gt; tfrz) then<a name='1047'>
<font color=#447700>!#else<a name='1048'></font>
<font color=#447700>!       if ( t_lake(c,1) &lt;= tfrz .and. t_grnd(c) &gt; tfrz) then<a name='1049'></font>
<font color=#447700>!#endif<a name='1050'></font>
          t_grnd_temp = t_grnd(c)<a name='1051'>
          t_grnd(c) = tfrz<a name='1052'>
          eflx_sh_grnd(p) = forc_rho(g)*cpair*(t_grnd(c)-thm(c))/rah(p)<a name='1053'>
          qflx_evap_soi(p) = forc_rho(g)*(qsatg(c)+qsatgdT(c)*(t_grnd(c)-t_grnd_temp) - forc_q(g))/raw(p)<a name='1054'>
       else if ( (t_lake(c,1) &gt; t_grnd(c) .and. t_grnd(c) &gt; tdmax) .or. &amp;<a name='1055'>
                 (t_lake(c,1) &lt; t_grnd(c) .and. t_lake(c,1) &gt; tfrz .and. t_grnd(c) &lt; tdmax) ) then<a name='1056'>
                 <font color=#447700>! Convective mixing will occur at surface<a name='1057'></font>
          t_grnd_temp = t_grnd(c)<a name='1058'>
          t_grnd(c) = t_lake(c,1)<a name='1059'>
          eflx_sh_grnd(p) = forc_rho(g)*cpair*(t_grnd(c)-thm(c))/rah(p)<a name='1060'>
          qflx_evap_soi(p) = forc_rho(g)*(qsatg(c)+qsatgdT(c)*(t_grnd(c)-t_grnd_temp) - forc_q(g))/raw(p)<a name='1061'>
       end if<a name='1062'>
<a name='1063'>
          <font color=#447700>! Update htvp<a name='1064'></font>
#ifndef PERGRO<a name='1065'>
       if (t_grnd(c) &gt; tfrz) then<a name='1066'>
          htvp(c) = hvap<a name='1067'>
       else<a name='1068'>
          htvp(c) = hsub<a name='1069'>
       end if<a name='1070'>
#endif<a name='1071'>
<a name='1072'>
       <font color=#447700>! Net longwave from ground to atmosphere<a name='1073'></font>
<a name='1074'>
<font color=#447700>!       eflx_lwrad_out(p) = (1._r8-emg)*forc_lwrad(g) + stftg3(p)*(-3._r8*tgbef(c)+4._r8*t_grnd(c))<a name='1075'></font>
       <font color=#447700>! What is tgbef doing in this equation? Can't it be exact now? --Zack Subin, 4/14/09<a name='1076'></font>
       eflx_lwrad_out(p) = (1._r8-emg)*forc_lwrad(g) + emg*sb*t_grnd(c)**4<a name='1077'>
<a name='1078'>
       <font color=#447700>! Ground heat flux<a name='1079'></font>
<a name='1080'>
       eflx_soil_grnd(p) = sabg(p) + forc_lwrad(g) - eflx_lwrad_out(p) - &amp;<a name='1081'>
            eflx_sh_grnd(p) - htvp(c)*qflx_evap_soi(p)<a name='1082'>
       <font color=#447700>!Why is this sabg(p) and not beta*sabg(p)??<a name='1083'></font>
       <font color=#447700>!I've kept this as the incorrect sabg so that the energy balance check will be correct.<a name='1084'></font>
       <font color=#447700>!This is the effective energy flux into the ground including the lake solar absorption<a name='1085'></font>
       <font color=#447700>!below the surface.  The variable eflx_gnet will be used to pass the actual heat flux<a name='1086'></font>
       <font color=#447700>!from the ground interface into the lake.<a name='1087'></font>
<a name='1088'>
       taux(p) = -forc_rho(g)*forc_u(g)/ram(p)<a name='1089'>
       tauy(p) = -forc_rho(g)*forc_v(g)/ram(p)<a name='1090'>
<a name='1091'>
       eflx_sh_tot(p)   = eflx_sh_grnd(p)<a name='1092'>
       qflx_evap_tot(p) = qflx_evap_soi(p)<a name='1093'>
       eflx_lh_tot(p)   = htvp(c)*qflx_evap_soi(p)<a name='1094'>
       eflx_lh_grnd(p)  = htvp(c)*qflx_evap_soi(p)<a name='1095'>
#if (defined LAKEDEBUG)<a name='1096'>
       write(message,*) 'c, sensible heat = ', c, eflx_sh_tot(p), 'latent heat = ', eflx_lh_tot(p) &amp;<a name='1097'>
              , 'ground temp = ', t_grnd(c), 'h2osno = ', h2osno(c)<a name='1098'>
       CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_899">(message)<a name='1099'>
       if (abs(eflx_sh_tot(p)) &gt; 1500 .or. abs(eflx_lh_tot(p)) &gt; 1500) then<a name='1100'>
           write(message,*)'WARNING: SH, LH = ', eflx_sh_tot(p), eflx_lh_tot(p)<a name='1101'>
           CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_900">(message)<a name='1102'>
       end if<a name='1103'>
       if (abs(eflx_sh_tot(p)) &gt; 10000 .or. abs(eflx_lh_tot(p)) &gt; 10000 &amp;<a name='1104'>
             .or. abs(t_grnd(c)-288)&gt;200 ) CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEFLUXES' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1141"> ( 't_grnd is out of range' ) <a name='1105'>
#endif<a name='1106'>
       <font color=#447700>! 2 m height air temperature<a name='1107'></font>
       t_ref2m(p) = thm(c) + temp1(p)*dth(p)*(1._r8/temp12m(p) - 1._r8/temp1(p))<a name='1108'>
<a name='1109'>
       <font color=#447700>! 2 m height specific humidity<a name='1110'></font>
       q_ref2m(p) = forc_q(g) + temp2(p)*dqh(p)*(1._r8/temp22m(p) - 1._r8/temp2(p))<a name='1111'>
<a name='1112'>
       <font color=#447700>! Energy residual used for melting snow<a name='1113'></font>
       <font color=#447700>! Effectively moved to ShalLakeTemp<a name='1114'></font>
<a name='1115'>
       <font color=#447700>! Prepare for lake layer temperature calculations below<a name='1116'></font>
       <font color=#447700>! fin(c) = betaprime * sabg(p) + forc_lwrad(g) - (eflx_lwrad_out(p) + &amp;<a name='1117'></font>
       <font color=#447700>!          eflx_sh_tot(p) + eflx_lh_tot(p))<a name='1118'></font>
       <font color=#447700>! NOW this is just the net ground heat flux calculated below.<a name='1119'></font>
<a name='1120'>
       eflx_gnet(p) = betaprime(c) * sabg(p) + forc_lwrad(g) - (eflx_lwrad_out(p) + &amp;<a name='1121'>
            eflx_sh_tot(p) + eflx_lh_tot(p))<a name='1122'>
       <font color=#447700>! This is the actual heat flux from the ground interface into the lake, not including<a name='1123'></font>
       <font color=#447700>! the light that penetrates the surface.<a name='1124'></font>
<a name='1125'>
<font color=#447700>!       u2m = max(1.0_r8,ustar(p)/vkc*log(2._r8/z0mg(p)))<a name='1126'></font>
       <font color=#447700>! u2 often goes below 1 m/s; it seems like the only reason for this minimum is to<a name='1127'></font>
       <font color=#447700>! keep it from being zero in the ks equation below; 0.1 m/s is a better limit for<a name='1128'></font>
       <font color=#447700>! stable conditions --ZS<a name='1129'></font>
       u2m = max(0.1_r8,ustar(p)/vkc*log(2._r8/z0mg(p)))<a name='1130'>
<a name='1131'>
       ws(c) = 1.2e-03_r8 * u2m<a name='1132'>
       ks(c) = 6.6_r8*sqrt(abs(sin(lat(g))))*(u2m**(-1.84_r8))<a name='1133'>
<a name='1134'>
    end do<a name='1135'>
<a name='1136'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='1137'></font>
    <font color=#447700>! End of surface flux relevant code in original BiogeophysicsLakeMod until history loop.<a name='1138'></font>
<a name='1139'>
    <font color=#447700>! The following are needed for global average on history tape.<a name='1140'></font>
<a name='1141'>
<font color=#447700>!dir$ concurrent<a name='1142'></font>
<font color=#447700>!cdir nodep<a name='1143'></font>
    do fp = 1, num_shlakep<a name='1144'>
       p = filter_shlakep(fp)<a name='1145'>
       c = pcolumn(p)<a name='1146'>
       g = pgridcell(p)<a name='1147'>
<font color=#447700>!       t_veg(p) = forc_t(g)<a name='1148'></font>
        <font color=#447700>!This is an odd choice, since elsewhere t_veg = t_grnd for bare ground.<a name='1149'></font>
        <font color=#447700>!Zack Subin, 4/09<a name='1150'></font>
       t_veg(p) = t_grnd(c)<a name='1151'>
       eflx_lwrad_net(p)  = eflx_lwrad_out(p) - forc_lwrad(g)<a name='1152'>
       qflx_prec_grnd(p) = forc_rain(g) + forc_snow(g)<a name='1153'>
    end do<a name='1154'>
<a name='1155'>
END SUBROUTINE ShalLakeFluxes<a name='1156'>
 <a name='1157'>
<A NAME='SHALLAKETEMPERATURE'><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1158'>
<font color=#993300>SUBROUTINE </font><font color=#cc0000>ShalLakeTemperature</font>(t_grnd,h2osno,sabg,dz,dz_lake,z,zi,           &amp; <font color=#447700>!i <A href='../../call_to/SHALLAKETEMPERATURE.html' TARGET='index'>1</A>,<A href='../../call_from/SHALLAKETEMPERATURE.html' TARGET='index'>13</A><a name='1159'></font>
                                 z_lake,ws,ks,snl,eflx_gnet,lakedepth,       &amp;<a name='1160'>
                                 lake_icefrac,snowdp,                        &amp; <font color=#447700>!i&amp;o<a name='1161'></font>
                                 eflx_sh_grnd,eflx_sh_tot,eflx_soil_grnd,    &amp; <font color=#447700>!o<a name='1162'></font>
                                 t_lake,t_soisno,h2osoi_liq,                 &amp;<a name='1163'>
                                 h2osoi_ice,savedtke1,                       &amp;<a name='1164'>
                                 frac_iceold,qflx_snomelt,imelt)<a name='1165'>
<font color=#447700>!=======================================================================================================<a name='1166'></font>
<font color=#447700>! !DESCRIPTION:<a name='1167'></font>
<font color=#447700>! Calculates temperatures in the 20-25 layer column of (possible) snow,<a name='1168'></font>
<font color=#447700>! lake water, and soil beneath lake.<a name='1169'></font>
<font color=#447700>! Snow and soil temperatures are determined as in SoilTemperature, except<a name='1170'></font>
<font color=#447700>! for appropriate boundary conditions at the top of the snow (the flux is fixed<a name='1171'></font>
<font color=#447700>! to be the ground heat flux calculated in ShalLakeFluxes), the bottom of the snow<a name='1172'></font>
<font color=#447700>! (adjacent to top lake layer), and the top of the soil (adjacent to the bottom<a name='1173'></font>
<font color=#447700>! lake layer). Also, the soil is assumed to be always fully saturated (ShalLakeHydrology<a name='1174'></font>
<font color=#447700>! will have to insure this). The whole column is solved simultaneously as one tridiagonal matrix.<a name='1175'></font>
<font color=#447700>! Lake temperatures are determined from the Hostetler model as before, except now:<a name='1176'></font>
<font color=#447700>!    i) Lake water layers can freeze by any fraction and release latent heat; thermal<a name='1177'></font>
<font color=#447700>!       and mechanical properties are adjusted for ice fraction.<a name='1178'></font>
<font color=#447700>!   ii) Convective mixing (though not eddy diffusion) still occurs for frozen lakes.<a name='1179'></font>
<font color=#447700>!  iii) No sunlight is absorbed in the lake if there are snow layers.<a name='1180'></font>
<font color=#447700>!   iv) Light is allowed to reach the top soil layer (where it is assumed to be completely absorbed).<a name='1181'></font>
<font color=#447700>!    v) Lakes have variable depth, set ultimately in surface data set but now in initShalLakeMod.<a name='1182'></font>
<font color=#447700>!<a name='1183'></font>
<font color=#447700>! Eddy + molecular diffusion:<a name='1184'></font>
<font color=#447700>! d ts    d            d ts     1 ds<a name='1185'></font>
<font color=#447700>! ---- = -- [(km + ke) ----] + -- --<a name='1186'></font>
<font color=#447700>!  dt    dz             dz     cw dz<a name='1187'></font>
<font color=#447700>!<a name='1188'></font>
<font color=#447700>! where: ts = temperature (kelvin)<a name='1189'></font>
<font color=#447700>!         t = time (s)<a name='1190'></font>
<font color=#447700>!         z = depth (m)<a name='1191'></font>
<font color=#447700>!        km = molecular diffusion coefficient (m**2/s)<a name='1192'></font>
<font color=#447700>!        ke = eddy diffusion coefficient (m**2/s)<a name='1193'></font>
<font color=#447700>!        cw = heat capacity (j/m**3/kelvin)<a name='1194'></font>
<font color=#447700>!         s = heat source term (w/m**2)<a name='1195'></font>
<font color=#447700>!<a name='1196'></font>
<font color=#447700>!   Shallow lakes are allowed to have variable depth, set in _____.<a name='1197'></font>
<font color=#447700>!<a name='1198'></font>
<font color=#447700>!   For shallow lakes:    ke &gt; 0 if unfrozen,<a name='1199'></font>
<font color=#447700>!       and convective mixing occurs WHETHER OR NOT frozen. (See e.g. Martynov...)<a name='1200'></font>
<font color=#447700>!<a name='1201'></font>
<font color=#447700>! Use the Crank-Nicholson method to set up tridiagonal system of equations to<a name='1202'></font>
<font color=#447700>! solve for ts at time n+1, where the temperature equation for layer i is<a name='1203'></font>
<font color=#447700>! r_i = a_i [ts_i-1] n+1 + b_i [ts_i] n+1 + c_i [ts_i+1] n+1<a name='1204'></font>
<font color=#447700>!<a name='1205'></font>
<font color=#447700>! The solution conserves energy as:<a name='1206'></font>
<font color=#447700>!<a name='1207'></font>
<font color=#447700>! [For lake layers]<a name='1208'></font>
<font color=#447700>! cw*([ts(      1)] n+1 - [ts(      1)] n)*dz(      1)/dt + ... +<a name='1209'></font>
<font color=#447700>! cw*([ts(nlevlake)] n+1 - [ts(nlevlake)] n)*dz(nlevlake)/dt = fin<a name='1210'></font>
<font color=#447700>! But now there is phase change, so cv is not constant and there is<a name='1211'></font>
<font color=#447700>! latent heat.<a name='1212'></font>
<font color=#447700>!<a name='1213'></font>
<font color=#447700>! where:<a name='1214'></font>
<font color=#447700>! [ts] n   = old temperature (kelvin)<a name='1215'></font>
<font color=#447700>! [ts] n+1 = new temperature (kelvin)<a name='1216'></font>
<font color=#447700>! fin      = heat flux into lake (w/m**2)<a name='1217'></font>
<font color=#447700>!          = betaprime*sabg + forc_lwrad - eflx_lwrad_out - eflx_sh_tot - eflx_lh_tot<a name='1218'></font>
<font color=#447700>!          (This is now the same as the ground heat flux.)<a name='1219'></font>
<font color=#447700>!            + phi(1) + ... + phi(nlevlake) + phi(top soil level)<a name='1220'></font>
<font color=#447700>! betaprime = beta(islak) for no snow layers, and 1 for snow layers.<a name='1221'></font>
<font color=#447700>! This assumes all radiation is absorbed in the top snow layer and will need<a name='1222'></font>
<font color=#447700>! to be changed for CLM 4.<a name='1223'></font>
<font color=#447700>!<a name='1224'></font>
<font color=#447700>! WARNING: This subroutine assumes lake columns have one and only one pft.<a name='1225'></font>
<font color=#447700>!<a name='1226'></font>
<font color=#447700>! Outline:<a name='1227'></font>
<font color=#447700>! 1!) Initialization<a name='1228'></font>
<font color=#447700>! 2!) Lake density<a name='1229'></font>
<font color=#447700>! 3!) Diffusivity<a name='1230'></font>
<font color=#447700>! 4!) Heat source term from solar radiation penetrating lake<a name='1231'></font>
<font color=#447700>! 5!) Set thermal props and find initial energy content<a name='1232'></font>
<font color=#447700>! 6!) Set up vectors for tridiagonal matrix solution<a name='1233'></font>
<font color=#447700>! 7!) Solve tridiagonal and back-substitute<a name='1234'></font>
<font color=#447700>! 8!) (Optional) Do first energy check using temperature change at constant heat capacity.<a name='1235'></font>
<font color=#447700>! 9!) Phase change<a name='1236'></font>
<font color=#447700>! 9.5!) (Optional) Do second energy check using temperature change and latent heat, considering changed heat capacity.<a name='1237'></font>
<font color=#447700>!                  Also do soil water balance check.<a name='1238'></font>
<font color=#447700>!10!) Convective mixing <a name='1239'></font>
<font color=#447700>!11!) Do final energy check to detect small numerical errors (especially from convection)<a name='1240'></font>
<font color=#447700>!     and dump small imbalance into sensible heat, or pass large errors to BalanceCheckMod for abort.<a name='1241'></font>
<font color=#447700>!<a name='1242'></font>
<font color=#447700>! REVISION HISTORY:<a name='1243'></font>
<font color=#447700>! Created by Zack Subin, 2009.<a name='1244'></font>
<font color=#447700>! Reedited by Hongping Gu, 2010.<a name='1245'></font>
<font color=#447700>!=========================================================================================================<a name='1246'></font>
<a name='1247'>
<a name='1248'>
<font color=#447700>!    use TridiagonalMod     , only : Tridiagonal<a name='1249'></font>
    <a name='1250'>
    implicit none<a name='1251'>
<a name='1252'>
<font color=#447700>!in:<a name='1253'></font>
    real(r8), intent(in) :: t_grnd(1)          <font color=#447700>! ground temperature (Kelvin)<a name='1254'></font>
    real(r8), intent(inout) :: h2osno(1)          <font color=#447700>! snow water (mm H2O)<a name='1255'></font>
    real(r8), intent(in) :: sabg(1)            <font color=#447700>! solar radiation absorbed by ground (W/m**2)<a name='1256'></font>
    real(r8), intent(in) :: dz(1,-nlevsnow + 1:nlevsoil)          <font color=#447700>! layer thickness for snow &amp; soil (m)<a name='1257'></font>
    real(r8), intent(in) :: dz_lake(1,nlevlake)                  <font color=#447700>! layer thickness for lake (m)<a name='1258'></font>
    real(r8), intent(in) :: z(1,-nlevsnow+1:nlevsoil)             <font color=#447700>! layer depth for snow &amp; soil (m)<a name='1259'></font>
    real(r8), intent(in) :: zi(1,-nlevsnow+0:nlevsoil)            <font color=#447700>! interface level below a "z" level (m)<a name='1260'></font>
                                                                <font color=#447700>! the other z and dz variables<a name='1261'></font>
    real(r8), intent(in) :: z_lake(1,nlevlake)  <font color=#447700>! layer depth for lake (m)<a name='1262'></font>
    real(r8), intent(in) :: ws(1)              <font color=#447700>! surface friction velocity (m/s)<a name='1263'></font>
    real(r8), intent(in) :: ks(1)              <font color=#447700>! coefficient passed to ShalLakeTemperature<a name='1264'></font>
                                               <font color=#447700>! for calculation of decay of eddy diffusivity with depth<a name='1265'></font>
    integer , intent(in) :: snl(1)             <font color=#447700>! negative of number of snow layers<a name='1266'></font>
    real(r8), intent(inout) :: eflx_gnet(1)       <font color=#447700>! net heat flux into ground (W/m**2) at the surface interface<a name='1267'></font>
    real(r8), intent(in) :: lakedepth(1)       <font color=#447700>! column lake depth (m)<a name='1268'></font>
    <a name='1269'>
   <font color=#447700>! real(r8), intent(in) :: watsat(1,nlevsoil)      ! volumetric soil water at saturation (porosity)<a name='1270'></font>
    real(r8), intent(inout) :: snowdp(1)        <font color=#447700>!snow height (m)<a name='1271'></font>
<font color=#447700>!out: <a name='1272'></font>
<a name='1273'>
    real(r8), intent(out) :: eflx_sh_grnd(1)    <font color=#447700>! sensible heat flux from ground (W/m**2) [+ to atm]<a name='1274'></font>
    real(r8), intent(out) :: eflx_sh_tot(1)     <font color=#447700>! total sensible heat flux (W/m**2) [+ to atm]<a name='1275'></font>
    real(r8), intent(out) :: eflx_soil_grnd(1)  <font color=#447700>! heat flux into snow / lake (W/m**2) [+ = into soil]<a name='1276'></font>
                                               <font color=#447700>! Here this includes the whole lake radiation absorbed.<a name='1277'></font>
#if (defined SHLAKETEST)<a name='1278'>
    real(r8), intent(out) :: qmelt(1)           <font color=#447700>! snow melt [mm/s] [temporary]<a name='1279'></font>
#endif<a name='1280'>
    real(r8), intent(inout) :: t_lake(1,nlevlake)                 <font color=#447700>! lake temperature (Kelvin)<a name='1281'></font>
    real(r8), intent(inout) :: t_soisno(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! soil (or snow) temperature (Kelvin)<a name='1282'></font>
    real(r8), intent(inout) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! liquid water (kg/m2) [for snow &amp; soil layers]<a name='1283'></font>
    real(r8), intent(inout) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! ice lens (kg/m2) [for snow &amp; soil layers]<a name='1284'></font>
    real(r8), intent(inout) :: lake_icefrac(1,nlevlake)           <font color=#447700>! mass fraction of lake layer that is frozen<a name='1285'></font>
    real(r8), intent(out) :: savedtke1(1)                      <font color=#447700>! top level thermal conductivity (W/mK)<a name='1286'></font>
    real(r8), intent(out) :: frac_iceold(1,-nlevsnow+1:nlevsoil) <font color=#447700>! fraction of ice relative to the tot water<a name='1287'></font>
    real(r8), intent(out) :: qflx_snomelt(1)  <font color=#447700>!snow melt (mm H2O /s)<a name='1288'></font>
    integer, intent(out)  :: imelt(1,-nlevsnow+1:nlevsoil)        <font color=#447700>!flag for melting (=1), freezing (=2), Not=0 (new)<a name='1289'></font>
<a name='1290'>
<a name='1291'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='1292'></font>
<a name='1293'>
    integer , parameter  :: islak = 2     <font color=#447700>! index of lake, 1 = deep lake, 2 = shallow lake<a name='1294'></font>
    real(r8), parameter  :: p0 = 1._r8     <font color=#447700>! neutral value of turbulent prandtl number<a name='1295'></font>
    integer  :: i,j,fc,fp,g,c,p         <font color=#447700>! do loop or array index<a name='1296'></font>
<font color=#447700>!    real(r8) :: dtime                   ! land model time step (sec)<a name='1297'></font>
    real(r8) :: beta(2)                 <font color=#447700>! fraction solar rad absorbed at surface: depends on lake type<a name='1298'></font>
    real(r8) :: za(2)                   <font color=#447700>! base of surface absorption layer (m): depends on lake type<a name='1299'></font>
    real(r8) :: eta(2)                  <font color=#447700>! light extinction coefficient (/m): depends on lake type<a name='1300'></font>
    real(r8) :: cwat                    <font color=#447700>! specific heat capacity of water (j/m**3/kelvin)<a name='1301'></font>
    real(r8) :: cice_eff                <font color=#447700>! effective heat capacity of ice (using density of<a name='1302'></font>
                                          <font color=#447700>! water because layer depth is not adjusted when freezing<a name='1303'></font>
    real(r8) :: cfus                    <font color=#447700>! effective heat of fusion per unit volume<a name='1304'></font>
                                          <font color=#447700>! using water density as above<a name='1305'></font>
    real(r8) :: km                      <font color=#447700>! molecular diffusion coefficient (m**2/s)<a name='1306'></font>
    real(r8) :: tkice_eff               <font color=#447700>! effective conductivity since layer depth is constant<a name='1307'></font>
    real(r8) :: a(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil)      <font color=#447700>! "a" vector for tridiagonal matrix<a name='1308'></font>
    real(r8) :: b(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil)      <font color=#447700>! "b" vector for tridiagonal matrix<a name='1309'></font>
    real(r8) :: c1(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil)     <font color=#447700>! "c" vector for tridiagonal matrix<a name='1310'></font>
    real(r8) :: r(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil)      <font color=#447700>! "r" vector for tridiagonal solution<a name='1311'></font>
    real(r8) :: rhow(lbc:ubc,nlevlake)   <font color=#447700>! density of water (kg/m**3)<a name='1312'></font>
    real(r8) :: phi(lbc:ubc,nlevlake)    <font color=#447700>! solar radiation absorbed by layer (w/m**2)<a name='1313'></font>
    real(r8) :: kme(lbc:ubc,nlevlake)    <font color=#447700>! molecular + eddy diffusion coefficient (m**2/s)<a name='1314'></font>
    real(r8) :: rsfin                   <font color=#447700>! relative flux of solar radiation into layer<a name='1315'></font>
    real(r8) :: rsfout                  <font color=#447700>! relative flux of solar radiation out of layer<a name='1316'></font>
    real(r8) :: phi_soil(lbc:ubc)       <font color=#447700>! solar radiation into top soil layer (W/m**2)<a name='1317'></font>
    real(r8) :: ri                      <font color=#447700>! richardson number<a name='1318'></font>
    real(r8) :: fin(lbc:ubc)            <font color=#447700>! net heat flux into lake at ground interface (w/m**2)<a name='1319'></font>
    real(r8) :: ocvts(lbc:ubc)          <font color=#447700>! (cwat*(t_lake[n  ])*dz<a name='1320'></font>
    real(r8) :: ncvts(lbc:ubc)          <font color=#447700>! (cwat*(t_lake[n+1])*dz<a name='1321'></font>
    real(r8) :: ke                      <font color=#447700>! eddy diffusion coefficient (m**2/s)<a name='1322'></font>
    real(r8) :: zin                     <font color=#447700>! depth at top of layer (m)<a name='1323'></font>
    real(r8) :: zout                    <font color=#447700>! depth at bottom of layer (m)<a name='1324'></font>
    real(r8) :: drhodz                  <font color=#447700>! d [rhow] /dz (kg/m**4)<a name='1325'></font>
    real(r8) :: n2                      <font color=#447700>! brunt-vaisala frequency (/s**2)<a name='1326'></font>
    real(r8) :: num                     <font color=#447700>! used in calculating ri<a name='1327'></font>
    real(r8) :: den                     <font color=#447700>! used in calculating ri<a name='1328'></font>
    real(r8) :: tav_froz(lbc:ubc)       <font color=#447700>! used in aver temp for convectively mixed layers (C)<a name='1329'></font>
    real(r8) :: tav_unfr(lbc:ubc)       <font color=#447700>! "<a name='1330'></font>
    real(r8) :: nav(lbc:ubc)            <font color=#447700>! used in aver temp for convectively mixed layers<a name='1331'></font>
    real(r8) :: phidum                  <font color=#447700>! temporary value of phi<a name='1332'></font>
    real(r8) :: iceav(lbc:ubc)          <font color=#447700>! used in calc aver ice for convectively mixed layers<a name='1333'></font>
    real(r8) :: qav(lbc:ubc)            <font color=#447700>! used in calc aver heat content for conv. mixed layers<a name='1334'></font>
    integer  :: jtop(lbc:ubc)           <font color=#447700>! top level for each column (no longer all 1)<a name='1335'></font>
    real(r8) :: cv (lbc:ubc,-nlevsnow+1:nlevsoil)  <font color=#447700>!heat capacity of soil/snow [J/(m2 K)]<a name='1336'></font>
    real(r8) :: tk (lbc:ubc,-nlevsnow+1:nlevsoil)  <font color=#447700>!thermal conductivity of soil/snow [W/(m K)]<a name='1337'></font>
                                                 <font color=#447700>!(at interface below, except for j=0)<a name='1338'></font>
    real(r8) :: cv_lake (lbc:ubc,1:nlevlake)      <font color=#447700>!heat capacity [J/(m2 K)]<a name='1339'></font>
    real(r8) :: tk_lake (lbc:ubc,1:nlevlake)  <font color=#447700>!thermal conductivity at layer node [W/(m K)]<a name='1340'></font>
    real(r8) :: cvx (lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil) <font color=#447700>!heat capacity for whole column [J/(m2 K)]<a name='1341'></font>
    real(r8) :: tkix(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil) <font color=#447700>!thermal conductivity at layer interfaces<a name='1342'></font>
                                                         <font color=#447700>!for whole column [W/(m K)]<a name='1343'></font>
    real(r8) :: tx(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil) <font color=#447700>! temperature of whole column [K]<a name='1344'></font>
    real(r8) :: tktopsoillay(lbc:ubc)          <font color=#447700>! thermal conductivity [W/(m K)]<a name='1345'></font>
    real(r8) :: fnx(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil)  <font color=#447700>!heat diffusion through the layer interface below [W/m2]<a name='1346'></font>
    real(r8) :: phix(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil) <font color=#447700>!solar source term for whole column [W/m**2]<a name='1347'></font>
    real(r8) :: zx(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil)   <font color=#447700>!interface depth (+ below surface) for whole column [m]<a name='1348'></font>
    real(r8) :: dzm                              <font color=#447700>!used in computing tridiagonal matrix [m]<a name='1349'></font>
    real(r8) :: dzp                              <font color=#447700>!used in computing tridiagonal matrix [m]<a name='1350'></font>
    integer  :: jprime                   <font color=#447700>! j - nlevlake<a name='1351'></font>
    real(r8) :: factx(lbc:ubc,-nlevsnow+1:nlevlake+nlevsoil) <font color=#447700>!coefficient used in computing tridiagonal matrix<a name='1352'></font>
    real(r8) :: t_lake_bef(lbc:ubc,1:nlevlake)    <font color=#447700>!beginning lake temp for energy conservation check [K]<a name='1353'></font>
    real(r8) :: t_soisno_bef(lbc:ubc,-nlevsnow+1:nlevsoil) <font color=#447700>!beginning soil temp for E cons. check [K]<a name='1354'></font>
    real(r8) :: lhabs(lbc:ubc)       <font color=#447700>! total per-column latent heat abs. from phase change  (J/m^2)<a name='1355'></font>
    real(r8) :: esum1(lbc:ubc)        <font color=#447700>! temp for checking energy (J/m^2)<a name='1356'></font>
    real(r8) :: esum2(lbc:ubc)        <font color=#447700>! ""<a name='1357'></font>
    real(r8) :: zsum(lbc:ubc)        <font color=#447700>! temp for putting ice at the top during convection (m)<a name='1358'></font>
    real(r8) :: wsum(lbc:ubc)        <font color=#447700>! temp for checking water (kg/m^2)<a name='1359'></font>
    real(r8) :: wsum_end(lbc:ubc)    <font color=#447700>! temp for checking water (kg/m^2)<a name='1360'></font>
    real(r8) :: errsoi(1)                         <font color=#447700>! soil/lake energy conservation error (W/m**2)<a name='1361'></font>
    real(r8) :: eflx_snomelt(1)  <font color=#447700>!snow melt heat flux (W/m**2)<a name='1362'></font>
    CHARACTER*256 :: message<a name='1363'>
<font color=#447700>!<a name='1364'></font>
<font color=#447700>! Constants for lake temperature model<a name='1365'></font>
<font color=#447700>!<a name='1366'></font>
    data beta/0.4_r8, 0.4_r8/  <font color=#447700>! (deep lake, shallow lake)<a name='1367'></font>
    data za  /0.6_r8, 0.6_r8/<a name='1368'>
<font color=#447700>!   For now, keep beta and za for shallow lake the same as deep lake, until better data is found.<a name='1369'></font>
<font color=#447700>!   It looks like eta is key and that larger values give better results for shallow lakes.  Use<a name='1370'></font>
<font color=#447700>!   empirical expression from Hakanson (below). This is still a very unconstrained parameter<a name='1371'></font>
<font color=#447700>!   that deserves more attention.<a name='1372'></font>
<font color=#447700>!   Some radiation will be allowed to reach the soil.<a name='1373'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='1374'></font>
<a name='1375'>
<a name='1376'>
    <font color=#447700>! 1!) Initialization<a name='1377'></font>
    <font color=#447700>! Determine step size<a name='1378'></font>
<a name='1379'>
<font color=#447700>!    dtime = get_step_size()<a name='1380'></font>
<a name='1381'>
    <font color=#447700>! Initialize constants<a name='1382'></font>
    cwat = cpliq*denh2o <font color=#447700>! water heat capacity per unit volume<a name='1383'></font>
    cice_eff = cpice*denh2o <font color=#447700>!use water density because layer depth is not adjusted<a name='1384'></font>
                              <font color=#447700>!for freezing<a name='1385'></font>
    cfus = hfus*denh2o  <font color=#447700>! latent heat per unit volume<a name='1386'></font>
    tkice_eff = tkice * denice/denh2o <font color=#447700>!effective conductivity since layer depth is constant<a name='1387'></font>
    km = tkwat/cwat     <font color=#447700>! a constant (molecular diffusivity)<a name='1388'></font>
<a name='1389'>
    <font color=#447700>! Begin calculations<a name='1390'></font>
<a name='1391'>
<font color=#447700>!dir$ concurrent<a name='1392'></font>
<font color=#447700>!cdir nodep<a name='1393'></font>
    do fc = 1, num_shlakec<a name='1394'>
       c = filter_shlakec(fc)<a name='1395'>
<a name='1396'>
       <font color=#447700>! Initialize Ebal quantities computed below<a name='1397'></font>
<a name='1398'>
       ocvts(c) = 0._r8<a name='1399'>
       ncvts(c) = 0._r8<a name='1400'>
       esum1(c) = 0._r8<a name='1401'>
       esum2(c) = 0._r8<a name='1402'>
<a name='1403'>
    end do<a name='1404'>
<a name='1405'>
    <font color=#447700>! Initialize set of previous time-step variables as in DriverInit,<a name='1406'></font>
    <font color=#447700>! which is currently not called over lakes. This has to be done<a name='1407'></font>
    <font color=#447700>! here because phase change will occur in this routine.<a name='1408'></font>
    <font color=#447700>! Ice fraction of snow at previous time step<a name='1409'></font>
<a name='1410'>
    do j = -nlevsnow+1,0<a name='1411'>
<font color=#447700>!dir$ concurrent<a name='1412'></font>
<font color=#447700>!cdir nodep<a name='1413'></font>
      do fc = 1, num_shlakec<a name='1414'>
         c = filter_shlakec(fc)<a name='1415'>
         if (j &gt;= snl(c) + 1) then<a name='1416'>
            frac_iceold(c,j) = h2osoi_ice(c,j)/(h2osoi_liq(c,j)+h2osoi_ice(c,j))<a name='1417'>
         end if<a name='1418'>
      end do<a name='1419'>
    end do<a name='1420'>
<a name='1421'>
    <font color=#447700>! Sum soil water.<a name='1422'></font>
    do j = 1, nlevsoil<a name='1423'>
<font color=#447700>!dir$ concurrent<a name='1424'></font>
<font color=#447700>!cdir nodep<a name='1425'></font>
       do fc = 1, num_shlakec<a name='1426'>
          c = filter_shlakec(fc)<a name='1427'>
          if (j == 1) wsum(c) = 0._r8<a name='1428'>
          wsum(c) = wsum(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='1429'>
       end do<a name='1430'>
    end do<a name='1431'>
<a name='1432'>
<font color=#447700>!dir$ concurrent<a name='1433'></font>
<font color=#447700>!cdir nodep<a name='1434'></font>
    do fp = 1, num_shlakep<a name='1435'>
       p = filter_shlakep(fp)<a name='1436'>
       c = pcolumn(p)<a name='1437'>
<a name='1438'>
<a name='1439'>
       <font color=#447700>! Prepare for lake layer temperature calculations below<a name='1440'></font>
<a name='1441'>
       <font color=#447700>! fin(c) = betaprime * sabg(p) + forc_lwrad(g) - (eflx_lwrad_out(p) + &amp;<a name='1442'></font>
       <font color=#447700>!     eflx_sh_tot(p) + eflx_lh_tot(p)) <a name='1443'></font>
       <font color=#447700>! fin(c) now passed from ShalLakeFluxes as eflx_gnet<a name='1444'></font>
       fin(c) = eflx_gnet(p)<a name='1445'>
<a name='1446'>
    end do<a name='1447'>
<a name='1448'>
    <font color=#447700>! 2!) Lake density<a name='1449'></font>
<a name='1450'>
    do j = 1, nlevlake<a name='1451'>
<font color=#447700>!dir$ concurrent<a name='1452'></font>
<font color=#447700>!cdir nodep<a name='1453'></font>
       do fc = 1, num_shlakec<a name='1454'>
          c = filter_shlakec(fc)<a name='1455'>
          rhow(c,j) = (1._r8 - lake_icefrac(c,j)) * &amp; <a name='1456'>
                      1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,j)-277._r8))**1.68_r8 ) &amp;<a name='1457'>
                    + lake_icefrac(c,j)*denice<a name='1458'>
                    <font color=#447700>! Allow for ice fraction; assume constant ice density.<a name='1459'></font>
                    <font color=#447700>! Is this the right weighted average?<a name='1460'></font>
                    <font color=#447700>! Using this average will make sure that surface ice is treated properly during<a name='1461'></font>
                    <font color=#447700>! convective mixing.<a name='1462'></font>
       end do<a name='1463'>
    end do<a name='1464'>
<a name='1465'>
    <font color=#447700>! 3!) Diffusivity and implied thermal "conductivity" = diffusivity * cwat<a name='1466'></font>
    do j = 1, nlevlake-1<a name='1467'>
<font color=#447700>!dir$ prefervector<a name='1468'></font>
<font color=#447700>!dir$ concurrent<a name='1469'></font>
<font color=#447700>!cdir nodep<a name='1470'></font>
       do fc = 1, num_shlakec<a name='1471'>
          c = filter_shlakec(fc)<a name='1472'>
          drhodz = (rhow(c,j+1)-rhow(c,j)) / (z_lake(c,j+1)-z_lake(c,j))<a name='1473'>
          n2 = grav / rhow(c,j) * drhodz<a name='1474'>
          <font color=#447700>! Fixed sign error here: our z goes up going down into the lake, so no negative<a name='1475'></font>
          <font color=#447700>! sign is needed to make this positive unlike in Hostetler. --ZS<a name='1476'></font>
          num = 40._r8 * n2 * (vkc*z_lake(c,j))**2<a name='1477'>
          den = max( (ws(c)**2) * exp(-2._r8*ks(c)*z_lake(c,j)), 1.e-10_r8 )<a name='1478'>
          ri = ( -1._r8 + sqrt( max(1._r8+num/den, 0._r8) ) ) / 20._r8<a name='1479'>
          if (t_grnd(c) &gt; tfrz .and. t_lake(c,1) &gt; tfrz .and. snl(c) == 0) then<a name='1480'>
            <font color=#447700>! ke = vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)<a name='1481'></font>
<a name='1482'>
             if( t_lake(c,1) &gt; 277.15_r8 ) then <a name='1483'>
                if (lakedepth(c) &gt; 15.0 ) then <a name='1484'>
                   ke = 1.e+2_r8*vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)<a name='1485'>
                else <a name='1486'>
                   ke = vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)<a name='1487'>
                endif<a name='1488'>
             else <a name='1489'>
                if (lakedepth(c) &gt; 15.0 ) then <a name='1490'>
                  if (lakedepth(c) &gt; 150.0 ) then <a name='1491'>
                    ke = 1.e+5_r8*vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)<a name='1492'>
                  else <a name='1493'>
                    ke =1.e+4_r8*vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)<a name='1494'>
                  end if<a name='1495'>
                else <a name='1496'>
                  ke = vkc*ws(c)*z_lake(c,j)/p0 * exp(-ks(c)*z_lake(c,j)) / (1._r8+37._r8*ri*ri)<a name='1497'>
                endif <a name='1498'>
             end if<a name='1499'>
<a name='1500'>
             kme(c,j) = km + ke<a name='1501'>
             tk_lake(c,j) = kme(c,j)*cwat<a name='1502'>
             <font color=#447700>! If there is some ice in this layer (this should rarely happen because the surface<a name='1503'></font>
             <font color=#447700>! is unfrozen and it will be unstable), still use the cwat to get out the tk b/c the eddy<a name='1504'></font>
             <font color=#447700>! diffusivity equation assumes water.<a name='1505'></font>
          else<a name='1506'>
             kme(c,j) = km<a name='1507'>
             tk_lake(c,j) = tkwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &amp;<a name='1508'>
                            + tkwat*lake_icefrac(c,j) )<a name='1509'>
             <font color=#447700>! Assume the resistances add as for the calculation of conductivities at layer interfaces.<a name='1510'></font>
          end if<a name='1511'>
       end do<a name='1512'>
    end do<a name='1513'>
<a name='1514'>
<font color=#447700>!dir$ concurrent<a name='1515'></font>
<font color=#447700>!cdir nodep<a name='1516'></font>
    do fc = 1, num_shlakec<a name='1517'>
       c = filter_shlakec(fc)<a name='1518'>
<a name='1519'>
       j = nlevlake<a name='1520'>
       kme(c,nlevlake) = kme(c,nlevlake-1)<a name='1521'>
<a name='1522'>
       if (t_grnd(c) &gt; tfrz .and. t_lake(c,1) &gt; tfrz .and. snl(c) == 0) then<a name='1523'>
          tk_lake(c,j) = tk_lake(c,j-1)<a name='1524'>
       else<a name='1525'>
          tk_lake(c,j) = tkwat*tkice_eff / ( (1._r8-lake_icefrac(c,j))*tkice_eff &amp;<a name='1526'>
                            + tkwat*lake_icefrac(c,j) )<a name='1527'>
       end if<a name='1528'>
<a name='1529'>
       <font color=#447700>! Use in surface flux calculation for next timestep.<a name='1530'></font>
       savedtke1(c) = kme(c,1)*cwat <font color=#447700>! Will only be used if unfrozen<a name='1531'></font>
       <font color=#447700>! set number of column levels for use by Tridiagonal below<a name='1532'></font>
       jtop(c) = snl(c) + 1<a name='1533'>
    end do<a name='1534'>
<a name='1535'>
    <font color=#447700>! 4!) Heat source term: unfrozen lakes only<a name='1536'></font>
    do j = 1, nlevlake<a name='1537'>
<font color=#447700>!dir$ concurrent<a name='1538'></font>
<font color=#447700>!cdir nodep<a name='1539'></font>
       do fp = 1, num_shlakep<a name='1540'>
          p = filter_shlakep(fp)<a name='1541'>
          c = pcolumn(p)<a name='1542'>
<a name='1543'>
          <font color=#447700>! Set eta(:), the extinction coefficient, according to L Hakanson, Aquatic Sciences, 1995<a name='1544'></font>
          <font color=#447700>! (regression of Secchi Depth with lake depth for small glacial basin lakes), and the<a name='1545'></font>
          <font color=#447700>! Poole &amp; Atkins expression for extinction coeffient of 1.7 / Secchi Depth (m).<a name='1546'></font>
#ifndef ETALAKE<a name='1547'>
          eta(:) = 1.1925_r8*lakedepth(c)**(-0.424)<a name='1548'>
#else<a name='1549'>
          eta(:) = ETALAKE<a name='1550'>
#endif<a name='1551'>
<a name='1552'>
          zin  = z_lake(c,j) - 0.5_r8*dz_lake(c,j)<a name='1553'>
          zout = z_lake(c,j) + 0.5_r8*dz_lake(c,j)<a name='1554'>
          rsfin  = exp( -eta(islak)*max(  zin-za(islak),0._r8 ) )<a name='1555'>
          rsfout = exp( -eta(islak)*max( zout-za(islak),0._r8 ) )<a name='1556'>
<a name='1557'>
          <font color=#447700>! Let rsfout for bottom layer go into soil.<a name='1558'></font>
          <font color=#447700>! This looks like it should be robust even for pathological cases,<a name='1559'></font>
            <font color=#447700>! like lakes thinner than za.<a name='1560'></font>
          if (t_grnd(c) &gt; tfrz .and. t_lake(c,1) &gt; tfrz .and. snl(c) == 0) then<a name='1561'>
             phidum = (rsfin-rsfout) * sabg(p) * (1._r8-beta(islak))<a name='1562'>
             if (j == nlevlake) then<a name='1563'>
                phi_soil(c) = rsfout * sabg(p) * (1._r8-beta(islak))<a name='1564'>
             end if<a name='1565'>
          else if (j == 1 .and. snl(c) == 0) then <font color=#447700>!if frozen but no snow layers<a name='1566'></font>
             phidum = sabg(p) * (1._r8-beta(islak))<a name='1567'>
          else <font color=#447700>!radiation absorbed at surface<a name='1568'></font>
             phidum = 0._r8<a name='1569'>
             if (j == nlevlake) phi_soil(c) = 0._r8<a name='1570'>
          end if<a name='1571'>
          phi(c,j) = phidum<a name='1572'>
<a name='1573'>
       end do<a name='1574'>
    end do<a name='1575'>
<a name='1576'>
    <font color=#447700>! 5!) Set thermal properties and check initial energy content.<a name='1577'></font>
<a name='1578'>
    <font color=#447700>! For lake<a name='1579'></font>
    do j = 1, nlevlake<a name='1580'>
<font color=#447700>!dir$ concurrent<a name='1581'></font>
<font color=#447700>!cdir nodep<a name='1582'></font>
       do fc = 1, num_shlakec<a name='1583'>
          c = filter_shlakec(fc)<a name='1584'>
<a name='1585'>
          cv_lake(c,j) = dz_lake(c,j) * (cwat*(1._r8-lake_icefrac(c,j)) + cice_eff*lake_icefrac(c,j))<a name='1586'>
       end do<a name='1587'>
    end do<a name='1588'>
<a name='1589'>
    <font color=#447700>! For snow / soil<a name='1590'></font>
  call <A href='../../html_code/phys/module_sf_lake.F.html#SOILTHERMPROP_LAKE'>SoilThermProp_Lake</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SOILTHERMPROP_LAKE_1"> (snl,dz,zi,z,t_soisno,h2osoi_liq,h2osoi_ice,    &amp;<a name='1591'>
                           tk, cv, tktopsoillay)<a name='1592'>
<a name='1593'>
    <font color=#447700>! Sum cv*t_lake for energy check<a name='1594'></font>
    <font color=#447700>! Include latent heat term, and correction for changing heat capacity with phase change.<a name='1595'></font>
<a name='1596'>
    <font color=#447700>! This will need to be over all soil / lake / snow layers. Lake is below.<a name='1597'></font>
    do j = 1, nlevlake<a name='1598'>
<font color=#447700>!dir$ concurrent<a name='1599'></font>
<font color=#447700>!cdir nodep<a name='1600'></font>
       do fc = 1, num_shlakec<a name='1601'>
          c = filter_shlakec(fc)<a name='1602'>
<a name='1603'>
<font color=#447700>!          ocvts(c) = ocvts(c) + cv_lake(c,j)*t_lake(c,j) &amp;<a name='1604'></font>
          ocvts(c) = ocvts(c) + cv_lake(c,j)*(t_lake(c,j)-tfrz) &amp;<a name='1605'>
                   + cfus*dz_lake(c,j)*(1._r8-lake_icefrac(c,j)) <font color=#447700>!&amp;<a name='1606'></font>
<font color=#447700>!                   + (cwat-cice_eff)*lake_icefrac(c)*tfrz*dz_lake(c,j) !enthalpy reconciliation term<a name='1607'></font>
          t_lake_bef(c,j) = t_lake(c,j)<a name='1608'>
       end do<a name='1609'>
    end do<a name='1610'>
<a name='1611'>
    <font color=#447700>! Now do for soil / snow layers<a name='1612'></font>
    do j = -nlevsnow + 1, nlevsoil<a name='1613'>
<font color=#447700>!dir$ concurrent<a name='1614'></font>
<font color=#447700>!cdir nodep<a name='1615'></font>
       do fc = 1, num_shlakec<a name='1616'>
          c = filter_shlakec(fc)<a name='1617'>
<a name='1618'>
          if (j &gt;= jtop(c)) then<a name='1619'>
<font color=#447700>!             ocvts(c) = ocvts(c) + cv(c,j)*t_soisno(c,j) &amp;<a name='1620'></font>
             ocvts(c) = ocvts(c) + cv(c,j)*(t_soisno(c,j)-tfrz) &amp;<a name='1621'>
                      + hfus*h2osoi_liq(c,j) <font color=#447700>!&amp;<a name='1622'></font>
<font color=#447700>!                      + (cpliq-cpice)*h2osoi_ice(c,j)*tfrz !enthalpy reconciliation term<a name='1623'></font>
             if (j == 1 .and. h2osno(c) &gt; 0._r8 .and. j == jtop(c)) then<a name='1624'>
                ocvts(c) = ocvts(c) - h2osno(c)*hfus<a name='1625'>
             end if<a name='1626'>
             t_soisno_bef(c,j) = t_soisno(c,j)<a name='1627'>
             if(abs(t_soisno(c,j)-288) &gt; 150)   then <a name='1628'>
                WRITE( message,* ) 'WARNING: Extreme t_soisno at c, level',c, j<a name='1629'>
                CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1142"> ( message )<a name='1630'>
             endif<a name='1631'>
          end if<a name='1632'>
       end do<a name='1633'>
    end do<a name='1634'>
<a name='1635'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!<a name='1636'></font>
    <font color=#447700>! 6!) Set up vector r and vectors a, b, c1 that define tridiagonal matrix<a name='1637'></font>
<a name='1638'>
    <font color=#447700>! Heat capacity and resistance of snow without snow layers (&lt;1cm) is ignored during diffusion,<a name='1639'></font>
    <font color=#447700>! but its capacity to absorb latent heat may be used during phase change.<a name='1640'></font>
<a name='1641'>
    <font color=#447700>! Set up interface depths, zx, heat capacities, cvx, solar source terms, phix, and temperatures, tx.<a name='1642'></font>
    do j = -nlevsnow+1, nlevlake+nlevsoil<a name='1643'>
<font color=#447700>!dir$ prefervector<a name='1644'></font>
<font color=#447700>!dir$ concurrent<a name='1645'></font>
<font color=#447700>!cdir nodep<a name='1646'></font>
       do fc = 1,num_shlakec<a name='1647'>
          c = filter_shlakec(fc)<a name='1648'>
<a name='1649'>
          jprime = j - nlevlake<a name='1650'>
<a name='1651'>
          if (j &gt;= jtop(c)) then<a name='1652'>
             if (j &lt; 1) then <font color=#447700>!snow layer<a name='1653'></font>
                zx(c,j) = z(c,j)<a name='1654'>
                cvx(c,j) = cv(c,j)<a name='1655'>
                phix(c,j) = 0._r8<a name='1656'>
                tx(c,j) = t_soisno(c,j)<a name='1657'>
             else if (j &lt;= nlevlake) then <font color=#447700>!lake layer<a name='1658'></font>
                zx(c,j) = z_lake(c,j)<a name='1659'>
                cvx(c,j) = cv_lake(c,j)<a name='1660'>
                phix(c,j) = <A href='../../html_code/phys/module_ra_cam_support.F.html#PHI'>phi</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="PHI_1">(c,j)<a name='1661'>
                tx(c,j) = t_lake(c,j)<a name='1662'>
             else <font color=#447700>!soil layer<a name='1663'></font>
                zx(c,j) = zx(c,nlevlake) + dz_lake(c,nlevlake)/2._r8 + z(c,jprime)<a name='1664'>
                cvx(c,j) = cv(c,jprime)<a name='1665'>
                if (j == nlevlake + 1) then <font color=#447700>!top soil layer<a name='1666'></font>
                   phix(c,j) = phi_soil(c)<a name='1667'>
                else <font color=#447700>!middle or bottom soil layer<a name='1668'></font>
                   phix(c,j) = 0._r8<a name='1669'>
                end if<a name='1670'>
                tx(c,j) = t_soisno(c,jprime)<a name='1671'>
             end if<a name='1672'>
          end if<a name='1673'>
<a name='1674'>
       end do<a name='1675'>
    end do<a name='1676'>
<a name='1677'>
    <font color=#447700>! Determine interface thermal conductivities, tkix<a name='1678'></font>
<a name='1679'>
    do j = -nlevsnow+1, nlevlake+nlevsoil<a name='1680'>
<font color=#447700>!dir$ prefervector<a name='1681'></font>
<font color=#447700>!dir$ concurrent<a name='1682'></font>
<font color=#447700>!cdir nodep<a name='1683'></font>
       do fc = 1,num_shlakec<a name='1684'>
          c = filter_shlakec(fc)<a name='1685'>
<a name='1686'>
          jprime = j - nlevlake<a name='1687'>
<a name='1688'>
          if (j &gt;= jtop(c)) then<a name='1689'>
             if (j &lt; 0) then <font color=#447700>!non-bottom snow layer<a name='1690'></font>
                tkix(c,j) = tk(c,j)<a name='1691'>
             else if (j == 0) then <font color=#447700>!bottom snow layer<a name='1692'></font>
                dzp = zx(c,j+1) - zx(c,j)<a name='1693'>
                tkix(c,j) = tk_lake(c,1)*tk(c,j)*dzp / &amp;<a name='1694'>
                      (tk(c,j)*z_lake(c,1) + tk_lake(c,1)*(-z(c,j)) )<a name='1695'>
                <font color=#447700>! tk(c,0) is the conductivity at the middle of that layer, as defined in SoilThermProp_Lake<a name='1696'></font>
             else if (j &lt; nlevlake) then <font color=#447700>!non-bottom lake layer<a name='1697'></font>
                tkix(c,j) = ( tk_lake(c,j)*tk_lake(c,j+1) * (dz_lake(c,j+1)+dz_lake(c,j)) ) &amp;<a name='1698'>
                           / ( tk_lake(c,j)*dz_lake(c,j+1) + tk_lake(c,j+1)*dz_lake(c,j) )<a name='1699'>
             else if (j == nlevlake) then <font color=#447700>!bottom lake layer<a name='1700'></font>
                dzp = zx(c,j+1) - zx(c,j)<a name='1701'>
                tkix(c,j) = (tktopsoillay(c)*tk_lake(c,j)*dzp / &amp;<a name='1702'>
                    (tktopsoillay(c)*dz_lake(c,j)/2._r8 + tk_lake(c,j)*z(c,1) ) )<a name='1703'>
                    <font color=#447700>! tktopsoillay is the conductivity at the middle of that layer, as defined in SoilThermProp_Lake<a name='1704'></font>
             else <font color=#447700>!soil layer<a name='1705'></font>
                tkix(c,j) = tk(c,jprime)<a name='1706'>
             end if<a name='1707'>
         end if<a name='1708'>
<a name='1709'>
      end do <a name='1710'>
   end do<a name='1711'>
<a name='1712'>
<a name='1713'>
    <font color=#447700>! Determine heat diffusion through the layer interface and factor used in computing<a name='1714'></font>
    <font color=#447700>! tridiagonal matrix and set up vector r and vectors a, b, c1 that define tridiagonal<a name='1715'></font>
    <font color=#447700>! matrix and solve system<a name='1716'></font>
<a name='1717'>
    do j = -nlevsnow+1, nlevlake+nlevsoil<a name='1718'>
<font color=#447700>!dir$ prefervector<a name='1719'></font>
<font color=#447700>!dir$ concurrent<a name='1720'></font>
<font color=#447700>!cdir nodep<a name='1721'></font>
       do fc = 1,num_shlakec<a name='1722'>
          c = filter_shlakec(fc)<a name='1723'>
          if (j &gt;= jtop(c)) then<a name='1724'>
             if (j &lt; nlevlake+nlevsoil) then <font color=#447700>!top or interior layer<a name='1725'></font>
                factx(c,j) = dtime/cvx(c,j)<a name='1726'>
                fnx(c,j) = tkix(c,j)*(tx(c,j+1)-tx(c,j))/(zx(c,j+1)-zx(c,j))<a name='1727'>
             else <font color=#447700>!bottom soil layer<a name='1728'></font>
                factx(c,j) = dtime/cvx(c,j)<a name='1729'>
                fnx(c,j) = 0._r8 <font color=#447700>!not used<a name='1730'></font>
             end if<a name='1731'>
          end if<a name='1732'>
       enddo<a name='1733'>
    end do<a name='1734'>
<a name='1735'>
    do j = -nlevsnow+1,nlevlake+nlevsoil<a name='1736'>
<font color=#447700>!dir$ prefervector<a name='1737'></font>
<font color=#447700>!dir$ concurrent<a name='1738'></font>
<font color=#447700>!cdir nodep<a name='1739'></font>
       do fc = 1,num_shlakec<a name='1740'>
          c = filter_shlakec(fc)<a name='1741'>
          if (j &gt;= jtop(c)) then<a name='1742'>
             if (j == jtop(c)) then <font color=#447700>!top layer<a name='1743'></font>
                dzp    = zx(c,j+1)-zx(c,j)<a name='1744'>
                a(c,j) = 0._r8<a name='1745'>
                b(c,j) = 1+(1._r8-cnfac)*factx(c,j)*tkix(c,j)/dzp<a name='1746'>
                c1(c,j) =  -(1._r8-cnfac)*factx(c,j)*tkix(c,j)/dzp<a name='1747'>
                r(c,j) = tx(c,j) + factx(c,j)*( fin(c) + phix(c,j) + cnfac*fnx(c,j) )<a name='1748'>
             else if (j &lt; nlevlake+nlevsoil) then <font color=#447700>!middle layer<a name='1749'></font>
                dzm    = (zx(c,j)-zx(c,j-1))<a name='1750'>
                dzp    = (zx(c,j+1)-zx(c,j))<a name='1751'>
                a(c,j) =   - (1._r8-cnfac)*factx(c,j)* tkix(c,j-1)/dzm<a name='1752'>
                b(c,j) = 1._r8+ (1._r8-cnfac)*factx(c,j)*(tkix(c,j)/dzp + tkix(c,j-1)/dzm)<a name='1753'>
                c1(c,j) =   - (1._r8-cnfac)*factx(c,j)* tkix(c,j)/dzp<a name='1754'>
                r(c,j) = tx(c,j) + cnfac*factx(c,j)*( fnx(c,j) - fnx(c,j-1) ) + factx(c,j)*phix(c,j)<a name='1755'>
             else  <font color=#447700>!bottom soil layer<a name='1756'></font>
                dzm     = (zx(c,j)-zx(c,j-1))<a name='1757'>
                a(c,j) =   - (1._r8-cnfac)*factx(c,j)*tkix(c,j-1)/dzm<a name='1758'>
                b(c,j) = 1._r8+ (1._r8-cnfac)*factx(c,j)*tkix(c,j-1)/dzm<a name='1759'>
                c1(c,j) = 0._r8<a name='1760'>
                r(c,j) = tx(c,j) - cnfac*factx(c,j)*fnx(c,j-1)<a name='1761'>
             end if<a name='1762'>
          end if<a name='1763'>
       enddo<a name='1764'>
    end do<a name='1765'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='1766'></font>
<a name='1767'>
<a name='1768'>
    <font color=#447700>! 7!) Solve for tdsolution<a name='1769'></font>
<a name='1770'>
    call <A href='../../html_code/phys/module_sf_lake.F.html#TRIDIAGONAL'>Tridiagonal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="TRIDIAGONAL_4">(lbc, ubc, -nlevsnow + 1, nlevlake + nlevsoil, jtop, num_shlakec, filter_shlakec, &amp;<a name='1771'>
                     a, b, c1, r, tx)<a name='1772'>
 <a name='1773'>
    <font color=#447700>! Set t_soisno and t_lake<a name='1774'></font>
    do j = -nlevsnow+1, nlevlake + nlevsoil<a name='1775'>
<font color=#447700>!dir$ concurrent<a name='1776'></font>
<font color=#447700>!cdir nodep<a name='1777'></font>
       do fc = 1, num_shlakec<a name='1778'>
          c = filter_shlakec(fc)<a name='1779'>
<a name='1780'>
          jprime = j - nlevlake<a name='1781'>
<a name='1782'>
          <font color=#447700>! Don't do anything with invalid snow layers.<a name='1783'></font>
          if (j &gt;= jtop(c)) then<a name='1784'>
             if (j &lt; 1) then <font color=#447700>!snow layer<a name='1785'></font>
             t_soisno(c,j) = tx(c,j)<a name='1786'>
             else if (j &lt;= nlevlake) then <font color=#447700>!lake layer<a name='1787'></font>
             t_lake(c,j)   = tx(c,j)<a name='1788'>
             else <font color=#447700>!soil layer<a name='1789'></font>
             t_soisno(c,jprime) = tx(c,j)<a name='1790'>
             end if<a name='1791'>
          end if<a name='1792'>
       end do<a name='1793'>
    end do<a name='1794'>
<a name='1795'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!<a name='1796'></font>
<a name='1797'>
    <font color=#447700>! 8!) Sum energy content and total energy into lake for energy check. Any errors will be from the<a name='1798'></font>
    <font color=#447700>!     Tridiagonal solution.<a name='1799'></font>
<a name='1800'>
#if (defined LAKEDEBUG)<a name='1801'>
    do j = 1, nlevlake<a name='1802'>
<font color=#447700>!dir$ concurrent<a name='1803'></font>
<font color=#447700>!cdir nodep<a name='1804'></font>
       do fc = 1, num_shlakec<a name='1805'>
          c = filter_shlakec(fc)<a name='1806'>
<a name='1807'>
          esum1(c) = esum1(c) + (t_lake(c,j)-t_lake_bef(c,j))*cv_lake(c,j)<a name='1808'>
          esum2(c) = esum2(c) + (t_lake(c,j)-tfrz)*cv_lake(c,j)<a name='1809'>
       end do<a name='1810'>
    end do<a name='1811'>
<a name='1812'>
    do j = -nlevsnow+1, nlevsoil<a name='1813'>
<font color=#447700>!dir$ concurrent<a name='1814'></font>
<font color=#447700>!cdir nodep<a name='1815'></font>
       do fc = 1, num_shlakec<a name='1816'>
          c = filter_shlakec(fc)<a name='1817'>
<a name='1818'>
          if (j &gt;= jtop(c)) then<a name='1819'>
             esum1(c) = esum1(c) + (t_soisno(c,j)-t_soisno_bef(c,j))*cv(c,j)<a name='1820'>
             esum2(c) = esum2(c) + (t_soisno(c,j)-tfrz)*cv(c,j)<a name='1821'>
          end if<a name='1822'>
       end do<a name='1823'>
    end do<a name='1824'>
<a name='1825'>
<font color=#447700>!dir$ concurrent<a name='1826'></font>
<font color=#447700>!cdir nodep<a name='1827'></font>
       do fp = 1, num_shlakep<a name='1828'>
          p = filter_shlakep(fp)<a name='1829'>
          c = pcolumn(p)<a name='1830'>
          <font color=#447700>! Again assuming only one pft per column<a name='1831'></font>
<font color=#447700>!          esum1(c) = esum1(c) + lhabs(c)<a name='1832'></font>
          errsoi(c) = esum1(c)/dtime - eflx_soil_grnd(p)<a name='1833'>
                    <font color=#447700>! eflx_soil_grnd includes all the solar radiation absorbed in the lake,<a name='1834'></font>
                    <font color=#447700>! unlike eflx_gnet<a name='1835'></font>
          if(abs(errsoi(c)) &gt; 1.e-5_r8) then<a name='1836'>
             WRITE( message,* )'Primary soil energy conservation error in shlake &amp;<a name='1837'>
                                column during Tridiagonal Solution,', 'error (W/m^2):', c, errsoi(c) <a name='1838'>
             CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1143"> ( message )<a name='1839'>
          end if<a name='1840'>
       end do<a name='1841'>
       <font color=#447700>! This has to be done before convective mixing because the heat capacities for each layer<a name='1842'></font>
       <font color=#447700>! will get scrambled.<a name='1843'></font>
<a name='1844'>
#endif<a name='1845'>
<a name='1846'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!<a name='1847'></font>
<a name='1848'>
    <font color=#447700>! 9!) Phase change<a name='1849'></font>
    call <A href='../../html_code/phys/module_sf_lake.F.html#PHASECHANGE_LAKE'>PhaseChange_Lake</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="PHASECHANGE_LAKE_1"> (snl,h2osno,dz,dz_lake,                            &amp; <font color=#447700>!i<a name='1850'></font>
                               t_soisno,h2osoi_liq,h2osoi_ice,               &amp; <font color=#447700>!i&amp;o<a name='1851'></font>
                               lake_icefrac,t_lake, snowdp,                  &amp; <font color=#447700>!i&amp;o<a name='1852'></font>
                               qflx_snomelt,eflx_snomelt,imelt,              &amp; <font color=#447700>!o  <a name='1853'></font>
                               cv, cv_lake,                                  &amp; <font color=#447700>!i&amp;o<a name='1854'></font>
                               lhabs)                                          <font color=#447700>!o<a name='1855'></font>
<a name='1856'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!<a name='1857'></font>
<a name='1858'>
    <font color=#447700>! 9.5!) Second energy check and water check.  Now check energy balance before and after phase<a name='1859'></font>
    <font color=#447700>!       change, considering the possibility of changed heat capacity during phase change, by<a name='1860'></font>
    <font color=#447700>!       using initial heat capacity in the first step, final heat capacity in the second step,<a name='1861'></font>
    <font color=#447700>!       and differences from tfrz only to avoid enthalpy correction for (cpliq-cpice)*melt*tfrz.<a name='1862'></font>
    <font color=#447700>!       Also check soil water sum.<a name='1863'></font>
<a name='1864'>
#if (defined LAKEDEBUG)<a name='1865'>
    do j = 1, nlevlake<a name='1866'>
<font color=#447700>!dir$ concurrent<a name='1867'></font>
<font color=#447700>!cdir nodep<a name='1868'></font>
       do fc = 1, num_shlakec<a name='1869'>
          c = filter_shlakec(fc)<a name='1870'>
<a name='1871'>
          esum2(c) = esum2(c) - (t_lake(c,j)-tfrz)*cv_lake(c,j)<a name='1872'>
       end do<a name='1873'>
    end do<a name='1874'>
<a name='1875'>
    do j = -nlevsnow+1, nlevsoil<a name='1876'>
<font color=#447700>!dir$ concurrent<a name='1877'></font>
<font color=#447700>!cdir nodep<a name='1878'></font>
       do fc = 1, num_shlakec<a name='1879'>
          c = filter_shlakec(fc)<a name='1880'>
<a name='1881'>
          if (j &gt;= jtop(c)) then<a name='1882'>
             esum2(c) = esum2(c) - (t_soisno(c,j)-tfrz)*cv(c,j)<a name='1883'>
          end if<a name='1884'>
       end do<a name='1885'>
    end do<a name='1886'>
<a name='1887'>
<font color=#447700>!dir$ concurrent<a name='1888'></font>
<font color=#447700>!cdir nodep<a name='1889'></font>
       do fp = 1, num_shlakep<a name='1890'>
          p = filter_shlakep(fp)<a name='1891'>
          c = pcolumn(p)<a name='1892'>
          <font color=#447700>! Again assuming only one pft per column<a name='1893'></font>
          esum2(c) = esum2(c) - lhabs(c)<a name='1894'>
          errsoi(c) = esum2(c)/dtime<a name='1895'>
          if(abs(errsoi(c)) &gt; 1.e-5_r8) then<a name='1896'>
             write(message,*)'Primary soil energy conservation error in shlake column during Phase Change, error (W/m^2):', &amp;<a name='1897'>
                       c, errsoi(c)<a name='1898'>
             CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1144"> ( message )<a name='1899'>
          end if<a name='1900'>
       end do<a name='1901'>
<a name='1902'>
    <font color=#447700>! Check soil water<a name='1903'></font>
    <font color=#447700>! Sum soil water.<a name='1904'></font>
    do j = 1, nlevsoil<a name='1905'>
<font color=#447700>!dir$ concurrent<a name='1906'></font>
<font color=#447700>!cdir nodep<a name='1907'></font>
       do fc = 1, num_shlakec<a name='1908'>
          c = filter_shlakec(fc)<a name='1909'>
          if (j == 1) wsum_end(c) = 0._r8<a name='1910'>
          wsum_end(c) = wsum_end(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='1911'>
          if (j == nlevsoil) then<a name='1912'>
             if (abs(wsum(c)-wsum_end(c))&gt;1.e-7_r8) then<a name='1913'>
                write(message,*)'Soil water balance error during phase change in ShalLakeTemperature.', &amp;<a name='1914'>
                          'column, error (kg/m^2):', c, wsum_end(c)-wsum(c)<a name='1915'>
                CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1145"> ( message )<a name='1916'>
             end if<a name='1917'>
          end if<a name='1918'>
       end do<a name='1919'>
    end do<a name='1920'>
<a name='1921'>
#endif<a name='1922'>
<a name='1923'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='1924'></font>
    <font color=#447700>! 10!) Convective mixing: make sure fracice*dz is conserved, heat content c*dz*T is conserved, and<a name='1925'></font>
    <font color=#447700>! all ice ends up at the top. Done over all lakes even if frozen.<a name='1926'></font>
    <font color=#447700>! Either an unstable density profile or ice in a layer below an incompletely frozen layer will trigger.<a name='1927'></font>
<a name='1928'>
    <font color=#447700>!Recalculate density<a name='1929'></font>
    do j = 1, nlevlake<a name='1930'>
<font color=#447700>!dir$ concurrent<a name='1931'></font>
<font color=#447700>!cdir nodep<a name='1932'></font>
       do fc = 1, num_shlakec<a name='1933'>
          c = filter_shlakec(fc)<a name='1934'>
          rhow(c,j) = (1._r8 - lake_icefrac(c,j)) * &amp;<a name='1935'>
                      1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,j)-277._r8))**1.68_r8 ) &amp;<a name='1936'>
                    + lake_icefrac(c,j)*denice<a name='1937'>
       end do<a name='1938'>
    end do<a name='1939'>
<a name='1940'>
    do j = 1, nlevlake-1<a name='1941'>
<font color=#447700>!dir$ concurrent<a name='1942'></font>
<font color=#447700>!cdir nodep<a name='1943'></font>
       do fc = 1, num_shlakec<a name='1944'>
          c = filter_shlakec(fc)<a name='1945'>
          qav(c) = 0._r8<a name='1946'>
          nav(c) = 0._r8<a name='1947'>
          iceav(c) = 0._r8<a name='1948'>
       end do<a name='1949'>
<a name='1950'>
       do i = 1, j+1<a name='1951'>
<font color=#447700>!dir$ concurrent<a name='1952'></font>
<font color=#447700>!cdir nodep<a name='1953'></font>
          do fc = 1, num_shlakec<a name='1954'>
             c = filter_shlakec(fc)<a name='1955'>
             if (rhow(c,j) &gt; rhow(c,j+1) .or. &amp;<a name='1956'>
                (lake_icefrac(c,j) &lt; 1._r8 .and. lake_icefrac(c,j+1) &gt; 0._r8) ) then<a name='1957'>
#if (defined LAKEDEBUG)<a name='1958'>
                if (i==1)  then<a name='1959'>
                  write(message,*), 'Convective Mixing in column ', c, '.'<a name='1960'>
                  CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_901">(message)<a name='1961'>
                endif<a name='1962'>
#endif<a name='1963'>
                qav(c) = qav(c) + dz_lake(c,i)*(t_lake(c,i)-tfrz) * &amp; <a name='1964'>
                        ((1._r8 - lake_icefrac(c,i))*cwat + lake_icefrac(c,i)*cice_eff)<a name='1965'>
<font color=#447700>!                tav(c) = tav(c) + t_lake(c,i)*dz_lake(c,i)<a name='1966'></font>
                iceav(c) = iceav(c) + lake_icefrac(c,i)*dz_lake(c,i)<a name='1967'>
                nav(c) = nav(c) + dz_lake(c,i)<a name='1968'>
             end if<a name='1969'>
          end do<a name='1970'>
       end do<a name='1971'>
<a name='1972'>
<font color=#447700>!dir$ concurrent<a name='1973'></font>
<font color=#447700>!cdir nodep<a name='1974'></font>
       do fc = 1, num_shlakec<a name='1975'>
          c = filter_shlakec(fc)<a name='1976'>
          if (rhow(c,j) &gt; rhow(c,j+1) .or. &amp;<a name='1977'>
             (lake_icefrac(c,j) &lt; 1._r8 .and. lake_icefrac(c,j+1) &gt; 0._r8) ) then<a name='1978'>
             qav(c) = qav(c)/nav(c)<a name='1979'>
             iceav(c) = iceav(c)/nav(c)<a name='1980'>
             <font color=#447700>!If the average temperature is above freezing, put the extra energy into the water.<a name='1981'></font>
             <font color=#447700>!If it is below freezing, take it away from the ice.<a name='1982'></font>
             if (qav(c) &gt; 0._r8) then<a name='1983'>
                tav_froz(c) = 0._r8 <font color=#447700>!Celsius<a name='1984'></font>
                tav_unfr(c) = qav(c) / ((1._r8 - iceav(c))*cwat)<a name='1985'>
             else if (qav(c) &lt; 0._r8) then<a name='1986'>
                tav_froz(c) = qav(c) / (iceav(c)*cice_eff)<a name='1987'>
                tav_unfr(c) = 0._r8 <font color=#447700>!Celsius<a name='1988'></font>
             else<a name='1989'>
                tav_froz(c) = 0._r8<a name='1990'>
                tav_unfr(c) = 0._r8<a name='1991'>
             end if<a name='1992'>
          end if<a name='1993'>
       end do<a name='1994'>
<a name='1995'>
       do i = 1, j+1<a name='1996'>
<font color=#447700>!dir$ concurrent<a name='1997'></font>
<font color=#447700>!cdir nodep<a name='1998'></font>
          do fc = 1, num_shlakec<a name='1999'>
             c = filter_shlakec(fc)<a name='2000'>
             if (nav(c) &gt; 0._r8) then<a name='2001'>
<font color=#447700>!             if(0==1) then<a name='2002'></font>
<a name='2003'>
                <font color=#447700>!Put all the ice at the top.!<a name='2004'></font>
                <font color=#447700>!If the average temperature is above freezing, put the extra energy into the water.<a name='2005'></font>
                <font color=#447700>!If it is below freezing, take it away from the ice.<a name='2006'></font>
                <font color=#447700>!For the layer with both ice &amp; water, be careful to use the average temperature<a name='2007'></font>
                <font color=#447700>!that preserves the correct total heat content given what the heat capacity of that<a name='2008'></font>
                <font color=#447700>!layer will actually be.<a name='2009'></font>
                if (i == 1) zsum(c) = 0._r8<a name='2010'>
                if ((zsum(c)+dz_lake(c,i))/nav(c) &lt;= iceav(c)) then<a name='2011'>
                   lake_icefrac(c,i) = 1._r8<a name='2012'>
                   t_lake(c,i) = tav_froz(c) + tfrz<a name='2013'>
                else if (zsum(c)/nav(c) &lt; iceav(c)) then<a name='2014'>
                   lake_icefrac(c,i) = (iceav(c)*nav(c) - zsum(c)) / dz_lake(c,i)<a name='2015'>
                   <font color=#447700>! Find average value that preserves correct heat content.<a name='2016'></font>
                   t_lake(c,i) = ( lake_icefrac(c,i)*tav_froz(c)*cice_eff &amp;<a name='2017'>
                               + (1._r8 - lake_icefrac(c,i))*tav_unfr(c)*cwat ) &amp;<a name='2018'>
                               / ( lake_icefrac(c,i)*cice_eff + (1-lake_icefrac(c,i))*cwat ) + tfrz<a name='2019'>
                else<a name='2020'>
                   lake_icefrac(c,i) = 0._r8<a name='2021'>
                   t_lake(c,i) = tav_unfr(c) + tfrz<a name='2022'>
                end if<a name='2023'>
                zsum(c) = zsum(c) + dz_lake(c,i)<a name='2024'>
<a name='2025'>
                rhow(c,i) = (1._r8 - lake_icefrac(c,i)) * &amp; <a name='2026'>
                            1000._r8*( 1.0_r8 - 1.9549e-05_r8*(abs(t_lake(c,i)-277._r8))**1.68_r8 ) &amp;<a name='2027'>
                          + lake_icefrac(c,i)*denice<a name='2028'>
             end if<a name='2029'>
          end do<a name='2030'>
       end do<a name='2031'>
    end do<a name='2032'>
<a name='2033'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!<a name='2034'></font>
    <font color=#447700>! 11!) Re-evaluate thermal properties and sum energy content.<a name='2035'></font>
    <font color=#447700>! For lake<a name='2036'></font>
    do j = 1, nlevlake<a name='2037'>
<font color=#447700>!dir$ concurrent<a name='2038'></font>
<font color=#447700>!cdir nodep<a name='2039'></font>
       do fc = 1, num_shlakec<a name='2040'>
          c = filter_shlakec(fc)<a name='2041'>
<a name='2042'>
          cv_lake(c,j) = dz_lake(c,j) * (cwat*(1._r8-lake_icefrac(c,j)) + cice_eff*lake_icefrac(c,j))<a name='2043'>
#if (defined LAKEDEBUG)<a name='2044'>
          write(message,*)'Lake Ice Fraction, c, level:', c, j, lake_icefrac(c,j)<a name='2045'>
          CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_902">(message)<a name='2046'>
#endif<a name='2047'>
       end do<a name='2048'>
    end do<a name='2049'>
    <font color=#447700>! For snow / soil<a name='2050'></font>
  <font color=#447700>!  call SoilThermProp_Lake(lbc, ubc, num_shlakec, filter_shlakec, tk, cv, tktopsoillay)<a name='2051'></font>
  call <A href='../../html_code/phys/module_sf_lake.F.html#SOILTHERMPROP_LAKE'>SoilThermProp_Lake</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SOILTHERMPROP_LAKE_2"> (snl,dz,zi,z,t_soisno,h2osoi_liq,h2osoi_ice,    &amp;<a name='2052'>
                           tk, cv, tktopsoillay)<a name='2053'>
<a name='2054'>
<a name='2055'>
    <font color=#447700>! Do as above to sum energy content<a name='2056'></font>
    do j = 1, nlevlake<a name='2057'>
<font color=#447700>!dir$ concurrent<a name='2058'></font>
<font color=#447700>!cdir nodep<a name='2059'></font>
       do fc = 1, num_shlakec<a name='2060'>
          c = filter_shlakec(fc)<a name='2061'>
<a name='2062'>
<font color=#447700>!          ncvts(c) = ncvts(c) + cv_lake(c,j)*t_lake(c,j) &amp;<a name='2063'></font>
          ncvts(c) = ncvts(c) + cv_lake(c,j)*(t_lake(c,j)-tfrz) &amp;<a name='2064'>
                   + cfus*dz_lake(c,j)*(1._r8-lake_icefrac(c,j)) <font color=#447700>!&amp;<a name='2065'></font>
<font color=#447700>!                   + (cwat-cice_eff)*lake_icefrac(c)*tfrz*dz_lake(c,j) !enthalpy reconciliation term<a name='2066'></font>
          fin(c) = fin(c) + phi(c,j)<a name='2067'>
       end do<a name='2068'>
    end do<a name='2069'>
<a name='2070'>
    do j = -nlevsnow + 1, nlevsoil<a name='2071'>
<font color=#447700>!dir$ concurrent<a name='2072'></font>
<font color=#447700>!cdir nodep<a name='2073'></font>
       do fc = 1, num_shlakec<a name='2074'>
          c = filter_shlakec(fc)<a name='2075'>
<a name='2076'>
          if (j &gt;= jtop(c)) then<a name='2077'>
<font color=#447700>!             ncvts(c) = ncvts(c) + cv(c,j)*t_soisno(c,j) &amp;<a name='2078'></font>
             ncvts(c) = ncvts(c) + cv(c,j)*(t_soisno(c,j)-tfrz) &amp;<a name='2079'>
                      + hfus*h2osoi_liq(c,j) <font color=#447700>!&amp;<a name='2080'></font>
<font color=#447700>!                      + (cpliq-cpice)*h2osoi_ice(c,j)*tfrz !enthalpy reconciliation term<a name='2081'></font>
             if (j == 1 .and. h2osno(c) &gt; 0._r8 .and. j == jtop(c)) then<a name='2082'>
                ncvts(c) = ncvts(c) - h2osno(c)*hfus<a name='2083'>
             end if<a name='2084'>
          end if<a name='2085'>
          if (j == 1) fin(c) = fin(c) + phi_soil(c)<a name='2086'>
       end do<a name='2087'>
    end do<a name='2088'>
<a name='2089'>
<a name='2090'>
    <font color=#447700>! Check energy conservation.<a name='2091'></font>
<a name='2092'>
    do fp = 1, num_shlakep<a name='2093'>
       p = filter_shlakep(fp)<a name='2094'>
       c = pcolumn(p)<a name='2095'>
       errsoi(c) = (ncvts(c)-ocvts(c)) / dtime - fin(c)<a name='2096'>
#ifndef LAKEDEBUG<a name='2097'>
<font color=#447700>!       if (abs(errsoi(c)) &lt; 0.10_r8) then ! else send to Balance Check and abort<a name='2098'></font>
       if (abs(errsoi(c)) &lt; 10._r8) then <font color=#447700>! else send to Balance Check and abort<a name='2099'></font>
#else<a name='2100'>
       if (abs(errsoi(c)) &lt; 1._r8) then<a name='2101'>
#endif<a name='2102'>
          eflx_sh_tot(p) = eflx_sh_tot(p) - errsoi(c)<a name='2103'>
          eflx_sh_grnd(p) = eflx_sh_grnd(p) - errsoi(c)<a name='2104'>
          eflx_soil_grnd(p) = eflx_soil_grnd(p) + errsoi(c)<a name='2105'>
          eflx_gnet(p) = eflx_gnet(p) + errsoi(c)<a name='2106'>
<font color=#447700>!          if (abs(errsoi(c)) &gt; 1.e-3_r8) then<a name='2107'></font>
          if (abs(errsoi(c)) &gt; 1.e-1_r8) then<a name='2108'>
             write(message,*)'errsoi incorporated into sensible heat in ShalLakeTemperature: c, (W/m^2):', c, errsoi(c)<a name='2109'>
             CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_903">(message)<a name='2110'>
          end if<a name='2111'>
          errsoi(c) = 0._r8<a name='2112'>
#if (defined LAKEDEBUG)<a name='2113'>
       else<a name='2114'>
          write(message,*)'Soil Energy Balance Error at column, ', c, 'G, fintotal, column E tendency = ', &amp;<a name='2115'>
             eflx_gnet(p), fin(c), (ncvts(c)-ocvts(c)) / dtime<a name='2116'>
          CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKETEMPERATURE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_904">(message)<a name='2117'>
#endif<a name='2118'>
       end if<a name='2119'>
    end do<a name='2120'>
    <font color=#447700>! This loop assumes only one point per column.<a name='2121'></font>
<a name='2122'>
  end subroutine ShalLakeTemperature<a name='2123'>
<a name='2124'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='2125'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='2126'></font>
<font color=#447700>!BOP<a name='2127'></font>
<font color=#447700>!<a name='2128'></font>
<font color=#447700>! ROUTINE: SoilThermProp_Lake<a name='2129'></font>
<font color=#447700>!<a name='2130'></font>
<font color=#447700>! !INTERFACE:<a name='2131'></font>
<A NAME='SOILTHERMPROP_LAKE'><A href='../../html_code/phys/module_sf_lake.F.html#SOILTHERMPROP_LAKE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='2132'>
  <font color=#993300>subroutine </font><font color=#cc0000>SoilThermProp_Lake</font> (snl,dz,zi,z,t_soisno,h2osoi_liq,h2osoi_ice,    &amp; <A href='../../call_to/SOILTHERMPROP_LAKE.html' TARGET='index'>2</A>,<A href='../../call_from/SOILTHERMPROP_LAKE.html' TARGET='index'>1</A><a name='2133'>
                           tk, cv, tktopsoillay)<a name='2134'>
<a name='2135'>
<font color=#447700>!<a name='2136'></font>
<font color=#447700>! !DESCRIPTION:<a name='2137'></font>
<font color=#447700>! Calculation of thermal conductivities and heat capacities of<a name='2138'></font>
<font color=#447700>! snow/soil layers<a name='2139'></font>
<font color=#447700>! (1) The volumetric heat capacity is calculated as a linear combination<a name='2140'></font>
<font color=#447700>!     in terms of the volumetric fraction of the constituent phases.<a name='2141'></font>
<font color=#447700>!<a name='2142'></font>
<font color=#447700>! (2) The thermal conductivity of soil is computed from the algorithm of<a name='2143'></font>
<font color=#447700>!     Johansen (as reported by Farouki 1981), and of snow is from the<a name='2144'></font>
<font color=#447700>!     formulation used in SNTHERM (Jordan 1991).<a name='2145'></font>
<font color=#447700>! The thermal conductivities at the interfaces between two neighboring<a name='2146'></font>
<font color=#447700>! layers (j, j+1) are derived from an assumption that the flux across<a name='2147'></font>
<font color=#447700>! the interface is equal to that from the node j to the interface and the<a name='2148'></font>
<font color=#447700>! flux from the interface to the node j+1.<a name='2149'></font>
<font color=#447700>!<a name='2150'></font>
<font color=#447700>! For lakes, the proper soil layers (not snow) should always be saturated.<a name='2151'></font>
<font color=#447700>!<a name='2152'></font>
<font color=#447700>! !USES:<a name='2153'></font>
<a name='2154'>
    implicit none<a name='2155'>
<font color=#447700>!in<a name='2156'></font>
<a name='2157'>
    integer , intent(in) :: snl(1)           <font color=#447700>! number of snow layers<a name='2158'></font>
<font color=#447700>!    real(r8), intent(in) :: h2osno(1)        ! snow water (mm H2O)<a name='2159'></font>
   <font color=#447700>! real(r8), intent(in) :: watsat(1,nlevsoil)      ! volumetric soil water at saturation (porosity)<a name='2160'></font>
   <font color=#447700>! real(r8), intent(in) :: tksatu(1,nlevsoil)      ! thermal conductivity, saturated soil [W/m-K]<a name='2161'></font>
   <font color=#447700>! real(r8), intent(in) :: tkmg(1,nlevsoil)        ! thermal conductivity, soil minerals  [W/m-K]<a name='2162'></font>
   <font color=#447700>! real(r8), intent(in) :: tkdry(1,nlevsoil)       ! thermal conductivity, dry soil (W/m/Kelvin)<a name='2163'></font>
   <font color=#447700>! real(r8), intent(in) :: csol(1,nlevsoil)        ! heat capacity, soil solids (J/m**3/Kelvin)<a name='2164'></font>
    real(r8), intent(in) :: dz(1,-nlevsnow+1:nlevsoil)          <font color=#447700>! layer thickness (m)<a name='2165'></font>
    real(r8), intent(in) :: zi(1,-nlevsnow+0:nlevsoil)          <font color=#447700>! interface level below a "z" level (m)<a name='2166'></font>
    real(r8), intent(in) :: z(1,-nlevsnow+1:nlevsoil)           <font color=#447700>! layer depth (m)<a name='2167'></font>
    real(r8), intent(in) :: t_soisno(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! soil temperature (Kelvin)<a name='2168'></font>
    real(r8), intent(in) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! liquid water (kg/m2)<a name='2169'></font>
    real(r8), intent(in) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! ice lens (kg/m2)<a name='2170'></font>
<a name='2171'>
<font color=#447700>!out<a name='2172'></font>
    real(r8), intent(out) :: cv(lbc:ubc,-nlevsnow+1:nlevsoil) <font color=#447700>! heat capacity [J/(m2 K)]<a name='2173'></font>
    real(r8), intent(out) :: tk(lbc:ubc,-nlevsnow+1:nlevsoil) <font color=#447700>! thermal conductivity [W/(m K)]<a name='2174'></font>
    real(r8), intent(out) :: tktopsoillay(lbc:ubc)          <font color=#447700>! thermal conductivity [W/(m K)]<a name='2175'></font>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='2176'></font>
<font color=#447700>! !CALLED FROM:<a name='2177'></font>
<font color=#447700>! subroutine ShalLakeTemperature in this module.<a name='2178'></font>
<font color=#447700>!<a name='2179'></font>
<font color=#447700>! !REVISION HISTORY:<a name='2180'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='2181'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='2182'></font>
<font color=#447700>! 2/13/02, Peter Thornton: migrated to new data structures<a name='2183'></font>
<font color=#447700>! 7/01/03, Mariana Vertenstein: migrated to vector code<a name='2184'></font>
<font color=#447700>! 4/09, Zack Subin, adjustment for ShalLake code.<a name='2185'></font>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='2186'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='2187'></font>
<font color=#447700>!<a name='2188'></font>
<font color=#447700>! local pointers to original implicit in scalars<a name='2189'></font>
<font color=#447700>!<a name='2190'></font>
<font color=#447700>!    integer , pointer :: clandunit(:)     ! column's landunit<a name='2191'></font>
<font color=#447700>!    integer , pointer :: ityplun(:)       ! landunit type<a name='2192'></font>
<font color=#447700>!<a name='2193'></font>
<font color=#447700>!EOP<a name='2194'></font>
<a name='2195'>
<a name='2196'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='2197'></font>
<a name='2198'>
    integer  :: l,c,j                     <font color=#447700>! indices<a name='2199'></font>
    integer  :: fc                        <font color=#447700>! lake filtered column indices<a name='2200'></font>
    real(r8) :: bw                        <font color=#447700>! partial density of water (ice + liquid)<a name='2201'></font>
    real(r8) :: dksat                     <font color=#447700>! thermal conductivity for saturated soil (j/(k s m))<a name='2202'></font>
    real(r8) :: dke                       <font color=#447700>! kersten number<a name='2203'></font>
    real(r8) :: fl                        <font color=#447700>! fraction of liquid or unfrozen water to total water<a name='2204'></font>
    real(r8) :: satw                      <font color=#447700>! relative total water content of soil.<a name='2205'></font>
    real(r8) :: thk(lbc:ubc,-nlevsnow+1:nlevsoil) <font color=#447700>! thermal conductivity of layer<a name='2206'></font>
    character*256 :: message <a name='2207'>
<a name='2208'>
<font color=#447700>! Thermal conductivity of soil from Farouki (1981)<a name='2209'></font>
<a name='2210'>
    do j = -nlevsnow+1,nlevsoil<a name='2211'>
<font color=#447700>!dir$ concurrent<a name='2212'></font>
<font color=#447700>!cdir nodep<a name='2213'></font>
       do fc = 1, num_shlakec<a name='2214'>
          c = filter_shlakec(fc)<a name='2215'>
<a name='2216'>
          <font color=#447700>! Only examine levels from 1-&gt;nlevsoil<a name='2217'></font>
          if (j &gt;= 1) then<a name='2218'>
<font color=#447700>!             l = clandunit(c)<a name='2219'></font>
<font color=#447700>!             if (ityplun(l) /= istwet .AND. ityplun(l) /= istice) then<a name='2220'></font>
              <font color=#447700>! This could be altered later for allowing this to be over glaciers.<a name='2221'></font>
<a name='2222'>
          <font color=#447700>! Soil should be saturated.<a name='2223'></font>
#if (defined LAKEDEBUG)<a name='2224'>
                satw = (h2osoi_liq(c,j)/denh2o + h2osoi_ice(c,j)/denice)/(dz(c,j)*watsat(c,j))<a name='2225'>
<font color=#447700>!                satw = min(1._r8, satw)<a name='2226'></font>
                if (satw &lt; 0.999_r8) then<a name='2227'>
                   write(message,*)'WARNING: soil layer unsaturated in SoilThermProp_Lake, satw, j = ', satw, j<a name='2228'>
                   CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SOILTHERMPROP_LAKE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1146"> ( message )<a name='2229'>
                end if<a name='2230'>
          <font color=#447700>! Could use denice because if it starts out frozen, the volume of water will go below sat.,<a name='2231'></font>
          <font color=#447700>! since we're not yet doing excess ice.<a name='2232'></font>
          <font color=#447700>! But take care of this in HydrologyLake.<a name='2233'></font>
#endif<a name='2234'>
                satw = 1._r8<a name='2235'>
                   fl = h2osoi_liq(c,j)/(h2osoi_ice(c,j)+h2osoi_liq(c,j))<a name='2236'>
                   if (t_soisno(c,j) &gt;= tfrz) then       <font color=#447700>! Unfrozen soil<a name='2237'></font>
                      dke = max(0._r8, log10(satw) + 1.0_r8)<a name='2238'>
                      dksat = tksatu(c,j)<a name='2239'>
                   else                               <font color=#447700>! Frozen soil<a name='2240'></font>
                      dke = satw<a name='2241'>
                      dksat = tkmg(c,j)*0.249_r8**(fl*watsat(c,j))*2.29_r8**watsat(c,j)<a name='2242'>
                   endif<a name='2243'>
                   thk(c,j) = dke*dksat + (1._r8-dke)*tkdry(c,j)<a name='2244'>
<font color=#447700>!             else<a name='2245'></font>
<font color=#447700>!                thk(c,j) = tkwat<a name='2246'></font>
<font color=#447700>!                if (t_soisno(c,j) &lt; tfrz) thk(c,j) = tkice<a name='2247'></font>
<font color=#447700>!             endif<a name='2248'></font>
          endif<a name='2249'>
<a name='2250'>
          <font color=#447700>! Thermal conductivity of snow, which from Jordan (1991) pp. 18<a name='2251'></font>
          <font color=#447700>! Only examine levels from snl(c)+1 -&gt; 0 where snl(c) &lt; 1<a name='2252'></font>
          if (snl(c)+1 &lt; 1 .AND. (j &gt;= snl(c)+1) .AND. (j &lt;= 0)) then<a name='2253'>
             bw = (h2osoi_ice(c,j)+h2osoi_liq(c,j))/dz(c,j)<a name='2254'>
             thk(c,j) = tkairc + (7.75e-5_r8 *bw + 1.105e-6_r8*bw*bw)*(tkice-tkairc)<a name='2255'>
          end if<a name='2256'>
<a name='2257'>
       end do<a name='2258'>
    end do<a name='2259'>
<a name='2260'>
    <font color=#447700>! Thermal conductivity at the layer interface<a name='2261'></font>
<a name='2262'>
    <font color=#447700>! Have to correct for the fact that bottom snow layer and top soil layer border lake.<a name='2263'></font>
    <font color=#447700>! For the first case, the snow layer conductivity for the middle of the layer will be returned.<a name='2264'></font>
    <font color=#447700>! Because the interfaces are below the soil layers, the conductivity for the top soil layer<a name='2265'></font>
    <font color=#447700>! will have to be returned separately.<a name='2266'></font>
    do j = -nlevsnow+1,nlevsoil<a name='2267'>
<font color=#447700>!dir$ concurrent<a name='2268'></font>
<font color=#447700>!cdir nodep<a name='2269'></font>
       do fc = 1,num_shlakec<a name='2270'>
          c = filter_shlakec(fc)<a name='2271'>
          if (j &gt;= snl(c)+1 .AND. j &lt;= nlevsoil-1 .AND. j /= 0) then<a name='2272'>
             tk(c,j) = thk(c,j)*thk(c,j+1)*(z(c,j+1)-z(c,j)) &amp;<a name='2273'>
                  /(thk(c,j)*(z(c,j+1)-zi(c,j))+thk(c,j+1)*(zi(c,j)-z(c,j)))<a name='2274'>
          else if (j == 0) then<a name='2275'>
             tk(c,j) = thk(c,j)<a name='2276'>
          else if (j == nlevsoil) then<a name='2277'>
             tk(c,j) = 0._r8<a name='2278'>
          end if<a name='2279'>
          <font color=#447700>! For top soil layer.<a name='2280'></font>
          if (j == 1) tktopsoillay(c) = thk(c,j)<a name='2281'>
       end do<a name='2282'>
    end do<a name='2283'>
<a name='2284'>
    <font color=#447700>! Soil heat capacity, from de Vires (1963)<a name='2285'></font>
<a name='2286'>
    do j = 1, nlevsoil<a name='2287'>
<font color=#447700>!dir$ concurrent<a name='2288'></font>
<font color=#447700>!cdir nodep<a name='2289'></font>
       do fc = 1,num_shlakec<a name='2290'>
          c = filter_shlakec(fc)<a name='2291'>
<font color=#447700>!          l = clandunit(c)<a name='2292'></font>
<font color=#447700>!          if (ityplun(l) /= istwet .AND. ityplun(l) /= istice) then<a name='2293'></font>
             cv(c,j) = csol(c,j)*(1-watsat(c,j))*dz(c,j) +   &amp;<a name='2294'>
               (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)<a name='2295'>
<font color=#447700>!          else<a name='2296'></font>
<font color=#447700>!             cv(c,j) = (h2osoi_ice(c,j)*cpice + h2osoi_liq(c,j)*cpliq)<a name='2297'></font>
<font color=#447700>!          endif<a name='2298'></font>
<font color=#447700>!          if (j == 1) then<a name='2299'></font>
<font color=#447700>!             if (snl(c)+1 == 1 .AND. h2osno(c) &gt; 0._r8) then<a name='2300'></font>
<font color=#447700>!                cv(c,j) = cv(c,j) + cpice*h2osno(c)<a name='2301'></font>
<font color=#447700>!             end if<a name='2302'></font>
<font color=#447700>!          end if<a name='2303'></font>
       <font color=#447700>! Won't worry about heat capacity for thin snow on lake with no snow layers.<a name='2304'></font>
       enddo<a name='2305'>
    end do<a name='2306'>
<a name='2307'>
    <font color=#447700>! Snow heat capacity<a name='2308'></font>
<a name='2309'>
    do j = -nlevsnow+1,0<a name='2310'>
<font color=#447700>!dir$ concurrent<a name='2311'></font>
<font color=#447700>!cdir nodep<a name='2312'></font>
       do fc = 1,num_shlakec<a name='2313'>
          c = filter_shlakec(fc)<a name='2314'>
          if (snl(c)+1 &lt; 1 .and. j &gt;= snl(c)+1) then<a name='2315'>
             cv(c,j) = cpliq*h2osoi_liq(c,j) + cpice*h2osoi_ice(c,j)<a name='2316'>
          end if<a name='2317'>
       end do<a name='2318'>
    end do<a name='2319'>
<a name='2320'>
  end subroutine SoilThermProp_Lake<a name='2321'>
<a name='2322'>
<a name='2323'>
<font color=#447700>!-----------------------------------------------------------------------<a name='2324'></font>
<font color=#447700>!BOP<a name='2325'></font>
<font color=#447700>!<a name='2326'></font>
<font color=#447700>! ROUTINE: PhaseChange_Lake<a name='2327'></font>
<font color=#447700>!<a name='2328'></font>
<font color=#447700>! !INTERFACE:<a name='2329'></font>
<A NAME='PHASECHANGE_LAKE'><A href='../../html_code/phys/module_sf_lake.F.html#PHASECHANGE_LAKE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='2330'>
  <font color=#993300>subroutine </font><font color=#cc0000>PhaseChange_Lake</font> (snl,h2osno,dz,dz_lake,                        &amp; <font color=#447700>!i <A href='../../call_to/PHASECHANGE_LAKE.html' TARGET='index'>1</A><a name='2331'></font>
                               t_soisno,h2osoi_liq,h2osoi_ice,               &amp; <font color=#447700>!i&amp;o<a name='2332'></font>
                               lake_icefrac,t_lake, snowdp,                  &amp; <font color=#447700>!i&amp;o<a name='2333'></font>
                               qflx_snomelt,eflx_snomelt,imelt,              &amp; <font color=#447700>!o  <a name='2334'></font>
                               cv, cv_lake,                                  &amp; <font color=#447700>!i&amp;o<a name='2335'></font>
                               lhabs)                                          <font color=#447700>!o<a name='2336'></font>
<font color=#447700>!=============================================================================================<a name='2337'></font>
<font color=#447700>! !DESCRIPTION:<a name='2338'></font>
<font color=#447700>! Calculation of the phase change within snow, soil, &amp; lake layers:<a name='2339'></font>
<font color=#447700>! (1) Check the conditions for which the phase change may take place,<a name='2340'></font>
<font color=#447700>!     i.e., the layer temperature is great than the freezing point<a name='2341'></font>
<font color=#447700>!     and the ice mass is not equal to zero (i.e. melting),<a name='2342'></font>
<font color=#447700>!     or the layer temperature is less than the freezing point<a name='2343'></font>
<font color=#447700>!     and the liquid water mass is greater than the allowable supercooled <a name='2344'></font>
<font color=#447700>!    (i.e. freezing).<a name='2345'></font>
<font color=#447700>! (2) Assess the amount of phase change from the energy excess (or deficit)<a name='2346'></font>
<font color=#447700>!     after setting the layer temperature to freezing point, depending on<a name='2347'></font>
<font color=#447700>!     how much water or ice is available.<a name='2348'></font>
<font color=#447700>! (3) Re-adjust the ice and liquid mass, and the layer temperature: either to<a name='2349'></font>
<font color=#447700>!     the freezing point if enough water or ice is available to fully compensate,<a name='2350'></font>
<font color=#447700>!     or to a remaining temperature.<a name='2351'></font>
<font color=#447700>! The specific heats are assumed constant. Potential cycling errors resulting from<a name='2352'></font>
<font color=#447700>! this assumption will be trapped at the end of ShalLakeTemperature.<a name='2353'></font>
<font color=#447700>! !CALLED FROM:<a name='2354'></font>
<font color=#447700>! subroutine ShalLakeTemperature in this module<a name='2355'></font>
<font color=#447700>!<a name='2356'></font>
<font color=#447700>! !REVISION HISTORY:<a name='2357'></font>
<font color=#447700>! 04/2009 Zack Subin: Initial code<a name='2358'></font>
<font color=#447700>!==============================================================================================<a name='2359'></font>
<font color=#447700>! !USES:<a name='2360'></font>
<font color=#447700>!<a name='2361'></font>
<font color=#447700>! !ARGUMENTS:<a name='2362'></font>
    implicit none<a name='2363'>
<font color=#447700>!in: <a name='2364'></font>
<a name='2365'>
    integer , intent(in) :: snl(1)           <font color=#447700>!number of snow layers<a name='2366'></font>
    real(r8), intent(inout) :: h2osno(1)        <font color=#447700>!snow water (mm H2O)<a name='2367'></font>
    real(r8), intent(in) :: dz(1,-nlevsnow+1:nlevsoil)          <font color=#447700>!layer thickness (m)<a name='2368'></font>
    real(r8), intent(in) :: dz_lake(1,nlevlake)     <font color=#447700>!lake layer thickness (m)<a name='2369'></font>
    <font color=#447700>! Needed in case snow height is less than critical value.<a name='2370'></font>
<a name='2371'>
<font color=#447700>!inout: <a name='2372'></font>
<a name='2373'>
    real(r8), intent(inout) :: snowdp(1)        <font color=#447700>!snow height (m)<a name='2374'></font>
    real(r8), intent(inout) :: t_soisno(1,-nlevsnow+1:nlevsoil)     <font color=#447700>!soil temperature (Kelvin)<a name='2375'></font>
    real(r8), intent(inout) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!liquid water (kg/m2)<a name='2376'></font>
    real(r8), intent(inout) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!ice lens (kg/m2)<a name='2377'></font>
    real(r8), intent(inout) :: lake_icefrac(1,nlevlake) <font color=#447700>! mass fraction of lake layer that is frozen<a name='2378'></font>
    real(r8), intent(inout) :: t_lake(1,nlevlake)       <font color=#447700>! lake temperature (Kelvin)<a name='2379'></font>
<font color=#447700>!out: <a name='2380'></font>
<a name='2381'>
    real(r8), intent(out) :: qflx_snomelt(1)  <font color=#447700>!snow melt (mm H2O /s)<a name='2382'></font>
    real(r8), intent(out) :: eflx_snomelt(1)  <font color=#447700>!snow melt heat flux (W/m**2)<a name='2383'></font>
    integer, intent(out)  :: imelt(1,-nlevsnow+1:nlevsoil)        <font color=#447700>!flag for melting (=1), freezing (=2), Not=0 (new)<a name='2384'></font>
                                          <font color=#447700>!What's the sign of this? Is it just output?<a name='2385'></font>
    real(r8), intent(inout) :: cv(lbc:ubc,-nlevsnow+1:nlevsoil)       <font color=#447700>! heat capacity [J/(m2 K)]<a name='2386'></font>
    real(r8), intent(inout) :: cv_lake (lbc:ubc,1:nlevlake)          <font color=#447700>! heat capacity [J/(m2 K)]<a name='2387'></font>
    real(r8), intent(out):: lhabs(lbc:ubc)                       <font color=#447700>! total per-column latent heat abs. (J/m^2)<a name='2388'></font>
<a name='2389'>
<a name='2390'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='2391'></font>
<a name='2392'>
    integer  :: j,c,g                              <font color=#447700>!do loop index<a name='2393'></font>
    integer  :: fc                                 <font color=#447700>!lake filtered column indices<a name='2394'></font>
<font color=#447700>!    real(r8) :: dtime                              !land model time step (sec)<a name='2395'></font>
    real(r8) :: heatavail                          <font color=#447700>!available energy for melting or freezing (J/m^2)<a name='2396'></font>
    real(r8) :: heatrem                            <font color=#447700>!energy residual or loss after melting or freezing<a name='2397'></font>
    real(r8) :: melt                               <font color=#447700>!actual melting (+) or freezing (-) [kg/m2]<a name='2398'></font>
    real(r8), parameter :: smallnumber = 1.e-7_r8  <font color=#447700>!to prevent tiny residuals from rounding error<a name='2399'></font>
    logical  :: dophasechangeflag<a name='2400'>
<font color=#447700>!-----------------------------------------------------------------------<a name='2401'></font>
<a name='2402'>
<font color=#447700>!    dtime = get_step_size()<a name='2403'></font>
<a name='2404'>
    <font color=#447700>! Initialization<a name='2405'></font>
<a name='2406'>
<font color=#447700>!dir$ concurrent<a name='2407'></font>
<font color=#447700>!cdir nodep<a name='2408'></font>
    do fc = 1,num_shlakec<a name='2409'>
       c = filter_shlakec(fc)<a name='2410'>
<a name='2411'>
       qflx_snomelt(c) = 0._r8<a name='2412'>
       eflx_snomelt(c) = 0._r8<a name='2413'>
       lhabs(c)        = 0._r8<a name='2414'>
    end do<a name='2415'>
<a name='2416'>
    do j = -nlevsnow+1,0<a name='2417'>
<font color=#447700>!dir$ concurrent<a name='2418'></font>
<font color=#447700>!cdir nodep<a name='2419'></font>
       do fc = 1,num_shlakec<a name='2420'>
          c = filter_shlakec(fc)<a name='2421'>
<a name='2422'>
          if (j &gt;= snl(c) + 1) imelt(c,j) = 0<a name='2423'>
       end do<a name='2424'>
    end do<a name='2425'>
<a name='2426'>
    <font color=#447700>! Check for case of snow without snow layers and top lake layer temp above freezing.<a name='2427'></font>
<a name='2428'>
<font color=#447700>!dir$ concurrent<a name='2429'></font>
<font color=#447700>!cdir nodep<a name='2430'></font>
    do fc = 1,num_shlakec<a name='2431'>
       c = filter_shlakec(fc)<a name='2432'>
<a name='2433'>
       if (snl(c) == 0 .and. h2osno(c) &gt; 0._r8 .and. t_lake(c,1) &gt; tfrz) then<a name='2434'>
          heatavail = (t_lake(c,1) - tfrz) * cv_lake(c,1)<a name='2435'>
          melt = min(h2osno(c), heatavail/hfus)<a name='2436'>
          heatrem = max(heatavail - melt*hfus, 0._r8)<a name='2437'>
                       <font color=#447700>!catch small negative value to keep t at tfrz<a name='2438'></font>
          t_lake(c,1) = tfrz + heatrem/(cv_lake(c,1))<a name='2439'>
          snowdp(c) = snowdp(c)*(1._r8 - melt/h2osno(c))<a name='2440'>
          h2osno(c) = h2osno(c) - melt<a name='2441'>
          lhabs(c) = lhabs(c) + melt*hfus<a name='2442'>
          qflx_snomelt(c) = qflx_snomelt(c) + melt<a name='2443'>
          <font color=#447700>! Prevent tiny residuals<a name='2444'></font>
          if (h2osno(c) &lt; smallnumber) h2osno(c) = 0._r8<a name='2445'>
          if (snowdp(c) &lt; smallnumber) snowdp(c) = 0._r8<a name='2446'>
       end if<a name='2447'>
    end do<a name='2448'>
<a name='2449'>
    <font color=#447700>! Lake phase change<a name='2450'></font>
<a name='2451'>
    do j = 1,nlevlake<a name='2452'>
<font color=#447700>!dir$ concurrent<a name='2453'></font>
<font color=#447700>!cdir nodep<a name='2454'></font>
       do fc = 1,num_shlakec<a name='2455'>
          c = filter_shlakec(fc)<a name='2456'>
<a name='2457'>
          dophasechangeflag = .false.<a name='2458'>
          if (t_lake(c,j) &gt; tfrz .and. lake_icefrac(c,j) &gt; 0._r8) then <font color=#447700>! melting<a name='2459'></font>
             dophasechangeflag = .true.<a name='2460'>
             heatavail = (t_lake(c,j) - tfrz) * cv_lake(c,j)<a name='2461'>
             melt = min(lake_icefrac(c,j)*denh2o*dz_lake(c,j), heatavail/hfus)<a name='2462'>
                        <font color=#447700>!denh2o is used because layer thickness is not adjusted for freezing<a name='2463'></font>
             heatrem = max(heatavail - melt*hfus, 0._r8)<a name='2464'>
                       <font color=#447700>!catch small negative value to keep t at tfrz<a name='2465'></font>
          else if (t_lake(c,j) &lt; tfrz .and. lake_icefrac(c,j) &lt; 1._r8) then <font color=#447700>!freezing<a name='2466'></font>
             dophasechangeflag = .true.<a name='2467'>
             heatavail = (t_lake(c,j) - tfrz) * cv_lake(c,j)<a name='2468'>
             melt = max(-(1._r8-lake_icefrac(c,j))*denh2o*dz_lake(c,j), heatavail/hfus)<a name='2469'>
                        <font color=#447700>!denh2o is used because layer thickness is not adjusted for freezing<a name='2470'></font>
             heatrem = min(heatavail - melt*hfus, 0._r8)<a name='2471'>
                       <font color=#447700>!catch small positive value to keep t at tfrz<a name='2472'></font>
          end if<a name='2473'>
          <font color=#447700>! Update temperature and ice fraction.<a name='2474'></font>
          if (dophasechangeflag) then<a name='2475'>
             lake_icefrac(c,j) = lake_icefrac(c,j) - melt/(denh2o*dz_lake(c,j))<a name='2476'>
             lhabs(c) = lhabs(c) + melt*hfus<a name='2477'>
          <font color=#447700>! Update heat capacity<a name='2478'></font>
             cv_lake(c,j) = cv_lake(c,j) + melt*(cpliq-cpice)<a name='2479'>
             t_lake(c,j) = tfrz + heatrem/cv_lake(c,j)<a name='2480'>
             <font color=#447700>! Prevent tiny residuals<a name='2481'></font>
             if (lake_icefrac(c,j) &gt; 1._r8 - smallnumber) lake_icefrac(c,j) = 1._r8<a name='2482'>
             if (lake_icefrac(c,j) &lt; smallnumber)         lake_icefrac(c,j) = 0._r8<a name='2483'>
          end if<a name='2484'>
       end do<a name='2485'>
    end do<a name='2486'>
<a name='2487'>
    <font color=#447700>! Snow &amp; soil phase change<a name='2488'></font>
<a name='2489'>
    do j = -nlevsnow+1,nlevsoil<a name='2490'>
<font color=#447700>!dir$ concurrent<a name='2491'></font>
<font color=#447700>!cdir nodep<a name='2492'></font>
       do fc = 1,num_shlakec<a name='2493'>
          c = filter_shlakec(fc)<a name='2494'>
          dophasechangeflag = .false.<a name='2495'>
<a name='2496'>
          if (j &gt;= snl(c) + 1) then<a name='2497'>
<a name='2498'>
             if (t_soisno(c,j) &gt; tfrz .and. h2osoi_ice(c,j) &gt; 0._r8) then <font color=#447700>! melting<a name='2499'></font>
                dophasechangeflag = .true.<a name='2500'>
                heatavail = (t_soisno(c,j) - tfrz) * cv(c,j)<a name='2501'>
                melt = min(h2osoi_ice(c,j), heatavail/hfus)<a name='2502'>
                heatrem = max(heatavail - melt*hfus, 0._r8)<a name='2503'>
                          <font color=#447700>!catch small negative value to keep t at tfrz<a name='2504'></font>
                if (j &lt;= 0) then <font color=#447700>!snow<a name='2505'></font>
                   imelt(c,j) = 1<a name='2506'>
                   qflx_snomelt(c) = qflx_snomelt(c) + melt<a name='2507'>
                end if<a name='2508'>
             else if (t_soisno(c,j) &lt; tfrz .and. h2osoi_liq(c,j) &gt; 0._r8) then <font color=#447700>!freezing<a name='2509'></font>
                dophasechangeflag = .true.<a name='2510'>
                heatavail = (t_soisno(c,j) - tfrz) * cv(c,j)<a name='2511'>
                melt = max(-h2osoi_liq(c,j), heatavail/hfus)<a name='2512'>
                heatrem = min(heatavail - melt*hfus, 0._r8)<a name='2513'>
                          <font color=#447700>!catch small positive value to keep t at tfrz<a name='2514'></font>
                if (j &lt;= 0) then <font color=#447700>!snow<a name='2515'></font>
                   imelt(c,j) = 2<a name='2516'>
                   qflx_snomelt(c) = qflx_snomelt(c) + melt<a name='2517'>
                   <font color=#447700>! Does this works for both signs of melt in SnowHydrology? I think<a name='2518'></font>
                   <font color=#447700>! qflx_snomelt(c) is just output.<a name='2519'></font>
                end if<a name='2520'>
             end if<a name='2521'>
<a name='2522'>
             <font color=#447700>! Update temperature and soil components.<a name='2523'></font>
             if (dophasechangeflag) then<a name='2524'>
                h2osoi_ice(c,j) = h2osoi_ice(c,j) - melt<a name='2525'>
                h2osoi_liq(c,j) = h2osoi_liq(c,j) + melt<a name='2526'>
                lhabs(c) = lhabs(c) + melt*hfus<a name='2527'>
             <font color=#447700>! Update heat capacity<a name='2528'></font>
                cv(c,j) = cv(c,j) + melt*(cpliq-cpice)<a name='2529'>
                t_soisno(c,j) = tfrz + heatrem/cv(c,j)<a name='2530'>
                <font color=#447700>! Prevent tiny residuals<a name='2531'></font>
                if (h2osoi_ice(c,j) &lt; smallnumber) h2osoi_ice(c,j) = 0._r8<a name='2532'>
                if (h2osoi_liq(c,j) &lt; smallnumber) h2osoi_liq(c,j) = 0._r8<a name='2533'>
             end if<a name='2534'>
<a name='2535'>
         end if<a name='2536'>
      end do<a name='2537'>
   end do<a name='2538'>
<a name='2539'>
   <font color=#447700>! Update eflx_snomelt(c)<a name='2540'></font>
<font color=#447700>!dir$ concurrent<a name='2541'></font>
<font color=#447700>!cdir nodep<a name='2542'></font>
    do fc = 1,num_shlakec<a name='2543'>
       c = filter_shlakec(fc)<a name='2544'>
       eflx_snomelt(c) = qflx_snomelt(c)*hfus<a name='2545'>
    end do<a name='2546'>
<font color=#447700>!!!<a name='2547'></font>
<a name='2548'>
   end subroutine PhaseChange_Lake<a name='2549'>
<a name='2550'>
<a name='2551'>
<A NAME='SHALLAKEHYDROLOGY'><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='2552'>
  <font color=#993300>subroutine </font><font color=#cc0000>ShalLakeHydrology</font>(dz_lake,forc_rain,forc_snow,                      &amp; <font color=#447700>!i <A href='../../call_to/SHALLAKEHYDROLOGY.html' TARGET='index'>1</A>,<A href='../../call_from/SHALLAKEHYDROLOGY.html' TARGET='index'>9</A><a name='2553'></font>
                               begwb,qflx_evap_tot,forc_t,do_capsnow,            &amp;<a name='2554'>
                               t_grnd,qflx_evap_soi,                             &amp;<a name='2555'>
                               qflx_snomelt,imelt,frac_iceold,                   &amp; <font color=#447700>!i add by guhp<a name='2556'></font>
                               z,dz,zi,snl,h2osno,snowdp,lake_icefrac,t_lake,      &amp; <font color=#447700>!i&amp;o<a name='2557'></font>
                               endwb,snowage,snowice,snowliq,t_snow,             &amp; <font color=#447700>!o<a name='2558'></font>
                               t_soisno,h2osoi_ice,h2osoi_liq,h2osoi_vol,        &amp;<a name='2559'>
                               qflx_drain,qflx_surf,qflx_infl,qflx_qrgwl,        &amp;<a name='2560'>
                               qcharge,qflx_prec_grnd,qflx_snowcap,              &amp;<a name='2561'>
                               qflx_snowcap_col,qflx_snow_grnd_pft,              &amp;<a name='2562'>
                               qflx_snow_grnd_col,qflx_rain_grnd,                &amp;<a name='2563'>
                               qflx_evap_tot_col,soilalpha,zwt,fcov,             &amp;<a name='2564'>
                               rootr_column,qflx_evap_grnd,qflx_sub_snow,        &amp;<a name='2565'>
                               qflx_dew_snow,qflx_dew_grnd,qflx_rain_grnd_col)<a name='2566'>
                       <a name='2567'>
<font color=#447700>!==================================================================================<a name='2568'></font>
<font color=#447700>! !DESCRIPTION:<a name='2569'></font>
<font color=#447700>! Calculation of Shallow Lake Hydrology. Full hydrology of snow layers is<a name='2570'></font>
<font color=#447700>! done. However, there is no infiltration, and the water budget is balanced with <a name='2571'></font>
<font color=#447700>! qflx_qrgwl. Lake water mass is kept constant. The soil is simply maintained at<a name='2572'></font>
<font color=#447700>! volumetric saturation if ice melting frees up pore space. Likewise, if the water<a name='2573'></font>
<font color=#447700>! portion alone at some point exceeds pore capacity, it is reduced. This is consistent<a name='2574'></font>
<font color=#447700>! with the possibility of initializing the soil layer with excess ice. The only<a name='2575'></font>
<font color=#447700>! real error with that is that the thermal conductivity will ignore the excess ice<a name='2576'></font>
<font color=#447700>! (and accompanying thickness change).<a name='2577'></font>
<font color=#447700>! <a name='2578'></font>
<font color=#447700>! If snow layers are present over an unfrozen lake, and the top layer of the lake<a name='2579'></font>
<font color=#447700>! is capable of absorbing the latent heat without going below freezing, <a name='2580'></font>
<font color=#447700>! the snow-water is runoff and the latent heat is subtracted from the lake.<a name='2581'></font>
<font color=#447700>!<a name='2582'></font>
<font color=#447700>! WARNING: This subroutine assumes lake columns have one and only one pft.<a name='2583'></font>
<font color=#447700>!<a name='2584'></font>
<font color=#447700>! Sequence is:<a name='2585'></font>
<font color=#447700>!  ShalLakeHydrology:<a name='2586'></font>
<font color=#447700>!    Do needed tasks from Hydrology1, Biogeophysics2, &amp; top of Hydrology2.<a name='2587'></font>
<font color=#447700>!    -&gt; SnowWater:             change of snow mass and snow water onto soil<a name='2588'></font>
<font color=#447700>!    -&gt; SnowCompaction:        compaction of snow layers<a name='2589'></font>
<font color=#447700>!    -&gt; CombineSnowLayers:     combine snow layers that are thinner than minimum<a name='2590'></font>
<font color=#447700>!    -&gt; DivideSnowLayers:      subdivide snow layers that are thicker than maximum<a name='2591'></font>
<font color=#447700>!    Add water to soil if melting has left it with open pore space.<a name='2592'></font>
<font color=#447700>!    Cleanup and do water balance.<a name='2593'></font>
<font color=#447700>!    If snow layers are found above a lake with unfrozen top layer, whose top<a name='2594'></font>
<font color=#447700>!    layer has enough heat to melt all the snow ice without freezing, do so<a name='2595'></font>
<font color=#447700>!    and eliminate the snow layers.<a name='2596'></font>
<font color=#447700>!<a name='2597'></font>
<font color=#447700>! !REVISION HISTORY:<a name='2598'></font>
<font color=#447700>! Created by Zack Subin, 2009<a name='2599'></font>
<font color=#447700>!<a name='2600'></font>
<font color=#447700>!============================================================================================<a name='2601'></font>
<a name='2602'>
<font color=#447700>! USES:<a name='2603'></font>
<font color=#447700>!<a name='2604'></font>
    implicit none<a name='2605'>
<a name='2606'>
<font color=#447700>! in:<a name='2607'></font>
<a name='2608'>
   <font color=#447700>! integer , intent(in) :: clandunit(1)     ! column's landunit<a name='2609'></font>
   <font color=#447700>! integer , intent(in) :: ityplun(1)       ! landunit type<a name='2610'></font>
   <font color=#447700>! real(r8), intent(in) :: watsat(1,1:nlevsoil)      ! volumetric soil water at saturation (porosity)<a name='2611'></font>
    real(r8), intent(in) :: dz_lake(1,nlevlake)     <font color=#447700>! layer thickness for lake (m)<a name='2612'></font>
    real(r8), intent(in) :: forc_rain(1)     <font color=#447700>! rain rate [mm/s]<a name='2613'></font>
    real(r8), intent(in) :: forc_snow(1)     <font color=#447700>! snow rate [mm/s]<a name='2614'></font>
    real(r8), intent(in) :: qflx_evap_tot(1) <font color=#447700>! qflx_evap_soi + qflx_evap_veg + qflx_tran_veg<a name='2615'></font>
    real(r8), intent(in) :: forc_t(1)        <font color=#447700>! atmospheric temperature (Kelvin)<a name='2616'></font>
#if (defined OFFLINE)<a name='2617'>
    real(r8), intent(in) :: flfall(1)        <font color=#447700>! fraction of liquid water within falling precipitation<a name='2618'></font>
#endif<a name='2619'>
    logical , intent(in) :: do_capsnow(1)     <font color=#447700>! true =&gt; do snow capping<a name='2620'></font>
    real(r8), intent(in) :: t_grnd(1)          <font color=#447700>! ground temperature (Kelvin)<a name='2621'></font>
    real(r8), intent(in) :: qflx_evap_soi(1)   <font color=#447700>! soil evaporation (mm H2O/s) (+ = to atm)<a name='2622'></font>
    real(r8), intent(in) :: qflx_snomelt(1)     <font color=#447700>!snow melt (mm H2O /s)<a name='2623'></font>
    integer,  intent(in) :: imelt(1,-nlevsnow+1:nlevsoil)        <font color=#447700>!flag for melting (=1), freezing (=2), Not=0<a name='2624'></font>
<a name='2625'>
<font color=#447700>!inout:<a name='2626'></font>
<a name='2627'>
    real(r8), intent(inout) :: begwb(1)         <font color=#447700>! water mass begining of the time step<a name='2628'></font>
<a name='2629'>
<font color=#447700>! inout: <a name='2630'></font>
<a name='2631'>
    <a name='2632'>
    real(r8), intent(inout) :: z(1,-nlevsnow+1:nlevsoil)           <font color=#447700>! layer depth  (m)<a name='2633'></font>
    real(r8), intent(inout) :: dz(1,-nlevsnow+1:nlevsoil)          <font color=#447700>! layer thickness depth (m)<a name='2634'></font>
    real(r8), intent(inout) :: zi(1,-nlevsnow+0:nlevsoil)          <font color=#447700>! interface depth (m)<a name='2635'></font>
    integer , intent(inout) :: snl(1)           <font color=#447700>! number of snow layers<a name='2636'></font>
    real(r8), intent(inout) :: h2osno(1)        <font color=#447700>! snow water (mm H2O)<a name='2637'></font>
    real(r8), intent(inout) :: snowdp(1)        <font color=#447700>! snow height (m)<a name='2638'></font>
    real(r8), intent(inout) :: lake_icefrac(1,nlevlake)  <font color=#447700>! mass fraction of lake layer that is frozen<a name='2639'></font>
    real(r8), intent(inout) :: t_lake(1,nlevlake)        <font color=#447700>! lake temperature (Kelvin)<a name='2640'></font>
<a name='2641'>
    real(r8), intent(inout) :: frac_iceold(1,-nlevsnow+1:nlevsoil)      <font color=#447700>! fraction of ice relative to the tot water<a name='2642'></font>
<font color=#447700>! out: <a name='2643'></font>
<a name='2644'>
<a name='2645'>
    real(r8), intent(out) :: endwb(1)         <font color=#447700>! water mass end of the time step<a name='2646'></font>
    real(r8), intent(out) :: snowage(1)       <font color=#447700>! non dimensional snow age [-]<a name='2647'></font>
    real(r8), intent(out) :: snowice(1)       <font color=#447700>! average snow ice lens<a name='2648'></font>
    real(r8), intent(out) :: snowliq(1)       <font color=#447700>! average snow liquid water<a name='2649'></font>
    real(r8), intent(out) :: t_snow(1)        <font color=#447700>! vertically averaged snow temperature<a name='2650'></font>
    real(r8), intent(out) :: t_soisno(1,-nlevsnow+1:nlevsoil)    <font color=#447700>! snow temperature (Kelvin)<a name='2651'></font>
    real(r8), intent(out) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! ice lens (kg/m2)<a name='2652'></font>
    real(r8), intent(out) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! liquid water (kg/m2)<a name='2653'></font>
    real(r8), intent(out) :: h2osoi_vol(1,-nlevsnow+1:nlevsoil)  <font color=#447700>! volumetric soil water (0&lt;=h2osoi_vol&lt;=watsat)[m3/m3]<a name='2654'></font>
    real(r8), intent(out) :: qflx_drain(1)    <font color=#447700>! sub-surface runoff (mm H2O /s)<a name='2655'></font>
    real(r8), intent(out) :: qflx_surf(1)     <font color=#447700>! surface runoff (mm H2O /s)<a name='2656'></font>
    real(r8), intent(out) :: qflx_infl(1)     <font color=#447700>! infiltration (mm H2O /s)<a name='2657'></font>
    real(r8), intent(out) :: qflx_qrgwl(1)    <font color=#447700>! qflx_surf at glaciers, wetlands, lakes<a name='2658'></font>
    real(r8), intent(out) :: qcharge(1)       <font color=#447700>! aquifer recharge rate (mm/s)<a name='2659'></font>
    real(r8), intent(out) :: qflx_prec_grnd(1)     <font color=#447700>! water onto ground including canopy runoff [kg/(m2 s)]<a name='2660'></font>
    real(r8), intent(out) :: qflx_snowcap(1)       <font color=#447700>! excess precipitation due to snow capping (mm H2O /s) [+]<a name='2661'></font>
    real(r8), intent(out) :: qflx_snowcap_col(1)   <font color=#447700>! excess precipitation due to snow capping (mm H2O /s) [+]<a name='2662'></font>
    real(r8), intent(out) :: qflx_snow_grnd_pft(1) <font color=#447700>! snow on ground after interception (mm H2O/s) [+]<a name='2663'></font>
    real(r8), intent(out) :: qflx_snow_grnd_col(1) <font color=#447700>! snow on ground after interception (mm H2O/s) [+]<a name='2664'></font>
    real(r8), intent(out) :: qflx_rain_grnd(1)     <font color=#447700>! rain on ground after interception (mm H2O/s) [+]<a name='2665'></font>
    real(r8), intent(out) :: qflx_evap_tot_col(1) <font color=#447700>!pft quantity averaged to the column (assuming one pft)<a name='2666'></font>
    real(r8) ,intent(out) :: soilalpha(1)     <font color=#447700>!factor that reduces ground saturated specific humidity (-)<a name='2667'></font>
    real(r8), intent(out) :: zwt(1)           <font color=#447700>!water table depth<a name='2668'></font>
    real(r8), intent(out) :: fcov(1)          <font color=#447700>!fractional area with water table at surface<a name='2669'></font>
    real(r8), intent(out) :: rootr_column(1,1:nlevsoil) <font color=#447700>!effective fraction of roots in each soil layer<a name='2670'></font>
    real(r8), intent(out) :: qflx_evap_grnd(1)  <font color=#447700>! ground surface evaporation rate (mm H2O/s) [+]<a name='2671'></font>
    real(r8), intent(out) :: qflx_sub_snow(1)   <font color=#447700>! sublimation rate from snow pack (mm H2O /s) [+]<a name='2672'></font>
    real(r8), intent(out) :: qflx_dew_snow(1)   <font color=#447700>! surface dew added to snow pack (mm H2O /s) [+]<a name='2673'></font>
    real(r8), intent(out) :: qflx_dew_grnd(1)   <font color=#447700>! ground surface dew formation (mm H2O /s) [+]<a name='2674'></font>
    real(r8), intent(out) :: qflx_rain_grnd_col(1)   <font color=#447700>!rain on ground after interception (mm H2O/s) [+]<a name='2675'></font>
<a name='2676'>
<font color=#447700>! Block of biogeochem currently not used.<a name='2677'></font>
#ifndef SHLAKE<a name='2678'>
    real(r8), pointer :: sucsat(:,:)      <font color=#447700>! minimum soil suction (mm)<a name='2679'></font>
    real(r8), pointer :: bsw(:,:)         <font color=#447700>! Clapp and Hornberger "b"<a name='2680'></font>
    real(r8), pointer :: bsw2(:,:)        <font color=#447700>! Clapp and Hornberger "b" for CN code<a name='2681'></font>
    real(r8), pointer :: psisat(:,:)      <font color=#447700>! soil water potential at saturation for CN code (MPa)<a name='2682'></font>
    real(r8), pointer :: vwcsat(:,:)      <font color=#447700>! volumetric water content at saturation for CN code (m3/m3)<a name='2683'></font>
    real(r8), pointer :: wf(:)            <font color=#447700>! soil water as frac. of whc for top 0.5 m<a name='2684'></font>
    real(r8), pointer :: soilpsi(:,:)     <font color=#447700>! soil water potential in each soil layer (MPa)<a name='2685'></font>
    real(r8) :: psi,vwc,fsat               <font color=#447700>! temporary variables for soilpsi calculation<a name='2686'></font>
#if (defined DGVM) || (defined CN)<a name='2687'>
    real(r8) :: watdry                     <font color=#447700>! temporary<a name='2688'></font>
    real(r8) :: rwat(lbc:ubc)              <font color=#447700>! soil water wgted by depth to maximum depth of 0.5 m<a name='2689'></font>
    real(r8) :: swat(lbc:ubc)              <font color=#447700>! same as rwat but at saturation<a name='2690'></font>
    real(r8) :: rz(lbc:ubc)                <font color=#447700>! thickness of soil layers contributing to rwat (m)<a name='2691'></font>
    real(r8) :: tsw                        <font color=#447700>! volumetric soil water to 0.5 m<a name='2692'></font>
    real(r8) :: stsw                       <font color=#447700>! volumetric soil water to 0.5 m at saturation<a name='2693'></font>
#endif<a name='2694'>
#endif<a name='2695'>
<a name='2696'>
<a name='2697'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='2698'></font>
<a name='2699'>
    integer  :: p,fp,g,l,c,j,fc,jtop             <font color=#447700>! indices<a name='2700'></font>
    integer  :: num_shlakesnowc                  <font color=#447700>! number of column snow points<a name='2701'></font>
    integer  :: filter_shlakesnowc(ubc-lbc+1)    <font color=#447700>! column filter for snow points<a name='2702'></font>
    integer  :: num_shlakenosnowc                <font color=#447700>! number of column non-snow points<a name='2703'></font>
    integer  :: filter_shlakenosnowc(ubc-lbc+1)  <font color=#447700>! column filter for non-snow points<a name='2704'></font>
<font color=#447700>!    real(r8) :: dtime                      ! land model time step (sec)<a name='2705'></font>
    integer  :: newnode                      <font color=#447700>! flag when new snow node is set, (1=yes, 0=no)<a name='2706'></font>
    real(r8) :: dz_snowf                     <font color=#447700>! layer thickness rate change due to precipitation [mm/s]<a name='2707'></font>
    real(r8) :: bifall                       <font color=#447700>! bulk density of newly fallen dry snow [kg/m3]<a name='2708'></font>
    real(r8) :: fracsnow(lbp:ubp)            <font color=#447700>! frac of precipitation that is snow<a name='2709'></font>
    real(r8) :: fracrain(lbp:ubp)            <font color=#447700>! frac of precipitation that is rain<a name='2710'></font>
    real(r8) :: qflx_prec_grnd_snow(lbp:ubp) <font color=#447700>! snow precipitation incident on ground [mm/s]<a name='2711'></font>
    real(r8) :: qflx_prec_grnd_rain(lbp:ubp) <font color=#447700>! rain precipitation incident on ground [mm/s]<a name='2712'></font>
    real(r8) :: qflx_evap_soi_lim            <font color=#447700>! temporary evap_soi limited by top snow layer content [mm/s]<a name='2713'></font>
    real(r8) :: h2osno_temp                  <font color=#447700>! temporary h2osno [kg/m^2]<a name='2714'></font>
    real(r8), parameter :: snow_bd = 250._r8  <font color=#447700>!constant snow bulk density (only used in special case here) [kg/m^3]<a name='2715'></font>
    real(r8) :: sumsnowice(lbc:ubc)             <font color=#447700>! sum of snow ice if snow layers found above unfrozen lake [kg/m&amp;2]<a name='2716'></font>
    logical  :: unfrozen(lbc:ubc)            <font color=#447700>! true if top lake layer is unfrozen with snow layers above<a name='2717'></font>
    real(r8) :: heatrem                      <font color=#447700>! used in case above [J/m^2]<a name='2718'></font>
    real(r8) :: heatsum(lbc:ubc)             <font color=#447700>! used in case above [J/m^2]<a name='2719'></font>
    real(r8) :: qflx_top_soil(1)     <font color=#447700>!net water input into soil from top (mm/s)<a name='2720'></font>
    character*256 :: message <a name='2721'>
<a name='2722'>
#if (defined LAKEDEBUG)<a name='2723'>
    real(r8) :: snow_water(lbc:ubc)           <font color=#447700>! temporary sum of snow water for Bal Check [kg/m^2]<a name='2724'></font>
#endif<a name='2725'>
<font color=#447700>!-----------------------------------------------------------------------<a name='2726'></font>
<a name='2727'>
<a name='2728'>
    <font color=#447700>! Determine step size<a name='2729'></font>
<a name='2730'>
<font color=#447700>!    dtime = get_step_size()<a name='2731'></font>
<a name='2732'>
    <font color=#447700>! Add soil water to water balance.<a name='2733'></font>
    do j = 1, nlevsoil<a name='2734'>
<font color=#447700>!dir$ concurrent<a name='2735'></font>
<font color=#447700>!cdir nodep<a name='2736'></font>
      do fc = 1, num_shlakec<a name='2737'>
         c = filter_shlakec(fc)<a name='2738'>
         begwb(c) = begwb(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='2739'>
      end do<a name='2740'>
    end do<a name='2741'>
<a name='2742'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='2743'></font>
<a name='2744'>
    <font color=#447700>! Do precipitation onto ground, etc., from Hydrology1.<a name='2745'></font>
<a name='2746'>
<font color=#447700>!dir$ concurrent<a name='2747'></font>
<font color=#447700>!cdir nodep<a name='2748'></font>
    do fp = 1, num_shlakep<a name='2749'>
       p = filter_shlakep(fp)<a name='2750'>
       g = pgridcell(p)<a name='2751'>
<font color=#447700>!       l = plandunit(p)<a name='2752'></font>
       c = pcolumn(p)<a name='2753'>
<a name='2754'>
       <font color=#447700>! Precipitation onto ground (kg/(m2 s))<a name='2755'></font>
<font color=#447700>!       ! PET, 1/18/2005: Added new terms for mass balance correction<a name='2756'></font>
<font color=#447700>!       ! due to dynamic pft weight shifting (column-level h2ocan_loss)<a name='2757'></font>
<font color=#447700>!       ! Because the fractionation between rain and snow is indeterminate if<a name='2758'></font>
<font color=#447700>!       ! rain + snow = 0, I am adding this very small flux only to the rain<a name='2759'></font>
<font color=#447700>!       ! components.<a name='2760'></font>
       <font color=#447700>! Not relevant unless PFTs are added to lake later.<a name='2761'></font>
<font color=#447700>!       if (frac_veg_nosno(p) == 0) then<a name='2762'></font>
          qflx_prec_grnd_snow(p) = forc_snow(g)<a name='2763'>
          qflx_prec_grnd_rain(p) = forc_rain(g) <font color=#447700>!+ h2ocan_loss(c)<a name='2764'></font>
<font color=#447700>!       else<a name='2765'></font>
<font color=#447700>!          qflx_prec_grnd_snow(p) = qflx_through_snow(p) + (qflx_candrip(p) * fracsnow(p))<a name='2766'></font>
<font color=#447700>!          qflx_prec_grnd_rain(p) = qflx_through_rain(p) + (qflx_candrip(p) * fracrain(p)) + h2ocan_loss(c)<a name='2767'></font>
<font color=#447700>!       end if<a name='2768'></font>
       qflx_prec_grnd(p) = qflx_prec_grnd_snow(p) + qflx_prec_grnd_rain(p)<a name='2769'>
<a name='2770'>
       if (do_capsnow(c)) then<a name='2771'>
          qflx_snowcap(p) = qflx_prec_grnd_snow(p) + qflx_prec_grnd_rain(p)<a name='2772'>
          qflx_snow_grnd_pft(p) = 0._r8<a name='2773'>
          qflx_rain_grnd(p) = 0._r8<a name='2774'>
       else<a name='2775'>
          qflx_snowcap(p) = 0._r8<a name='2776'>
#if (defined OFFLINE)<a name='2777'>
          qflx_snow_grnd_pft(p) = qflx_prec_grnd(p)*(1._r8-flfall(g)) <font color=#447700>! ice onto ground (mm/s)<a name='2778'></font>
          qflx_rain_grnd(p)     = qflx_prec_grnd(p)*flfall(g)      <font color=#447700>! liquid water onto ground (mm/s)<a name='2779'></font>
#else<a name='2780'>
          qflx_snow_grnd_pft(p) = qflx_prec_grnd_snow(p)           <font color=#447700>! ice onto ground (mm/s)<a name='2781'></font>
          qflx_rain_grnd(p)     = qflx_prec_grnd_rain(p)           <font color=#447700>! liquid water onto ground (mm/s)<a name='2782'></font>
#endif<a name='2783'>
       end if<a name='2784'>
       <font color=#447700>! Assuming one PFT; needed for below<a name='2785'></font>
       qflx_snow_grnd_col(c) = qflx_snow_grnd_pft(p)<a name='2786'>
       qflx_rain_grnd_col(c) = qflx_rain_grnd(p)<a name='2787'>
<a name='2788'>
    end do <font color=#447700>! (end pft loop)<a name='2789'></font>
<a name='2790'>
    <font color=#447700>! Determine snow height and snow water<a name='2791'></font>
<a name='2792'>
<font color=#447700>!dir$ concurrent<a name='2793'></font>
<font color=#447700>!cdir nodep<a name='2794'></font>
    do fc = 1, num_shlakec<a name='2795'>
       c = filter_shlakec(fc)<a name='2796'>
<font color=#447700>!       l = clandunit(c)<a name='2797'></font>
       g = cgridcell(c)<a name='2798'>
<a name='2799'>
       <font color=#447700>! Use Alta relationship, Anderson(1976); LaChapelle(1961),<a name='2800'></font>
       <font color=#447700>! U.S.Department of Agriculture Forest Service, Project F,<a name='2801'></font>
       <font color=#447700>! Progress Rep. 1, Alta Avalanche Study Center:Snow Layer Densification.<a name='2802'></font>
<a name='2803'>
       if (do_capsnow(c)) then<a name='2804'>
          dz_snowf = 0._r8<a name='2805'>
       else<a name='2806'>
          if (forc_t(g) &gt; tfrz + 2._r8) then<a name='2807'>
             bifall=50._r8 + 1.7_r8*(17.0_r8)**1.5_r8<a name='2808'>
          else if (forc_t(g) &gt; tfrz - 15._r8) then<a name='2809'>
             bifall=50._r8 + 1.7_r8*(forc_t(g) - tfrz + 15._r8)**1.5_r8<a name='2810'>
          else<a name='2811'>
             bifall=50._r8<a name='2812'>
          end if<a name='2813'>
          dz_snowf = qflx_snow_grnd_col(c)/bifall<a name='2814'>
          snowdp(c) = snowdp(c) + dz_snowf*dtime<a name='2815'>
          h2osno(c) = h2osno(c) + qflx_snow_grnd_col(c)*dtime  <font color=#447700>! snow water equivalent (mm)<a name='2816'></font>
       end if<a name='2817'>
<a name='2818'>
<font color=#447700>!       if (itype(l)==istwet .and. t_grnd(c)&gt;tfrz) then<a name='2819'></font>
<font color=#447700>!          h2osno(c)=0._r8<a name='2820'></font>
<font color=#447700>!          snowdp(c)=0._r8<a name='2821'></font>
<font color=#447700>!          snowage(c)=0._r8<a name='2822'></font>
<font color=#447700>!       end if<a name='2823'></font>
       <font color=#447700>! Take care of this later in function.<a name='2824'></font>
<a name='2825'>
       <font color=#447700>! When the snow accumulation exceeds 10 mm, initialize snow layer<a name='2826'></font>
       <font color=#447700>! Currently, the water temperature for the precipitation is simply set<a name='2827'></font>
       <font color=#447700>! as the surface air temperature<a name='2828'></font>
<a name='2829'>
       newnode = 0    <font color=#447700>! flag for when snow node will be initialized<a name='2830'></font>
       if (snl(c) == 0 .and. qflx_snow_grnd_col(c) &gt; 0.0_r8 .and. snowdp(c) &gt;= 0.01_r8) then<a name='2831'>
          newnode = 1<a name='2832'>
          snl(c) = -1<a name='2833'>
          dz(c,0) = snowdp(c)                       <font color=#447700>! meter<a name='2834'></font>
          z(c,0) = -0.5_r8*dz(c,0)<a name='2835'>
          zi(c,-1) = -dz(c,0)<a name='2836'>
          snowage(c) = 0._r8                        <font color=#447700>! snow age<a name='2837'></font>
          t_soisno(c,0) = min(tfrz, forc_t(g))      <font color=#447700>! K<a name='2838'></font>
          h2osoi_ice(c,0) = h2osno(c)               <font color=#447700>! kg/m2<a name='2839'></font>
          h2osoi_liq(c,0) = 0._r8                   <font color=#447700>! kg/m2<a name='2840'></font>
          frac_iceold(c,0) = 1._r8<a name='2841'>
       end if<a name='2842'>
<a name='2843'>
       <font color=#447700>! The change of ice partial density of surface node due to precipitation.<a name='2844'></font>
       <font color=#447700>! Only ice part of snowfall is added here, the liquid part will be added<a name='2845'></font>
       <font color=#447700>! later.<a name='2846'></font>
<a name='2847'>
       if (snl(c) &lt; 0 .and. newnode == 0) then<a name='2848'>
          h2osoi_ice(c,snl(c)+1) = h2osoi_ice(c,snl(c)+1)+dtime*qflx_snow_grnd_col(c)<a name='2849'>
          dz(c,snl(c)+1) = dz(c,snl(c)+1)+dz_snowf*dtime<a name='2850'>
       end if<a name='2851'>
<a name='2852'>
    end do<a name='2853'>
<a name='2854'>
    <font color=#447700>! Calculate sublimation and dew, adapted from HydrologyLake and Biogeophysics2.<a name='2855'></font>
<a name='2856'>
<font color=#447700>!dir$ concurrent<a name='2857'></font>
<font color=#447700>!cdir nodep<a name='2858'></font>
    do fp = 1,num_shlakep<a name='2859'>
       p = filter_shlakep(fp)<a name='2860'>
       c = pcolumn(p)<a name='2861'>
       jtop = snl(c)+1<a name='2862'>
<a name='2863'>
       <font color=#447700>! Use column variables here<a name='2864'></font>
       qflx_evap_grnd(c) = 0._r8<a name='2865'>
       qflx_sub_snow(c) = 0._r8<a name='2866'>
       qflx_dew_snow(c) = 0._r8<a name='2867'>
       qflx_dew_grnd(c) = 0._r8<a name='2868'>
<a name='2869'>
       if (jtop &lt;= 0) then <font color=#447700>! snow layers<a name='2870'></font>
          j = jtop<a name='2871'>
          <font color=#447700>! Assign ground evaporation to sublimation from soil ice or to dew<a name='2872'></font>
          <font color=#447700>! on snow or ground<a name='2873'></font>
<a name='2874'>
          if (qflx_evap_soi(p) &gt;= 0._r8) then<a name='2875'>
          <font color=#447700>! for evaporation partitioning between liquid evap and ice sublimation, <a name='2876'></font>
          <font color=#447700>! use the ratio of liquid to (liquid+ice) in the top layer to determine split<a name='2877'></font>
          <font color=#447700>! Since we're not limiting evap over lakes, but still can't remove more from top<a name='2878'></font>
          <font color=#447700>! snow layer than there is there, create temp. limited evap_soi.<a name='2879'></font>
             qflx_evap_soi_lim = min(qflx_evap_soi(p), (h2osoi_liq(c,j)+h2osoi_ice(c,j))/dtime)<a name='2880'>
             if ((h2osoi_liq(c,j)+h2osoi_ice(c,j)) &gt; 0._r8) then<a name='2881'>
                qflx_evap_grnd(c) = max(qflx_evap_soi_lim*(h2osoi_liq(c,j)/(h2osoi_liq(c,j)+h2osoi_ice(c,j))), 0._r8)<a name='2882'>
             else<a name='2883'>
                qflx_evap_grnd(c) = 0._r8<a name='2884'>
             end if<a name='2885'>
             qflx_sub_snow(c) = qflx_evap_soi_lim - qflx_evap_grnd(c)     <a name='2886'>
          else<a name='2887'>
             if (t_grnd(c) &lt; tfrz) then<a name='2888'>
                qflx_dew_snow(c) = abs(qflx_evap_soi(p))<a name='2889'>
             else<a name='2890'>
                qflx_dew_grnd(c) = abs(qflx_evap_soi(p))<a name='2891'>
             end if<a name='2892'>
          end if<a name='2893'>
          <font color=#447700>! Update the pft-level qflx_snowcap<a name='2894'></font>
          <font color=#447700>! This was moved in from Hydrology2 to keep all pft-level<a name='2895'></font>
          <font color=#447700>! calculations out of Hydrology2<a name='2896'></font>
          if (do_capsnow(c)) qflx_snowcap(p) = qflx_snowcap(p) + qflx_dew_snow(c) + qflx_dew_grnd(c)<a name='2897'>
<a name='2898'>
       else <font color=#447700>! No snow layers: do as in HydrologyLake but with actual clmtype variables<a name='2899'></font>
          if (qflx_evap_soi(p) &gt;= 0._r8) then<a name='2900'>
             <font color=#447700>! Sublimation: do not allow for more sublimation than there is snow<a name='2901'></font>
             <font color=#447700>! after melt.  Remaining surface evaporation used for infiltration.<a name='2902'></font>
             qflx_sub_snow(c) = min(qflx_evap_soi(p), h2osno(c)/dtime)<a name='2903'>
             qflx_evap_grnd(c) = qflx_evap_soi(p) - qflx_sub_snow(c)<a name='2904'>
          else<a name='2905'>
             if (t_grnd(c) &lt; tfrz-0.1_r8) then<a name='2906'>
                qflx_dew_snow(c) = abs(qflx_evap_soi(p))<a name='2907'>
             else<a name='2908'>
                qflx_dew_grnd(c) = abs(qflx_evap_soi(p))<a name='2909'>
             end if<a name='2910'>
          end if<a name='2911'>
<a name='2912'>
          <font color=#447700>! Update snow pack for dew &amp; sub.<a name='2913'></font>
          h2osno_temp = h2osno(c)<a name='2914'>
          if (do_capsnow(c)) then<a name='2915'>
             h2osno(c) = h2osno(c) - qflx_sub_snow(c)*dtime<a name='2916'>
             qflx_snowcap(p) = qflx_snowcap(p) + qflx_dew_snow(c) + qflx_dew_grnd(c)<a name='2917'>
          else<a name='2918'>
             h2osno(c) = h2osno(c) + (-qflx_sub_snow(c)+qflx_dew_snow(c))*dtime<a name='2919'>
          end if<a name='2920'>
          if (h2osno_temp &gt; 0._r8) then<a name='2921'>
             snowdp(c) = snowdp(c) * h2osno(c) / h2osno_temp<a name='2922'>
          else<a name='2923'>
             snowdp(c) = h2osno(c)/snow_bd <font color=#447700>!Assume a constant snow bulk density = 250.<a name='2924'></font>
          end if<a name='2925'>
<a name='2926'>
#if (defined PERGRO)<a name='2927'>
          if (abs(h2osno(c)) &lt; 1.e-10_r8) h2osno(c) = 0._r8<a name='2928'>
#else<a name='2929'>
          h2osno(c) = max(h2osno(c), 0._r8)<a name='2930'>
#endif<a name='2931'>
<a name='2932'>
       end if<a name='2933'>
<a name='2934'>
    qflx_snowcap_col(c) = qflx_snowcap(p)<a name='2935'>
<a name='2936'>
    end do<a name='2937'>
<a name='2938'>
<a name='2939'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='2940'></font>
    <font color=#447700>! Determine initial snow/no-snow filters (will be modified possibly by<a name='2941'></font>
    <font color=#447700>! routines CombineSnowLayers and DivideSnowLayers below<a name='2942'></font>
<a name='2943'>
    call <A href='../../html_code/phys/module_sf_lake.F.html#BUILDSNOWFILTER'>BuildSnowFilter</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="BUILDSNOWFILTER_3">(lbc, ubc, num_shlakec, filter_shlakec,snl,       &amp;            <font color=#447700>!i<a name='2944'></font>
         num_shlakesnowc, filter_shlakesnowc, num_shlakenosnowc, filter_shlakenosnowc) <font color=#447700>!o<a name='2945'></font>
<a name='2946'>
    <font color=#447700>! Determine the change of snow mass and the snow water onto soil<a name='2947'></font>
<a name='2948'>
    call <A href='../../html_code/phys/module_sf_noahmplsm.F.html#SNOWWATER'>SnowWater</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SNOWWATER_2">(lbc, ubc, num_shlakesnowc, filter_shlakesnowc,         &amp; <font color=#447700>!i <a name='2949'></font>
                   num_shlakenosnowc, filter_shlakenosnowc,               &amp; <font color=#447700>!i <a name='2950'></font>
                   snl,do_capsnow,qflx_snomelt,qflx_rain_grnd,            &amp; <font color=#447700>!i <a name='2951'></font>
                   qflx_sub_snow,qflx_evap_grnd,                          &amp; <font color=#447700>!i   <a name='2952'></font>
                   qflx_dew_snow,qflx_dew_grnd,dz,                        &amp; <font color=#447700>!i   <a name='2953'></font>
                   h2osoi_ice,h2osoi_liq,                                 &amp; <font color=#447700>!i&amp;o <a name='2954'></font>
                   qflx_top_soil)                                           <font color=#447700>!o                        <a name='2955'></font>
<a name='2956'>
<a name='2957'>
    <font color=#447700>! Determine soil hydrology<a name='2958'></font>
    <font color=#447700>! Here this consists only of making sure that soil is saturated even as it melts and 10%<a name='2959'></font>
    <font color=#447700>! of pore space opens up. Conversely, if excess ice is melting and the liquid water exceeds the<a name='2960'></font>
    <font color=#447700>! saturation value, then remove water.<a name='2961'></font>
<a name='2962'>
    do j = 1,nlevsoil<a name='2963'>
<font color=#447700>!dir$ concurrent<a name='2964'></font>
<font color=#447700>!cdir nodep<a name='2965'></font>
       do fc = 1, num_shlakec<a name='2966'>
          c = filter_shlakec(fc)<a name='2967'>
<a name='2968'>
          if (h2osoi_vol(c,j) &lt; watsat(c,j)) then<a name='2969'>
             h2osoi_liq(c,j) = (watsat(c,j)*dz(c,j) - h2osoi_ice(c,j)/denice)*denh2o<a name='2970'>
          <font color=#447700>! h2osoi_vol will be updated below, and this water addition will come from qflx_qrgwl<a name='2971'></font>
          else if (h2osoi_liq(c,j) &gt; watsat(c,j)*denh2o*dz(c,j)) then<a name='2972'>
             h2osoi_liq(c,j) = watsat(c,j)*denh2o*dz(c,j)<a name='2973'>
          end if<a name='2974'>
<a name='2975'>
       end do<a name='2976'>
    end do<a name='2977'>
<font color=#447700>!!!!!!!!!!<a name='2978'></font>
<a name='2979'>
<font color=#447700>!    if (.not. is_perpetual()) then<a name='2980'></font>
    if (1==1) then<a name='2981'>
<a name='2982'>
       <font color=#447700>! Natural compaction and metamorphosis.<a name='2983'></font>
<a name='2984'>
       call <A href='../../html_code/phys/module_sf_lake.F.html#SNOWCOMPACTION'>SnowCompaction</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SNOWCOMPACTION_2">(lbc, ubc, num_shlakesnowc, filter_shlakesnowc,   &amp;<font color=#447700>!i<a name='2985'></font>
                           snl,imelt,frac_iceold,t_soisno,                  &amp;<font color=#447700>!i<a name='2986'></font>
                           h2osoi_ice,h2osoi_liq,                           &amp;<font color=#447700>!i<a name='2987'></font>
                           dz)                                               <font color=#447700>!&amp;o<a name='2988'></font>
<a name='2989'>
       <font color=#447700>! Combine thin snow elements<a name='2990'></font>
<a name='2991'>
       call <A href='../../html_code/phys/module_sf_lake.F.html#COMBINESNOWLAYERS'>CombineSnowLayers</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMBINESNOWLAYERS_2">(lbc, ubc,                            &amp; <font color=#447700>!i<a name='2992'></font>
                              num_shlakesnowc, filter_shlakesnowc, &amp; <font color=#447700>!i&amp;o<a name='2993'></font>
                              snl,h2osno,snowdp,dz,zi,             &amp; <font color=#447700>!i&amp;o<a name='2994'></font>
                              t_soisno,h2osoi_ice,h2osoi_liq,      &amp; <font color=#447700>!i&amp;o<a name='2995'></font>
                              z)  <font color=#447700>!o                              <a name='2996'></font>
<a name='2997'>
<a name='2998'>
       <font color=#447700>! Divide thick snow elements<a name='2999'></font>
<a name='3000'>
       call <A href='../../html_code/phys/module_sf_lake.F.html#DIVIDESNOWLAYERS'>DivideSnowLayers</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="DIVIDESNOWLAYERS_2">(lbc, ubc,                             &amp; <font color=#447700>!i<a name='3001'></font>
                             num_shlakesnowc, filter_shlakesnowc,  &amp; <font color=#447700>!i&amp;o<a name='3002'></font>
                             snl,dz,zi,t_soisno,                   &amp; <font color=#447700>!i&amp;o<a name='3003'></font>
                             h2osoi_ice,h2osoi_liq,                &amp; <font color=#447700>!i&amp;o<a name='3004'></font>
                             z)  <font color=#447700>!o<a name='3005'></font>
<a name='3006'>
<a name='3007'>
    else<a name='3008'>
<a name='3009'>
       do fc = 1, num_shlakesnowc<a name='3010'>
          c = filter_shlakesnowc(fc)<a name='3011'>
          h2osno(c) = 0._r8<a name='3012'>
       end do<a name='3013'>
       do j = -nlevsnow+1,0<a name='3014'>
          do fc = 1, num_shlakesnowc<a name='3015'>
             c = filter_shlakesnowc(fc)<a name='3016'>
             if (j &gt;= snl(c)+1) then<a name='3017'>
                h2osno(c) = h2osno(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='3018'>
             end if<a name='3019'>
          end do<a name='3020'>
       end do<a name='3021'>
<a name='3022'>
    end if<a name='3023'>
<a name='3024'>
    <font color=#447700>! Check for snow layers above lake with unfrozen top layer.  Mechanically,<a name='3025'></font>
    <font color=#447700>! the snow will fall into the lake and melt or turn to ice.  If the top layer has<a name='3026'></font>
    <font color=#447700>! sufficient heat to melt the snow without freezing, then that will be done.<a name='3027'></font>
    <font color=#447700>! Otherwise, the top layer will undergo freezing, but only if the top layer will<a name='3028'></font>
    <font color=#447700>! not freeze completely.  Otherwise, let the snow layers persist and melt by diffusion.<a name='3029'></font>
<font color=#447700>!dir$ concurrent<a name='3030'></font>
<font color=#447700>!cdir nodep<a name='3031'></font>
       do fc = 1, num_shlakec<a name='3032'>
          c = filter_shlakec(fc)<a name='3033'>
<a name='3034'>
          if (t_lake(c,1) &gt; tfrz .and. lake_icefrac(c,1) == 0._r8 .and. snl(c) &lt; 0) then<a name='3035'>
             unfrozen(c) = .true.<a name='3036'>
          else<a name='3037'>
             unfrozen(c) = .false.<a name='3038'>
          end if<a name='3039'>
       end do<a name='3040'>
<a name='3041'>
    do j = -nlevsnow+1,0<a name='3042'>
<font color=#447700>!dir$ concurrent<a name='3043'></font>
<font color=#447700>!cdir nodep<a name='3044'></font>
       do fc = 1, num_shlakec<a name='3045'>
          c = filter_shlakec(fc)<a name='3046'>
<a name='3047'>
          if (unfrozen(c)) then<a name='3048'>
             if (j == -nlevsnow+1) then<a name='3049'>
                sumsnowice(c) = 0._r8<a name='3050'>
                heatsum(c) = 0._r8<a name='3051'>
             end if<a name='3052'>
             if (j &gt;= snl(c)+1) then<a name='3053'>
                sumsnowice(c) = sumsnowice(c) + h2osoi_ice(c,j)<a name='3054'>
                heatsum(c) = heatsum(c) + h2osoi_ice(c,j)*cpice*(tfrz - t_soisno(c,j)) &amp;<a name='3055'>
                           + h2osoi_liq(c,j)*cpliq*(tfrz - t_soisno(c,j))<a name='3056'>
             end if<a name='3057'>
          end if<a name='3058'>
       end do<a name='3059'>
    end do<a name='3060'>
<a name='3061'>
<font color=#447700>!dir$ concurrent<a name='3062'></font>
<font color=#447700>!cdir nodep<a name='3063'></font>
       do fc = 1, num_shlakec<a name='3064'>
          c = filter_shlakec(fc)<a name='3065'>
<a name='3066'>
          if (unfrozen(c)) then<a name='3067'>
             heatsum(c) = heatsum(c) + sumsnowice(c)*hfus<a name='3068'>
             heatrem = (t_lake(c,1) - tfrz)*cpliq*denh2o*dz_lake(c,1) - heatsum(c)<a name='3069'>
<a name='3070'>
             if (heatrem + denh2o*dz_lake(c,1)*hfus &gt; 0._r8) then            <a name='3071'>
                <font color=#447700>! Remove snow and subtract the latent heat from the top layer.<a name='3072'></font>
                h2osno(c) = 0._r8<a name='3073'>
                snl(c) = 0<a name='3074'>
                <font color=#447700>! The rest of the bookkeeping for the removed snow will be done below.<a name='3075'></font>
#if (defined LAKEDEBUG)<a name='3076'>
                write(message,*)'Snow layers removed above unfrozen lake for column, snowice:', &amp;<a name='3077'>
                          c, sumsnowice(c)<a name='3078'>
                CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_905">(message)<a name='3079'>
#endif<a name='3080'>
                if (heatrem &gt; 0._r8) then <font color=#447700>! simply subtract the heat from the layer<a name='3081'></font>
                   t_lake(c,1) = t_lake(c,1) - heatrem/(cpliq*denh2o*dz_lake(c,1))<a name='3082'>
                else <font color=#447700>!freeze part of the layer<a name='3083'></font>
                   t_lake(c,1) = tfrz<a name='3084'>
                   lake_icefrac(c,1) = -heatrem/(denh2o*dz_lake(c,1)*hfus)<a name='3085'>
                end if<a name='3086'>
             end if<a name='3087'>
          end if<a name='3088'>
       end do<a name='3089'>
<font color=#447700>!!!!!!!!!!!!<a name='3090'></font>
<a name='3091'>
    <font color=#447700>! Set snow age to zero if no snow<a name='3092'></font>
<a name='3093'>
<font color=#447700>!dir$ concurrent<a name='3094'></font>
<font color=#447700>!cdir nodep<a name='3095'></font>
    do fc = 1, num_shlakesnowc<a name='3096'>
       c = filter_shlakesnowc(fc)<a name='3097'>
       if (snl(c) == 0) then<a name='3098'>
          snowage(c) = 0._r8<a name='3099'>
       end if<a name='3100'>
    end do<a name='3101'>
<a name='3102'>
    <font color=#447700>! Set empty snow layers to zero<a name='3103'></font>
<a name='3104'>
    do j = -nlevsnow+1,0<a name='3105'>
<font color=#447700>!dir$ concurrent<a name='3106'></font>
<font color=#447700>!cdir nodep<a name='3107'></font>
       do fc = 1, num_shlakesnowc<a name='3108'>
          c = filter_shlakesnowc(fc)<a name='3109'>
          if (j &lt;= snl(c) .and. snl(c) &gt; -nlevsnow) then<a name='3110'>
             h2osoi_ice(c,j) = 0._r8<a name='3111'>
             h2osoi_liq(c,j) = 0._r8<a name='3112'>
             t_soisno(c,j) = 0._r8<a name='3113'>
             dz(c,j) = 0._r8<a name='3114'>
             z(c,j) = 0._r8<a name='3115'>
             zi(c,j-1) = 0._r8<a name='3116'>
          end if<a name='3117'>
       end do<a name='3118'>
    end do<a name='3119'>
<a name='3120'>
    <font color=#447700>! Build new snow filter<a name='3121'></font>
<a name='3122'>
    call <A href='../../html_code/phys/module_sf_lake.F.html#BUILDSNOWFILTER'>BuildSnowFilter</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="BUILDSNOWFILTER_4">(lbc, ubc, num_shlakec, filter_shlakec, snl,&amp;   <font color=#447700>!i<a name='3123'></font>
         num_shlakesnowc, filter_shlakesnowc, num_shlakenosnowc, filter_shlakenosnowc) <font color=#447700>!o<a name='3124'></font>
<a name='3125'>
    <font color=#447700>! Vertically average t_soisno and sum of h2osoi_liq and h2osoi_ice<a name='3126'></font>
    <font color=#447700>! over all snow layers for history output<a name='3127'></font>
<a name='3128'>
<font color=#447700>!dir$ concurrent<a name='3129'></font>
<font color=#447700>!cdir nodep<a name='3130'></font>
    do fc = 1, num_shlakesnowc<a name='3131'>
       c = filter_shlakesnowc(fc)<a name='3132'>
       t_snow(c)  = 0._r8<a name='3133'>
       snowice(c) = 0._r8<a name='3134'>
       snowliq(c) = 0._r8<a name='3135'>
    end do<a name='3136'>
<font color=#447700>!dir$ concurrent<a name='3137'></font>
<font color=#447700>!cdir nodep<a name='3138'></font>
    do fc = 1, num_shlakenosnowc<a name='3139'>
       c = filter_shlakenosnowc(fc)<a name='3140'>
       t_snow(c)  = spval<a name='3141'>
       snowice(c) = spval<a name='3142'>
       snowliq(c) = spval<a name='3143'>
    end do<a name='3144'>
<a name='3145'>
    do j = -nlevsnow+1, 0<a name='3146'>
<font color=#447700>!dir$ concurrent<a name='3147'></font>
<font color=#447700>!cdir nodep<a name='3148'></font>
       do fc = 1, num_shlakesnowc<a name='3149'>
          c = filter_shlakesnowc(fc)<a name='3150'>
          if (j &gt;= snl(c)+1) then<a name='3151'>
             t_snow(c)  = t_snow(c) + t_soisno(c,j)<a name='3152'>
             snowice(c) = snowice(c) + h2osoi_ice(c,j)<a name='3153'>
             snowliq(c) = snowliq(c) + h2osoi_liq(c,j)<a name='3154'>
          end if<a name='3155'>
       end do<a name='3156'>
    end do<a name='3157'>
<a name='3158'>
    <font color=#447700>! Determine ending water balance and volumetric soil water<a name='3159'></font>
<a name='3160'>
<font color=#447700>!dir$ concurrent<a name='3161'></font>
<font color=#447700>!cdir nodep<a name='3162'></font>
    do fc = 1, num_shlakec<a name='3163'>
       <a name='3164'>
       c = filter_shlakec(fc)<a name='3165'>
       if (snl(c) &lt; 0) t_snow(c) = t_snow(c)/abs(snl(c))<a name='3166'>
       endwb(c) = h2osno(c)<a name='3167'>
    end do<a name='3168'>
<a name='3169'>
    do j = 1, nlevsoil<a name='3170'>
<font color=#447700>!dir$ concurrent<a name='3171'></font>
<font color=#447700>!cdir nodep<a name='3172'></font>
       do fc = 1, num_shlakec<a name='3173'>
          c = filter_shlakec(fc)<a name='3174'>
          endwb(c) = endwb(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='3175'>
          h2osoi_vol(c,j) = h2osoi_liq(c,j)/(dz(c,j)*denh2o) + h2osoi_ice(c,j)/(dz(c,j)*denice)<a name='3176'>
       end do<a name='3177'>
    end do<a name='3178'>
<a name='3179'>
#if (defined LAKEDEBUG)<a name='3180'>
    <font color=#447700>! Check to make sure snow water adds up correctly.<a name='3181'></font>
    do j = -nlevsnow+1,0<a name='3182'>
<font color=#447700>!dir$ concurrent<a name='3183'></font>
<font color=#447700>!cdir nodep<a name='3184'></font>
      do fc = 1, num_shlakec<a name='3185'>
         c = filter_shlakec(fc)<a name='3186'>
 <a name='3187'>
         jtop = snl(c)+1<a name='3188'>
         if(j == jtop) snow_water(c) = 0._r8<a name='3189'>
         if(j &gt;= jtop) then<a name='3190'>
            snow_water(c) = snow_water(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='3191'>
            if(j == 0 .and. abs(snow_water(c)-h2osno(c))&gt;1.e-7_r8) then<a name='3192'>
               write(message,*)'h2osno does not equal sum of snow layers in ShalLakeHydrology:', &amp;<a name='3193'>
                         'column, h2osno, sum of snow layers =', c, h2osno(c), snow_water(c)<a name='3194'>
               CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1147"> ( message )<a name='3195'>
            end if<a name='3196'>
         end if<a name='3197'>
      end do<a name='3198'>
    end do<a name='3199'>
#endif<a name='3200'>
<a name='3201'>
<font color=#447700>!!!!!!!!!!!!!<a name='3202'></font>
    <font color=#447700>! Do history variables and set special landunit runoff (adapted from end of HydrologyLake)<a name='3203'></font>
<font color=#447700>!dir$ concurrent<a name='3204'></font>
<font color=#447700>!cdir nodep<a name='3205'></font>
    do fp = 1,num_shlakep<a name='3206'>
       p = filter_shlakep(fp)<a name='3207'>
       c = pcolumn(p)<a name='3208'>
       g = pgridcell(p)<a name='3209'>
<a name='3210'>
       qflx_infl(c)      = 0._r8<a name='3211'>
       qflx_surf(c)      = 0._r8<a name='3212'>
       qflx_drain(c)     = 0._r8<a name='3213'>
       rootr_column(c,:) = spval<a name='3214'>
       soilalpha(c)      = spval<a name='3215'>
       zwt(c)            = spval<a name='3216'>
       fcov(c)           = spval<a name='3217'>
       qcharge(c)        = spval<a name='3218'>
<font color=#447700>!       h2osoi_vol(c,:)   = spval<a name='3219'></font>
<a name='3220'>
       <font color=#447700>! Insure water balance using qflx_qrgwl<a name='3221'></font>
       qflx_qrgwl(c)     = forc_rain(g) + forc_snow(g) - qflx_evap_tot(p) - (endwb(c)-begwb(c))/dtime<a name='3222'>
#if (defined LAKEDEBUG)<a name='3223'>
    write(message,*)'c, rain, snow, evap, endwb, begwb, qflx_qrgwl:', &amp;<a name='3224'>
       c, forc_rain(g), forc_snow(g), qflx_evap_tot(p), endwb(c), begwb(c), qflx_qrgwl(c)<a name='3225'>
    CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#SHALLAKEHYDROLOGY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_906">(message)<a name='3226'>
#endif<a name='3227'>
<a name='3228'>
       <font color=#447700>! The pft average must be done here for output to history tape<a name='3229'></font>
       qflx_evap_tot_col(c) = qflx_evap_tot(p)<a name='3230'>
    end do<a name='3231'>
<a name='3232'>
<font color=#447700>!!!!!!!!!!!!!<a name='3233'></font>
<font color=#447700>!For now, bracket off the remaining biogeochem code.  May need to bring it back<a name='3234'></font>
<font color=#447700>!to do soil carbon and methane beneath lakes.<a name='3235'></font>
#if (defined CN)<a name='3236'>
#ifndef SHLAKE<a name='3237'>
    do j = 1, nlevsoil<a name='3238'>
<font color=#447700>!dir$ concurrent<a name='3239'></font>
<font color=#447700>!cdir nodep<a name='3240'></font>
       do fc = 1, num_soilc<a name='3241'>
          c = filter_soilc(fc)<a name='3242'>
          <a name='3243'>
          if (h2osoi_liq(c,j) &gt; 0._r8) then<a name='3244'>
             vwc = h2osoi_liq(c,j)/(dz(c,j)*denh2o)<a name='3245'>
            <a name='3246'>
             <font color=#447700>! the following limit set to catch very small values of <a name='3247'></font>
             <font color=#447700>! fractional saturation that can crash the calculation of psi<a name='3248'></font>
           <a name='3249'>
             fsat = max(vwc/vwcsat(c,j), 0.001_r8)<a name='3250'>
             psi = psisat(c,j) * (fsat)**bsw2(c,j)<a name='3251'>
             soilpsi(c,j) = min(max(psi,-15.0_r8),0._r8)<a name='3252'>
          else <a name='3253'>
             soilpsi(c,j) = -15.0_r8<a name='3254'>
          end if<a name='3255'>
       end do<a name='3256'>
    end do<a name='3257'>
#endif<a name='3258'>
#endif<a name='3259'>
<a name='3260'>
#if (defined DGVM) || (defined CN)<a name='3261'>
#ifndef SHLAKE<a name='3262'>
    <font color=#447700>! Available soil water up to a depth of 0.5 m.<a name='3263'></font>
    <font color=#447700>! Potentially available soil water (=whc) up to a depth of 0.5 m.<a name='3264'></font>
    <font color=#447700>! Water content as fraction of whc up to a depth of 0.5 m.<a name='3265'></font>
<a name='3266'>
<font color=#447700>!dir$ concurrent<a name='3267'></font>
<font color=#447700>!cdir nodep<a name='3268'></font>
    do c = lbc,ubc<a name='3269'>
       l = clandunit(c)<a name='3270'>
       if (ityplun(l) == istsoil) then<a name='3271'>
          rwat(c) = 0._r8<a name='3272'>
          swat(c) = 0._r8<a name='3273'>
          rz(c)   = 0._r8<a name='3274'>
       end if<a name='3275'>
    end do<a name='3276'>
<a name='3277'>
    do j = 1, nlevsoil<a name='3278'>
<font color=#447700>!dir$ concurrent<a name='3279'></font>
<font color=#447700>!cdir nodep<a name='3280'></font>
       do c = lbc,ubc<a name='3281'>
          l = clandunit(c)<a name='3282'>
          if (ityplun(l) == istsoil) then<a name='3283'>
             if (z(c,j)+0.5_r8*dz(c,j) &lt;= 0.5_r8) then<a name='3284'>
                watdry = watsat(c,j) * (316230._r8/sucsat(c,j)) ** (-1._r8/bsw(c,j))<a name='3285'>
                rwat(c) = rwat(c) + (h2osoi_vol(c,j)-watdry) * dz(c,j)<a name='3286'>
                swat(c) = swat(c) + (watsat(c,j)    -watdry) * dz(c,j)<a name='3287'>
                rz(c) = rz(c) + dz(c,j)<a name='3288'>
             end if<a name='3289'>
          end if<a name='3290'>
       end do<a name='3291'>
    end do<a name='3292'>
<a name='3293'>
<font color=#447700>!dir$ concurrent<a name='3294'></font>
<font color=#447700>!cdir nodep<a name='3295'></font>
    do c = lbc,ubc<a name='3296'>
       l = clandunit(c)<a name='3297'>
       if (ityplun(l) == istsoil) then<a name='3298'>
          if (rz(c) /= 0._r8) then<a name='3299'>
             tsw  = rwat(c)/rz(c)<a name='3300'>
             stsw = swat(c)/rz(c)<a name='3301'>
          else<a name='3302'>
             watdry = watsat(c,1) * (316230._r8/sucsat(c,1)) ** (-1._r8/bsw(c,1))<a name='3303'>
             tsw = h2osoi_vol(c,1) - watdry<a name='3304'>
             stsw = watsat(c,1) - watdry<a name='3305'>
          end if<a name='3306'>
          wf(c) = tsw/stsw<a name='3307'>
       else<a name='3308'>
          wf(c) = 1.0_r8<a name='3309'>
       end if<a name='3310'>
    end do<a name='3311'>
<a name='3312'>
#endif<a name='3313'>
#endif<a name='3314'>
<a name='3315'>
  end subroutine ShalLakeHydrology<a name='3316'>
<a name='3317'>
<A NAME='QSAT'><A href='../../html_code/phys/module_sf_lake.F.html#QSAT' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3318'>
  <font color=#993300>subroutine </font><font color=#cc0000>QSat</font> (T, p, es, esdT, qs, qsdT) <A href='../../call_to/QSAT.html' TARGET='index'>29</A>,<A href='../../call_from/QSAT.html' TARGET='index'>3</A><a name='3319'>
<font color=#447700>!<a name='3320'></font>
<font color=#447700>! !DESCRIPTION:<a name='3321'></font>
<font color=#447700>! Computes saturation mixing ratio and the change in saturation<a name='3322'></font>
<font color=#447700>! mixing ratio with respect to temperature.<a name='3323'></font>
<font color=#447700>! Reference:  Polynomial approximations from:<a name='3324'></font>
<font color=#447700>!             Piotr J. Flatau, et al.,1992:  Polynomial fits to saturation<a name='3325'></font>
<font color=#447700>!             vapor pressure.  Journal of Applied Meteorology, 31, 1507-1513.<a name='3326'></font>
<font color=#447700>!<a name='3327'></font>
<font color=#447700>! !USES:<a name='3328'></font>
<font color=#447700>!<a name='3329'></font>
<font color=#447700>! !ARGUMENTS:<a name='3330'></font>
    implicit none<a name='3331'>
    real(r8), intent(in)  :: T        <font color=#447700>! temperature (K)<a name='3332'></font>
    real(r8), intent(in)  :: p        <font color=#447700>! surface atmospheric pressure (pa)<a name='3333'></font>
    real(r8), intent(out) :: es       <font color=#447700>! vapor pressure (pa)<a name='3334'></font>
    real(r8), intent(out) :: esdT     <font color=#447700>! d(es)/d(T)<a name='3335'></font>
    real(r8), intent(out) :: qs       <font color=#447700>! humidity (kg/kg)<a name='3336'></font>
    real(r8), intent(out) :: qsdT     <font color=#447700>! d(qs)/d(T)<a name='3337'></font>
<font color=#447700>!<a name='3338'></font>
<font color=#447700>! !CALLED FROM:<a name='3339'></font>
<font color=#447700>! subroutine Biogeophysics1 in module Biogeophysics1Mod<a name='3340'></font>
<font color=#447700>! subroutine BiogeophysicsLake in module BiogeophysicsLakeMod<a name='3341'></font>
<font color=#447700>! subroutine CanopyFluxesMod CanopyFluxesMod<a name='3342'></font>
<font color=#447700>!<a name='3343'></font>
<font color=#447700>! !REVISION HISTORY:<a name='3344'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='3345'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='3346'></font>
<font color=#447700>!<a name='3347'></font>
<font color=#447700>!EOP<a name='3348'></font>
<font color=#447700>!<a name='3349'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='3350'></font>
<font color=#447700>!<a name='3351'></font>
    real(r8) :: T_limit<a name='3352'>
    real(r8) :: td,vp,vp1,vp2<a name='3353'>
<font color=#447700>!<a name='3354'></font>
<font color=#447700>! For water vapor (temperature range 0C-100C)<a name='3355'></font>
<font color=#447700>!<a name='3356'></font>
    real(r8), parameter :: a0 =  6.11213476<a name='3357'>
    real(r8), parameter :: a1 =  0.444007856<a name='3358'>
    real(r8), parameter :: a2 =  0.143064234e-01<a name='3359'>
    real(r8), parameter :: a3 =  0.264461437e-03<a name='3360'>
    real(r8), parameter :: a4 =  0.305903558e-05<a name='3361'>
    real(r8), parameter :: a5 =  0.196237241e-07<a name='3362'>
    real(r8), parameter :: a6 =  0.892344772e-10<a name='3363'>
    real(r8), parameter :: a7 = -0.373208410e-12<a name='3364'>
    real(r8), parameter :: a8 =  0.209339997e-15<a name='3365'>
<font color=#447700>!<a name='3366'></font>
<font color=#447700>! For derivative:water vapor<a name='3367'></font>
<font color=#447700>!<a name='3368'></font>
    real(r8), parameter :: b0 =  0.444017302<a name='3369'>
    real(r8), parameter :: b1 =  0.286064092e-01<a name='3370'>
    real(r8), parameter :: b2 =  0.794683137e-03<a name='3371'>
    real(r8), parameter :: b3 =  0.121211669e-04<a name='3372'>
    real(r8), parameter :: b4 =  0.103354611e-06<a name='3373'>
    real(r8), parameter :: b5 =  0.404125005e-09<a name='3374'>
    real(r8), parameter :: b6 = -0.788037859e-12<a name='3375'>
    real(r8), parameter :: b7 = -0.114596802e-13<a name='3376'>
    real(r8), parameter :: b8 =  0.381294516e-16<a name='3377'>
<font color=#447700>!<a name='3378'></font>
<font color=#447700>! For ice (temperature range -75C-0C)<a name='3379'></font>
<font color=#447700>!<a name='3380'></font>
    real(r8), parameter :: c0 =  6.11123516<a name='3381'>
    real(r8), parameter :: c1 =  0.503109514<a name='3382'>
    real(r8), parameter :: c2 =  0.188369801e-01<a name='3383'>
    real(r8), parameter :: c3 =  0.420547422e-03<a name='3384'>
    real(r8), parameter :: c4 =  0.614396778e-05<a name='3385'>
    real(r8), parameter :: c5 =  0.602780717e-07<a name='3386'>
    real(r8), parameter :: c6 =  0.387940929e-09<a name='3387'>
    real(r8), parameter :: c7 =  0.149436277e-11<a name='3388'>
    real(r8), parameter :: c8 =  0.262655803e-14<a name='3389'>
<font color=#447700>!<a name='3390'></font>
<font color=#447700>! For derivative:ice<a name='3391'></font>
<font color=#447700>!<a name='3392'></font>
    real(r8), parameter :: d0 =  0.503277922<a name='3393'>
    real(r8), parameter :: d1 =  0.377289173e-01<a name='3394'>
    real(r8), parameter :: d2 =  0.126801703e-02<a name='3395'>
    real(r8), parameter :: d3 =  0.249468427e-04<a name='3396'>
    real(r8), parameter :: d4 =  0.313703411e-06<a name='3397'>
    real(r8), parameter :: d5 =  0.257180651e-08<a name='3398'>
    real(r8), parameter :: d6 =  0.133268878e-10<a name='3399'>
    real(r8), parameter :: d7 =  0.394116744e-13<a name='3400'>
    real(r8), parameter :: d8 =  0.498070196e-16<a name='3401'>
<font color=#447700>!-----------------------------------------------------------------------<a name='3402'></font>
<a name='3403'>
    T_limit = T - tfrz<a name='3404'>
    if (T_limit &gt; 100.0) T_limit=100.0<a name='3405'>
    if (T_limit &lt; -75.0) T_limit=-75.0<a name='3406'>
<a name='3407'>
    td       = T_limit<a name='3408'>
    if (td &gt;= 0.0) then<a name='3409'>
       es   = a0 + td*(a1 + td*(a2 + td*(a3 + td*(a4 &amp;<a name='3410'>
            + td*(a5 + td*(a6 + td*(a7 + td*a8)))))))<a name='3411'>
       esdT = b0 + td*(b1 + td*(b2 + td*(b3 + td*(b4 &amp;<a name='3412'>
            + td*(b5 + td*(b6 + td*(b7 + td*b8)))))))<a name='3413'>
    else<a name='3414'>
       es   = c0 + td*(c1 + td*(c2 + td*(c3 + td*(c4 &amp;<a name='3415'>
            + td*(c5 + td*(c6 + td*(c7 + td*c8)))))))<a name='3416'>
       esdT = d0 + td*(d1 + td*(d2 + td*(d3 + td*(d4 &amp;<a name='3417'>
            + td*(d5 + td*(d6 + td*(d7 + td*d8)))))))<a name='3418'>
    endif<a name='3419'>
<a name='3420'>
    es    = es    * 100.            <font color=#447700>! pa<a name='3421'></font>
    esdT  = esdT  * 100.            <font color=#447700>! pa/K<a name='3422'></font>
<a name='3423'>
    vp    = 1.0   / (p - 0.378*es)<a name='3424'>
    vp1   = 0.622 * vp<a name='3425'>
    vp2   = vp1   * vp<a name='3426'>
<a name='3427'>
    qs    = es    * vp1             <font color=#447700>! kg/kg<a name='3428'></font>
    qsdT  = esdT  * vp2 * p         <font color=#447700>! 1 / K<a name='3429'></font>
<a name='3430'>
  end subroutine QSat<a name='3431'>
<a name='3432'>
<a name='3433'>
<A NAME='TRIDIAGONAL'><A href='../../html_code/phys/module_sf_lake.F.html#TRIDIAGONAL' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3434'>
  <font color=#993300>subroutine </font><font color=#cc0000>Tridiagonal</font> (lbc, ubc, lbj, ubj, jtop, numf, filter, &amp; <A href='../../call_to/TRIDIAGONAL.html' TARGET='index'>4</A>,<A href='../../call_from/TRIDIAGONAL.html' TARGET='index'>1</A><a name='3435'>
                          a, b, c, r, u)<a name='3436'>
<font color=#447700>!<a name='3437'></font>
<font color=#447700>! !DESCRIPTION:<a name='3438'></font>
<font color=#447700>! Tridiagonal matrix solution<a name='3439'></font>
<font color=#447700>!<a name='3440'></font>
<font color=#447700>! !USES:<a name='3441'></font>
  <font color=#447700>!  use shr_kind_mod, only: r8 =&gt; shr_kind_r8<a name='3442'></font>
<font color=#447700>!<a name='3443'></font>
<font color=#447700>! !ARGUMENTS:<a name='3444'></font>
    implicit none<a name='3445'>
    integer , intent(in)    :: lbc, ubc               <font color=#447700>! lbinning and ubing column indices<a name='3446'></font>
    integer , intent(in)    :: lbj, ubj               <font color=#447700>! lbinning and ubing level indices<a name='3447'></font>
    integer , intent(in)    :: jtop(lbc:ubc)          <font color=#447700>! top level for each column<a name='3448'></font>
    integer , intent(in)    :: numf                   <font color=#447700>! filter dimension<a name='3449'></font>
    integer , intent(in)    :: filter(1:numf)         <font color=#447700>! filter<a name='3450'></font>
    real(r8), intent(in)    :: a(lbc:ubc, lbj:ubj)    <font color=#447700>! "a" left off diagonal of tridiagonal matrix<a name='3451'></font>
    real(r8), intent(in)    :: b(lbc:ubc, lbj:ubj)    <font color=#447700>! "b" diagonal column for tridiagonal matrix<a name='3452'></font>
    real(r8), intent(in)    :: c(lbc:ubc, lbj:ubj)    <font color=#447700>! "c" right off diagonal tridiagonal matrix<a name='3453'></font>
    real(r8), intent(in)    :: r(lbc:ubc, lbj:ubj)    <font color=#447700>! "r" forcing term of tridiagonal matrix<a name='3454'></font>
    real(r8), intent(inout) :: u(lbc:ubc, lbj:ubj)    <font color=#447700>! solution<a name='3455'></font>
<font color=#447700>!<a name='3456'></font>
<font color=#447700>! !CALLED FROM:<a name='3457'></font>
<font color=#447700>! subroutine BiogeophysicsLake in module BiogeophysicsLakeMod<a name='3458'></font>
<font color=#447700>! subroutine SoilTemperature in module SoilTemperatureMod<a name='3459'></font>
<font color=#447700>! subroutine SoilWater in module HydrologyMod<a name='3460'></font>
<font color=#447700>!<a name='3461'></font>
<font color=#447700>! !REVISION HISTORY:<a name='3462'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='3463'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='3464'></font>
<font color=#447700>!  1 July 2003: Mariana Vertenstein; modified for vectorization<a name='3465'></font>
<font color=#447700>!<a name='3466'></font>
<font color=#447700>!EOP<a name='3467'></font>
<font color=#447700>!<a name='3468'></font>
<font color=#447700>! !OTHER LOCAL VARIABLES:<a name='3469'></font>
<font color=#447700>!<a name='3470'></font>
    integer  :: j,ci,fc                   <font color=#447700>!indices<a name='3471'></font>
    real(r8) :: gam(lbc:ubc,lbj:ubj)      <font color=#447700>!temporary<a name='3472'></font>
    real(r8) :: bet(lbc:ubc)              <font color=#447700>!temporary<a name='3473'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='3474'></font>
<a name='3475'>
    <font color=#447700>! Solve the matrix<a name='3476'></font>
<a name='3477'>
<font color=#447700>!dir$ concurrent<a name='3478'></font>
<font color=#447700>!cdir nodep<a name='3479'></font>
    do fc = 1,numf<a name='3480'>
       ci = filter(fc)<a name='3481'>
       bet(ci) = b(ci,jtop(ci))<a name='3482'>
    end do<a name='3483'>
<a name='3484'>
    do j = lbj, ubj<a name='3485'>
<font color=#447700>!dir$ prefervector<a name='3486'></font>
<font color=#447700>!dir$ concurrent<a name='3487'></font>
<font color=#447700>!cdir nodep<a name='3488'></font>
       do fc = 1,numf<a name='3489'>
          ci = filter(fc)<a name='3490'>
          if (j &gt;= jtop(ci)) then<a name='3491'>
             if (j == jtop(ci)) then<a name='3492'>
                u(ci,j) = r(ci,j) / bet(ci)<a name='3493'>
             else<a name='3494'>
                gam(ci,j) = c(ci,j-1) / bet(ci)<a name='3495'>
                bet(ci) = b(ci,j) - a(ci,j) * gam(ci,j)<a name='3496'>
                u(ci,j) = (r(ci,j) - a(ci,j)*u(ci,j-1)) / bet(ci)<a name='3497'>
             end if<a name='3498'>
          end if<a name='3499'>
       end do<a name='3500'>
    end do<a name='3501'>
<a name='3502'>
<font color=#447700>!Cray X1 unroll directive used here as work-around for compiler issue 2003/10/20<a name='3503'></font>
<font color=#447700>!dir$ unroll 0<a name='3504'></font>
    do j = ubj-1,lbj,-1<a name='3505'>
<font color=#447700>!dir$ prefervector<a name='3506'></font>
<font color=#447700>!dir$ concurrent<a name='3507'></font>
<font color=#447700>!cdir nodep<a name='3508'></font>
       do fc = 1,numf<a name='3509'>
          ci = filter(fc)<a name='3510'>
          if (j &gt;= jtop(ci)) then<a name='3511'>
             u(ci,j) = u(ci,j) - gam(ci,j+1) * u(ci,j+1)<a name='3512'>
          end if<a name='3513'>
       end do<a name='3514'>
    end do<a name='3515'>
<a name='3516'>
  end subroutine Tridiagonal<a name='3517'>
<a name='3518'>
<a name='3519'>
<A NAME='SNOWWATER'><A href='../../html_code/phys/module_sf_lake.F.html#SNOWWATER' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3520'>
  <font color=#993300>subroutine </font><font color=#cc0000>SnowWater</font>(lbc, ubc, num_snowc, filter_snowc,         &amp; <font color=#447700>!i <A href='../../call_to/SNOWWATER.html' TARGET='index'>3</A>,<A href='../../call_from/SNOWWATER.html' TARGET='index'>9</A><a name='3521'></font>
                   num_nosnowc, filter_nosnowc,               &amp; <font color=#447700>!i <a name='3522'></font>
                   snl,do_capsnow,qflx_snomelt,qflx_rain_grnd,            &amp; <font color=#447700>!i<a name='3523'></font>
                   qflx_sub_snow,qflx_evap_grnd,                          &amp; <font color=#447700>!i   <a name='3524'></font>
                   qflx_dew_snow,qflx_dew_grnd,dz,                        &amp; <font color=#447700>!i   <a name='3525'></font>
                   h2osoi_ice,h2osoi_liq,                                 &amp; <font color=#447700>!i&amp;o <a name='3526'></font>
                   qflx_top_soil)                                           <font color=#447700>!o                        <a name='3527'></font>
<font color=#447700>!===============================================================================<a name='3528'></font>
<font color=#447700>! !DESCRIPTION:<a name='3529'></font>
<font color=#447700>! Evaluate the change of snow mass and the snow water onto soil.<a name='3530'></font>
<font color=#447700>! Water flow within snow is computed by an explicit and non-physical<a name='3531'></font>
<font color=#447700>! based scheme, which permits a part of liquid water over the holding<a name='3532'></font>
<font color=#447700>! capacity (a tentative value is used, i.e. equal to 0.033*porosity) to<a name='3533'></font>
<font color=#447700>! percolate into the underlying layer.  Except for cases where the<a name='3534'></font>
<font color=#447700>! porosity of one of the two neighboring layers is less than 0.05, zero<a name='3535'></font>
<font color=#447700>! flow is assumed. The water flow out of the bottom of the snow pack will<a name='3536'></font>
<font color=#447700>! participate as the input of the soil water and runoff.  This subroutine<a name='3537'></font>
<font color=#447700>! uses a filter for columns containing snow which must be constructed prior<a name='3538'></font>
<font color=#447700>! to being called.<a name='3539'></font>
<font color=#447700>!<a name='3540'></font>
<font color=#447700>! !REVISION HISTORY:<a name='3541'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='3542'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='3543'></font>
<font color=#447700>! 15 November 2000: Mariana Vertenstein<a name='3544'></font>
<font color=#447700>! 2/26/02, Peter Thornton: Migrated to new data structures.<a name='3545'></font>
<font color=#447700>!=============================================================================<a name='3546'></font>
<font color=#447700>! !USES:<a name='3547'></font>
  <font color=#447700>!  use clmtype<a name='3548'></font>
<a name='3549'>
    implicit none<a name='3550'>
<a name='3551'>
<font color=#447700>!in:<a name='3552'></font>
    integer, intent(in) :: lbc, ubc                    <font color=#447700>! column bounds<a name='3553'></font>
    integer, intent(in) :: num_snowc                   <font color=#447700>! number of snow points in column filter<a name='3554'></font>
    integer, intent(in) :: filter_snowc(ubc-lbc+1)     <font color=#447700>! column filter for snow points<a name='3555'></font>
    integer, intent(in) :: num_nosnowc                 <font color=#447700>! number of non-snow points in column filter<a name='3556'></font>
    integer, intent(in) :: filter_nosnowc(ubc-lbc+1)   <font color=#447700>! column filter for non-snow points<a name='3557'></font>
<a name='3558'>
    integer , intent(in) :: snl(1)              <font color=#447700>!number of snow layers<a name='3559'></font>
    logical , intent(in) :: do_capsnow(1)       <font color=#447700>!true =&gt; do snow capping<a name='3560'></font>
    real(r8), intent(in) :: qflx_snomelt(1)     <font color=#447700>!snow melt (mm H2O /s)<a name='3561'></font>
    real(r8), intent(in) :: qflx_rain_grnd(1)   <font color=#447700>!rain on ground after interception (mm H2O/s) [+]<a name='3562'></font>
    real(r8), intent(in) :: qflx_sub_snow(1)    <font color=#447700>!sublimation rate from snow pack (mm H2O /s) [+]<a name='3563'></font>
    real(r8), intent(in) :: qflx_evap_grnd(1)   <font color=#447700>!ground surface evaporation rate (mm H2O/s) [+]<a name='3564'></font>
    real(r8), intent(in) :: qflx_dew_snow(1)    <font color=#447700>!surface dew added to snow pack (mm H2O /s) [+]<a name='3565'></font>
    real(r8), intent(in) :: qflx_dew_grnd(1)    <font color=#447700>!ground surface dew formation (mm H2O /s) [+]<a name='3566'></font>
    real(r8), intent(in) :: dz(1,-nlevsnow+1:nlevsoil)             <font color=#447700>!layer depth (m)<a name='3567'></font>
<a name='3568'>
<a name='3569'>
<font color=#447700>!inout: <a name='3570'></font>
<a name='3571'>
    real(r8), intent(inout) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)     <font color=#447700>!ice lens (kg/m2)<a name='3572'></font>
    real(r8), intent(inout) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)     <font color=#447700>!liquid water (kg/m2)<a name='3573'></font>
<a name='3574'>
<font color=#447700>!out:<a name='3575'></font>
<a name='3576'>
    real(r8), intent(out) :: qflx_top_soil(1)     <font color=#447700>!net water input into soil from top (mm/s)<a name='3577'></font>
<a name='3578'>
<a name='3579'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='3580'></font>
<a name='3581'>
    integer  :: c, j, fc                           <font color=#447700>!do loop/array indices<a name='3582'></font>
    real(r8) :: qin(lbc:ubc)                       <font color=#447700>!water flow into the elmement (mm/s)<a name='3583'></font>
    real(r8) :: qout(lbc:ubc)                      <font color=#447700>!water flow out of the elmement (mm/s)<a name='3584'></font>
    real(r8) :: wgdif                              <font color=#447700>!ice mass after minus sublimation<a name='3585'></font>
    real(r8) :: vol_liq(lbc:ubc,-nlevsnow+1:0)      <font color=#447700>!partial volume of liquid water in layer<a name='3586'></font>
    real(r8) :: vol_ice(lbc:ubc,-nlevsnow+1:0)      <font color=#447700>!partial volume of ice lens in layer<a name='3587'></font>
    real(r8) :: eff_porosity(lbc:ubc,-nlevsnow+1:0) <font color=#447700>!effective porosity = porosity - vol_ice<a name='3588'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='3589'></font>
    <font color=#447700>! Renew the mass of ice lens (h2osoi_ice) and liquid (h2osoi_liq) in the<a name='3590'></font>
    <font color=#447700>! surface snow layer resulting from sublimation (frost) / evaporation (condense)<a name='3591'></font>
<a name='3592'>
<font color=#447700>!dir$ concurrent<a name='3593'></font>
<font color=#447700>!cdir nodep<a name='3594'></font>
    do fc = 1,num_snowc<a name='3595'>
       c = filter_snowc(fc)<a name='3596'>
       if (do_capsnow(c)) then<a name='3597'>
          wgdif = h2osoi_ice(c,snl(c)+1) - qflx_sub_snow(c)*dtime<a name='3598'>
          h2osoi_ice(c,snl(c)+1) = wgdif<a name='3599'>
          if (wgdif &lt; 0.) then<a name='3600'>
             h2osoi_ice(c,snl(c)+1) = 0.<a name='3601'>
             h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) + wgdif<a name='3602'>
          end if<a name='3603'>
          h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) - qflx_evap_grnd(c) * dtime<a name='3604'>
       else<a name='3605'>
          wgdif = h2osoi_ice(c,snl(c)+1) + (qflx_dew_snow(c) - qflx_sub_snow(c)) * dtime<a name='3606'>
          h2osoi_ice(c,snl(c)+1) = wgdif<a name='3607'>
          if (wgdif &lt; 0.) then<a name='3608'>
             h2osoi_ice(c,snl(c)+1) = 0.<a name='3609'>
             h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) + wgdif<a name='3610'>
          end if<a name='3611'>
          h2osoi_liq(c,snl(c)+1) = h2osoi_liq(c,snl(c)+1) +  &amp;<a name='3612'>
               (qflx_rain_grnd(c) + qflx_dew_grnd(c) - qflx_evap_grnd(c)) * dtime<a name='3613'>
       end if<a name='3614'>
       h2osoi_liq(c,snl(c)+1) = max(0._r8, h2osoi_liq(c,snl(c)+1))<a name='3615'>
    end do<a name='3616'>
<a name='3617'>
    <font color=#447700>! Porosity and partial volume<a name='3618'></font>
<a name='3619'>
    do j = -nlevsnow+1, 0<a name='3620'>
<font color=#447700>!dir$ concurrent<a name='3621'></font>
<font color=#447700>!cdir nodep<a name='3622'></font>
       do fc = 1, num_snowc<a name='3623'>
          c = filter_snowc(fc)<a name='3624'>
          if (j &gt;= snl(c)+1) then<a name='3625'>
             vol_ice(c,j) = min(1._r8, h2osoi_ice(c,j)/(dz(c,j)*denice))<a name='3626'>
             eff_porosity(c,j) = 1. - vol_ice(c,j)<a name='3627'>
             vol_liq(c,j) = min(eff_porosity(c,j),h2osoi_liq(c,j)/(dz(c,j)*denh2o))<a name='3628'>
          end if<a name='3629'>
       end do<a name='3630'>
    end do<a name='3631'>
<a name='3632'>
    <font color=#447700>! Capillary forces within snow are usually two or more orders of magnitude<a name='3633'></font>
    <font color=#447700>! less than those of gravity. Only gravity terms are considered.<a name='3634'></font>
    <font color=#447700>! the genernal expression for water flow is "K * ss**3", however,<a name='3635'></font>
    <font color=#447700>! no effective parameterization for "K".  Thus, a very simple consideration<a name='3636'></font>
    <font color=#447700>! (not physically based) is introduced:<a name='3637'></font>
    <font color=#447700>! when the liquid water of layer exceeds the layer's holding<a name='3638'></font>
    <font color=#447700>! capacity, the excess meltwater adds to the underlying neighbor layer.<a name='3639'></font>
<a name='3640'>
    qin(:) = 0._r8<a name='3641'>
<a name='3642'>
    do j = -nlevsnow+1, 0<a name='3643'>
<font color=#447700>!dir$ concurrent<a name='3644'></font>
<font color=#447700>!cdir nodep<a name='3645'></font>
       do fc = 1, num_snowc<a name='3646'>
          c = filter_snowc(fc)<a name='3647'>
          if (j &gt;= snl(c)+1) then<a name='3648'>
             h2osoi_liq(c,j) = h2osoi_liq(c,j) + qin(c)<a name='3649'>
             if (j &lt;= -1) then<a name='3650'>
                <font color=#447700>! No runoff over snow surface, just ponding on surface<a name='3651'></font>
                if (eff_porosity(c,j) &lt; wimp .OR. eff_porosity(c,j+1) &lt; wimp) then<a name='3652'>
                   qout(c) = 0._r8<a name='3653'>
                else<a name='3654'>
                   qout(c) = max(0._r8,(vol_liq(c,j)-ssi*eff_porosity(c,j))*dz(c,j))<a name='3655'>
                   qout(c) = min(qout(c),(1.-vol_ice(c,j+1)-vol_liq(c,j+1))*dz(c,j+1))<a name='3656'>
                end if<a name='3657'>
             else<a name='3658'>
                qout(c) = max(0._r8,(vol_liq(c,j) - ssi*eff_porosity(c,j))*dz(c,j))<a name='3659'>
             end if<a name='3660'>
             qout(c) = qout(c)*1000.<a name='3661'>
             h2osoi_liq(c,j) = h2osoi_liq(c,j) - qout(c)<a name='3662'>
             qin(c) = qout(c)<a name='3663'>
          end if<a name='3664'>
       end do<a name='3665'>
    end do<a name='3666'>
<a name='3667'>
<font color=#447700>!dir$ concurrent<a name='3668'></font>
<font color=#447700>!cdir nodep<a name='3669'></font>
    do fc = 1, num_snowc<a name='3670'>
       c = filter_snowc(fc)<a name='3671'>
       <font color=#447700>! Qout from snow bottom<a name='3672'></font>
       qflx_top_soil(c) = qout(c) / dtime<a name='3673'>
    end do<a name='3674'>
<a name='3675'>
<font color=#447700>!dir$ concurrent<a name='3676'></font>
<font color=#447700>!cdir nodep<a name='3677'></font>
    do fc = 1, num_nosnowc<a name='3678'>
       c = filter_nosnowc(fc)<a name='3679'>
       qflx_top_soil(c) = qflx_rain_grnd(c) + qflx_snomelt(c)<a name='3680'>
    end do<a name='3681'>
<a name='3682'>
  end subroutine SnowWater<a name='3683'>
<a name='3684'>
<A NAME='SNOWCOMPACTION'><A href='../../html_code/phys/module_sf_lake.F.html#SNOWCOMPACTION' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3685'>
  <font color=#993300>subroutine </font><font color=#cc0000>SnowCompaction</font>(lbc, ubc, num_snowc, filter_snowc,   &amp;<font color=#447700>!i   <A href='../../call_to/SNOWCOMPACTION.html' TARGET='index'>2</A>,<A href='../../call_from/SNOWCOMPACTION.html' TARGET='index'>3</A><a name='3686'></font>
                           snl,imelt,frac_iceold,t_soisno,                  &amp;<font color=#447700>!i  <a name='3687'></font>
                           h2osoi_ice,h2osoi_liq,                           &amp;<font color=#447700>!i  <a name='3688'></font>
                           dz)                                               <font color=#447700>!i&amp;o   <a name='3689'></font>
<a name='3690'>
<a name='3691'>
<font color=#447700>!================================================================================<a name='3692'></font>
<font color=#447700>! !DESCRIPTION:<a name='3693'></font>
<font color=#447700>! Determine the change in snow layer thickness due to compaction and<a name='3694'></font>
<font color=#447700>! settling.<a name='3695'></font>
<font color=#447700>! Three metamorphisms of changing snow characteristics are implemented,<a name='3696'></font>
<font color=#447700>! i.e., destructive, overburden, and melt. The treatments of the former<a name='3697'></font>
<font color=#447700>! two are from SNTHERM.89 and SNTHERM.99 (1991, 1999). The contribution<a name='3698'></font>
<font color=#447700>! due to melt metamorphism is simply taken as a ratio of snow ice<a name='3699'></font>
<font color=#447700>! fraction after the melting versus before the melting.<a name='3700'></font>
<font color=#447700>!<a name='3701'></font>
<font color=#447700>! CALLED FROM:<a name='3702'></font>
<font color=#447700>! subroutine Hydrology2 in module Hydrology2Mod<a name='3703'></font>
<font color=#447700>!<a name='3704'></font>
<font color=#447700>! REVISION HISTORY:<a name='3705'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='3706'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='3707'></font>
<font color=#447700>! 2/28/02, Peter Thornton: Migrated to new data structures<a name='3708'></font>
<font color=#447700>!==============================================================================<a name='3709'></font>
<font color=#447700>! USES:<a name='3710'></font>
  <font color=#447700>!  use clmtype<a name='3711'></font>
<font color=#447700>!<a name='3712'></font>
<font color=#447700>! !ARGUMENTS:<a name='3713'></font>
    implicit none<a name='3714'>
<a name='3715'>
<font color=#447700>!in:<a name='3716'></font>
    integer, intent(in) :: lbc, ubc                <font color=#447700>! column bounds<a name='3717'></font>
    integer, intent(in) :: num_snowc               <font color=#447700>! number of column snow points in column filter<a name='3718'></font>
    integer, intent(in) :: filter_snowc(ubc-lbc+1) <font color=#447700>! column filter for snow points<a name='3719'></font>
    integer,  intent(in) :: snl(1)             <font color=#447700>!number of snow layers<a name='3720'></font>
    integer,  intent(in) :: imelt(1,-nlevsnow+1:nlevsoil)        <font color=#447700>!flag for melting (=1), freezing (=2), Not=0<a name='3721'></font>
    real(r8), intent(in) :: frac_iceold(1,-nlevsnow+1:nlevsoil)  <font color=#447700>!fraction of ice relative to the tot water<a name='3722'></font>
    real(r8), intent(in) :: t_soisno(1,-nlevsnow+1:nlevsoil)     <font color=#447700>!soil temperature (Kelvin)<a name='3723'></font>
    real(r8), intent(in) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!ice lens (kg/m2)<a name='3724'></font>
    real(r8), intent(in) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!liquid water (kg/m2)<a name='3725'></font>
<a name='3726'>
<font color=#447700>!inout:<a name='3727'></font>
<a name='3728'>
    real(r8), intent(inout) :: dz(1,-nlevsnow+1:nlevsoil)           <font color=#447700>!layer depth (m)<a name='3729'></font>
<a name='3730'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='3731'></font>
<a name='3732'>
    integer :: j, c, fc                   <font color=#447700>! indices<a name='3733'></font>
    real(r8), parameter :: c2 = 23.e-3    <font color=#447700>! [m3/kg]<a name='3734'></font>
    real(r8), parameter :: c3 = 2.777e-6  <font color=#447700>! [1/s]<a name='3735'></font>
    real(r8), parameter :: c4 = 0.04      <font color=#447700>! [1/K]<a name='3736'></font>
    real(r8), parameter :: c5 = 2.0       <font color=#447700>!<a name='3737'></font>
    real(r8), parameter :: dm = 100.0     <font color=#447700>! Upper Limit on Destructive Metamorphism Compaction [kg/m3]<a name='3738'></font>
    real(r8), parameter :: eta0 = 9.e+5   <font color=#447700>! The Viscosity Coefficient Eta0 [kg-s/m2]<a name='3739'></font>
    real(r8) :: burden(lbc:ubc) <font color=#447700>! pressure of overlying snow [kg/m2]<a name='3740'></font>
    real(r8) :: ddz1   <font color=#447700>! Rate of settling of snowpack due to destructive metamorphism.<a name='3741'></font>
    real(r8) :: ddz2   <font color=#447700>! Rate of compaction of snowpack due to overburden.<a name='3742'></font>
    real(r8) :: ddz3   <font color=#447700>! Rate of compaction of snowpack due to melt [1/s]<a name='3743'></font>
    real(r8) :: dexpf  <font color=#447700>! expf=exp(-c4*(273.15-t_soisno)).<a name='3744'></font>
    real(r8) :: fi     <font color=#447700>! Fraction of ice relative to the total water content at current time step<a name='3745'></font>
    real(r8) :: td     <font color=#447700>! t_soisno - tfrz [K]<a name='3746'></font>
    real(r8) :: pdzdtc <font color=#447700>! Nodal rate of change in fractional-thickness due to compaction [fraction/s]<a name='3747'></font>
    real(r8) :: void   <font color=#447700>! void (1 - vol_ice - vol_liq)<a name='3748'></font>
    real(r8) :: wx     <font color=#447700>! water mass (ice+liquid) [kg/m2]<a name='3749'></font>
    real(r8) :: bi     <font color=#447700>! partial density of ice [kg/m3]<a name='3750'></font>
<a name='3751'>
<font color=#447700>!-----------------------------------------------------------------------<a name='3752'></font>
<a name='3753'>
<a name='3754'>
    <font color=#447700>! Begin calculation - note that the following column loops are only invoked if snl(c) &lt; 0<a name='3755'></font>
<a name='3756'>
    burden(:) = 0._r8<a name='3757'>
<a name='3758'>
    do j = -nlevsnow+1, 0<a name='3759'>
<font color=#447700>!dir$ concurrent<a name='3760'></font>
<font color=#447700>!cdir nodep<a name='3761'></font>
       do fc = 1, num_snowc<a name='3762'>
          c = filter_snowc(fc)<a name='3763'>
          if (j &gt;= snl(c)+1) then<a name='3764'>
<a name='3765'>
             wx = h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='3766'>
             void = 1. - (h2osoi_ice(c,j)/denice + h2osoi_liq(c,j)/denh2o) / dz(c,j)<a name='3767'>
<a name='3768'>
             <font color=#447700>! Allow compaction only for non-saturated node and higher ice lens node.<a name='3769'></font>
             if (void &gt; 0.001 .and. h2osoi_ice(c,j) &gt; .1) then<a name='3770'>
                bi = h2osoi_ice(c,j) / dz(c,j)<a name='3771'>
                fi = h2osoi_ice(c,j) / wx<a name='3772'>
                td = tfrz-t_soisno(c,j)<a name='3773'>
                dexpf = exp(-c4*td)<a name='3774'>
<a name='3775'>
                <font color=#447700>! Settling as a result of destructive metamorphism<a name='3776'></font>
<a name='3777'>
                ddz1 = -c3*dexpf<a name='3778'>
                if (bi &gt; dm) ddz1 = ddz1*exp(-46.0e-3*(bi-dm))<a name='3779'>
<a name='3780'>
                <font color=#447700>! Liquid water term<a name='3781'></font>
<a name='3782'>
                if (h2osoi_liq(c,j) &gt; 0.01*dz(c,j)) ddz1=ddz1*c5<a name='3783'>
<a name='3784'>
                <font color=#447700>! Compaction due to overburden<a name='3785'></font>
<a name='3786'>
                ddz2 = -burden(c)*exp(-0.08*td - c2*bi)/eta0<a name='3787'>
<a name='3788'>
                <font color=#447700>! Compaction occurring during melt<a name='3789'></font>
<a name='3790'>
                if (imelt(c,j) == 1) then<a name='3791'>
                   ddz3 = - 1./dtime * max(0._r8,(frac_iceold(c,j) - fi)/frac_iceold(c,j))<a name='3792'>
                else<a name='3793'>
                   ddz3 = 0._r8<a name='3794'>
                end if<a name='3795'>
<a name='3796'>
                <font color=#447700>! Time rate of fractional change in dz (units of s-1)<a name='3797'></font>
<a name='3798'>
                pdzdtc = ddz1 + ddz2 + ddz3<a name='3799'>
<a name='3800'>
                <font color=#447700>! The change in dz due to compaction<a name='3801'></font>
<a name='3802'>
                dz(c,j) = dz(c,j) * (1.+pdzdtc*dtime)<a name='3803'>
             end if<a name='3804'>
<a name='3805'>
             <font color=#447700>! Pressure of overlying snow<a name='3806'></font>
<a name='3807'>
             burden(c) = burden(c) + wx<a name='3808'>
<a name='3809'>
          end if<a name='3810'>
       end do<a name='3811'>
    end do<a name='3812'>
<a name='3813'>
  end subroutine SnowCompaction<a name='3814'>
<a name='3815'>
<A NAME='COMBINESNOWLAYERS'><A href='../../html_code/phys/module_sf_lake.F.html#COMBINESNOWLAYERS' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3816'>
  <font color=#993300>subroutine </font><font color=#cc0000>CombineSnowLayers</font>(lbc, ubc,                            &amp; <font color=#447700>!i <A href='../../call_to/COMBINESNOWLAYERS.html' TARGET='index'>2</A>,<A href='../../call_from/COMBINESNOWLAYERS.html' TARGET='index'>5</A><a name='3817'></font>
                              num_snowc, filter_snowc, &amp; <font color=#447700>!i&amp;o<a name='3818'></font>
                              snl,h2osno,snowdp,dz,zi,             &amp; <font color=#447700>!i&amp;o<a name='3819'></font>
                              t_soisno,h2osoi_ice,h2osoi_liq,      &amp; <font color=#447700>!i&amp;o<a name='3820'></font>
                              z)  <font color=#447700>!o<a name='3821'></font>
<font color=#447700>!==========================================================================<a name='3822'></font>
<font color=#447700>! !DESCRIPTION:<a name='3823'></font>
<font color=#447700>! Combine snow layers that are less than a minimum thickness or mass<a name='3824'></font>
<font color=#447700>! If the snow element thickness or mass is less than a prescribed minimum,<a name='3825'></font>
<font color=#447700>! then it is combined with a neighboring element.  The subroutine<a name='3826'></font>
<font color=#447700>! clm\_combo.f90 then executes the combination of mass and energy.<a name='3827'></font>
<font color=#447700>! !CALLED FROM:<a name='3828'></font>
<font color=#447700>! subroutine Hydrology2 in module Hydrology2Mod<a name='3829'></font>
<font color=#447700>!<a name='3830'></font>
<font color=#447700>! !REVISION HISTORY:<a name='3831'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='3832'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='3833'></font>
<font color=#447700>! 2/28/02, Peter Thornton: Migrated to new data structures.<a name='3834'></font>
<font color=#447700>!=========================================================================<a name='3835'></font>
<font color=#447700>! !USES:<a name='3836'></font>
  <font color=#447700>!  use clmtype<a name='3837'></font>
<font color=#447700>!<a name='3838'></font>
<font color=#447700>! !ARGUMENTS:<a name='3839'></font>
    implicit none<a name='3840'>
<font color=#447700>!in:<a name='3841'></font>
    integer, intent(in)    :: lbc, ubc                    <font color=#447700>! column bounds<a name='3842'></font>
   <font color=#447700>! integer, intent(in) :: clandunit(1)       !landunit index for each column<a name='3843'></font>
   <font color=#447700>! integer, intent(in) :: ityplun(1)         !landunit type<a name='3844'></font>
<a name='3845'>
<font color=#447700>!inout:<a name='3846'></font>
    integer, intent(inout) :: num_snowc                   <font color=#447700>! number of column snow points in column filter<a name='3847'></font>
    integer, intent(inout) :: filter_snowc(ubc-lbc+1)     <font color=#447700>! column filter for snow points<a name='3848'></font>
    integer , intent(inout) :: snl(1)            <font color=#447700>!number of snow layers<a name='3849'></font>
    real(r8), intent(inout) :: h2osno(1)         <font color=#447700>!snow water (mm H2O)<a name='3850'></font>
    real(r8), intent(inout) :: snowdp(1)         <font color=#447700>!snow height (m)<a name='3851'></font>
    real(r8), intent(inout) :: dz(1,-nlevsnow+1:nlevsoil)           <font color=#447700>!layer depth (m)<a name='3852'></font>
    real(r8), intent(inout) :: zi(1,-nlevsnow+0:nlevsoil)           <font color=#447700>!interface level below a "z" level (m)<a name='3853'></font>
    real(r8), intent(inout) :: t_soisno(1,-nlevsnow+1:nlevsoil)     <font color=#447700>!soil temperature (Kelvin)<a name='3854'></font>
    real(r8), intent(inout) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!ice lens (kg/m2)<a name='3855'></font>
    real(r8), intent(inout) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!liquid water (kg/m2)<a name='3856'></font>
<a name='3857'>
<font color=#447700>!out:<a name='3858'></font>
<a name='3859'>
    real(r8), intent(out) :: z(1,-nlevsnow+1:nlevsoil)            <font color=#447700>!layer thickness (m)<a name='3860'></font>
<font color=#447700>!<a name='3861'></font>
<font color=#447700>!EOP<a name='3862'></font>
<font color=#447700>!<a name='3863'></font>
<font color=#447700>! !OTHER LOCAL VARIABLES:<a name='3864'></font>
<font color=#447700>!<a name='3865'></font>
    integer :: c, fc                 <font color=#447700>! column indices<a name='3866'></font>
    integer :: i,k                   <font color=#447700>! loop indices<a name='3867'></font>
    integer :: j,l                   <font color=#447700>! node indices<a name='3868'></font>
    integer :: msn_old(lbc:ubc)      <font color=#447700>! number of top snow layer<a name='3869'></font>
    integer :: mssi(lbc:ubc)         <font color=#447700>! node index<a name='3870'></font>
    integer :: neibor                <font color=#447700>! adjacent node selected for combination<a name='3871'></font>
    real(r8):: zwice(lbc:ubc)        <font color=#447700>! total ice mass in snow<a name='3872'></font>
    real(r8):: zwliq (lbc:ubc)       <font color=#447700>! total liquid water in snow<a name='3873'></font>
    real(r8):: dzmin(5)              <font color=#447700>! minimum of top snow layer<a name='3874'></font>
<a name='3875'>
    data dzmin /0.010, 0.015, 0.025, 0.055, 0.115/<a name='3876'>
<font color=#447700>!-----------------------------------------------------------------------<a name='3877'></font>
<a name='3878'>
    <font color=#447700>! Check the mass of ice lens of snow, when the total is less than a small value,<a name='3879'></font>
    <font color=#447700>! combine it with the underlying neighbor.<a name='3880'></font>
<a name='3881'>
<font color=#447700>!dir$ concurrent<a name='3882'></font>
<font color=#447700>!cdir nodep<a name='3883'></font>
    do fc = 1, num_snowc<a name='3884'>
       c = filter_snowc(fc)<a name='3885'>
       msn_old(c) = snl(c)<a name='3886'>
    end do<a name='3887'>
<a name='3888'>
    <font color=#447700>! The following loop is NOT VECTORIZED<a name='3889'></font>
<a name='3890'>
    do fc = 1, num_snowc<a name='3891'>
       c = filter_snowc(fc)<a name='3892'>
   <font color=#447700>!    l = clandunit(c)                                                    <a name='3893'></font>
       do j = msn_old(c)+1,0<a name='3894'>
          if (h2osoi_ice(c,j) &lt;= .1) then<a name='3895'>
           <font color=#447700>!  if (ityplun(l) == istsoil) then                                <a name='3896'></font>
           <font color=#447700>!     h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) + h2osoi_liq(c,j)        <a name='3897'></font>
           <font color=#447700>!     h2osoi_ice(c,j+1) = h2osoi_ice(c,j+1) + h2osoi_ice(c,j)       <a name='3898'></font>
           <font color=#447700>!  else if (ityplun(l) /= istsoil .and. j /= 0) then               <a name='3899'></font>
             h2osoi_liq(c,j+1) = h2osoi_liq(c,j+1) + h2osoi_liq(c,j)<a name='3900'>
             h2osoi_ice(c,j+1) = h2osoi_ice(c,j+1) + h2osoi_ice(c,j)<a name='3901'>
           <font color=#447700>!  end if <a name='3902'></font>
<a name='3903'>
             <font color=#447700>! shift all elements above this down one.<a name='3904'></font>
             if (j &gt; snl(c)+1 .and. snl(c) &lt; -1) then<a name='3905'>
                do i = j, snl(c)+2, -1<a name='3906'>
                   t_soisno(c,i)   = t_soisno(c,i-1)<a name='3907'>
                   h2osoi_liq(c,i) = h2osoi_liq(c,i-1)<a name='3908'>
                   h2osoi_ice(c,i) = h2osoi_ice(c,i-1)<a name='3909'>
                   dz(c,i)         = dz(c,i-1)<a name='3910'>
                end do<a name='3911'>
             end if<a name='3912'>
             snl(c) = snl(c) + 1<a name='3913'>
          end if<a name='3914'>
       end do<a name='3915'>
    end do<a name='3916'>
<a name='3917'>
<font color=#447700>!dir$ concurrent<a name='3918'></font>
<font color=#447700>!cdir nodep<a name='3919'></font>
    do fc = 1, num_snowc<a name='3920'>
       c = filter_snowc(fc)<a name='3921'>
       h2osno(c) = 0._r8<a name='3922'>
       snowdp(c) = 0._r8<a name='3923'>
       zwice(c)  = 0._r8<a name='3924'>
       zwliq(c)  = 0._r8<a name='3925'>
    end do<a name='3926'>
<a name='3927'>
    do j = -nlevsnow+1,0<a name='3928'>
<font color=#447700>!dir$ concurrent<a name='3929'></font>
<font color=#447700>!cdir nodep<a name='3930'></font>
       do fc = 1, num_snowc<a name='3931'>
          c = filter_snowc(fc)<a name='3932'>
          if (j &gt;= snl(c)+1) then<a name='3933'>
             h2osno(c) = h2osno(c) + h2osoi_ice(c,j) + h2osoi_liq(c,j)<a name='3934'>
             snowdp(c) = snowdp(c) + dz(c,j)<a name='3935'>
             zwice(c)  = zwice(c) + h2osoi_ice(c,j)<a name='3936'>
             zwliq(c)  = zwliq(c) + h2osoi_liq(c,j)<a name='3937'>
          end if<a name='3938'>
       end do<a name='3939'>
    end do<a name='3940'>
<a name='3941'>
    <font color=#447700>! Check the snow depth - all snow gone<a name='3942'></font>
    <font color=#447700>! The liquid water assumes ponding on soil surface.<a name='3943'></font>
<a name='3944'>
<font color=#447700>!dir$ concurrent<a name='3945'></font>
<font color=#447700>!cdir nodep<a name='3946'></font>
    do fc = 1, num_snowc<a name='3947'>
       c = filter_snowc(fc)<a name='3948'>
      <font color=#447700>! l = clandunit(c)                                         <a name='3949'></font>
       if (snowdp(c) &lt; 0.01 .and. snowdp(c) &gt; 0.) then<a name='3950'>
          snl(c) = 0<a name='3951'>
          h2osno(c) = zwice(c)<a name='3952'>
          if (h2osno(c) &lt;= 0.) snowdp(c) = 0._r8<a name='3953'>
      <font color=#447700>!    if (ityplun(l) == istsoil) h2osoi_liq(c,1) = h2osoi_liq(c,1) + zwliq(c)    !change by guhp<a name='3954'></font>
       end if<a name='3955'>
    end do<a name='3956'>
<a name='3957'>
    <font color=#447700>! Check the snow depth - snow layers combined<a name='3958'></font>
    <font color=#447700>! The following loop IS NOT VECTORIZED<a name='3959'></font>
<a name='3960'>
    do fc = 1, num_snowc<a name='3961'>
       c = filter_snowc(fc)<a name='3962'>
<a name='3963'>
       <font color=#447700>! Two or more layers<a name='3964'></font>
<a name='3965'>
       if (snl(c) &lt; -1) then<a name='3966'>
<a name='3967'>
          msn_old(c) = snl(c)<a name='3968'>
          mssi(c) = 1<a name='3969'>
<a name='3970'>
          do i = msn_old(c)+1,0<a name='3971'>
             if (dz(c,i) &lt; dzmin(mssi(c))) then<a name='3972'>
<a name='3973'>
                if (i == snl(c)+1) then<a name='3974'>
                   <font color=#447700>! If top node is removed, combine with bottom neighbor.<a name='3975'></font>
                   neibor = i + 1<a name='3976'>
                else if (i == 0) then<a name='3977'>
                   <font color=#447700>! If the bottom neighbor is not snow, combine with the top neighbor.<a name='3978'></font>
                   neibor = i - 1<a name='3979'>
                else<a name='3980'>
                   <font color=#447700>! If none of the above special cases apply, combine with the thinnest neighbor<a name='3981'></font>
                   neibor = i + 1<a name='3982'>
                   if ((dz(c,i-1)+dz(c,i)) &lt; (dz(c,i+1)+dz(c,i))) neibor = i-1<a name='3983'>
                end if<a name='3984'>
<a name='3985'>
                <font color=#447700>! Node l and j are combined and stored as node j.<a name='3986'></font>
                if (neibor &gt; i) then<a name='3987'>
                   j = neibor<a name='3988'>
                   l = i<a name='3989'>
                else<a name='3990'>
                   j = i<a name='3991'>
                   l = neibor<a name='3992'>
                end if<a name='3993'>
<a name='3994'>
                call <A href='../../html_code/phys/module_sf_ssib.F.html#COMBO'>Combo</A><A href='../../html_code/phys/module_sf_lake.F.html#COMBINESNOWLAYERS' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMBO_6"> (dz(c,j), h2osoi_liq(c,j), h2osoi_ice(c,j), &amp;<a name='3995'>
                   t_soisno(c,j), dz(c,l), h2osoi_liq(c,l), h2osoi_ice(c,l), t_soisno(c,l) )<a name='3996'>
<a name='3997'>
                <font color=#447700>! Now shift all elements above this down one.<a name='3998'></font>
                if (j-1 &gt; snl(c)+1) then<a name='3999'>
                   do k = j-1, snl(c)+2, -1<a name='4000'>
                      t_soisno(c,k) = t_soisno(c,k-1)<a name='4001'>
                      h2osoi_ice(c,k) = h2osoi_ice(c,k-1)<a name='4002'>
                      h2osoi_liq(c,k) = h2osoi_liq(c,k-1)<a name='4003'>
                      dz(c,k) = dz(c,k-1)<a name='4004'>
                   end do<a name='4005'>
                end if<a name='4006'>
<a name='4007'>
                <font color=#447700>! Decrease the number of snow layers<a name='4008'></font>
                snl(c) = snl(c) + 1<a name='4009'>
                if (snl(c) &gt;= -1) EXIT<a name='4010'>
<a name='4011'>
             else<a name='4012'>
<a name='4013'>
                <font color=#447700>! The layer thickness is greater than the prescribed minimum value<a name='4014'></font>
                mssi(c) = mssi(c) + 1<a name='4015'>
<a name='4016'>
             end if<a name='4017'>
          end do<a name='4018'>
<a name='4019'>
       end if<a name='4020'>
<a name='4021'>
    end do<a name='4022'>
<a name='4023'>
    <font color=#447700>! Reset the node depth and the depth of layer interface<a name='4024'></font>
<a name='4025'>
    do j = 0, -nlevsnow+1, -1<a name='4026'>
<font color=#447700>!dir$ concurrent<a name='4027'></font>
<font color=#447700>!cdir nodep<a name='4028'></font>
       do fc = 1, num_snowc<a name='4029'>
          c = filter_snowc(fc)<a name='4030'>
          if (j &gt;= snl(c) + 1) then<a name='4031'>
             z(c,j) = zi(c,j) - 0.5*dz(c,j)<a name='4032'>
             zi(c,j-1) = zi(c,j) - dz(c,j)<a name='4033'>
          end if<a name='4034'>
       end do<a name='4035'>
    end do<a name='4036'>
<a name='4037'>
  end subroutine CombineSnowLayers<a name='4038'>
<a name='4039'>
<A NAME='DIVIDESNOWLAYERS'><A href='../../html_code/phys/module_sf_lake.F.html#DIVIDESNOWLAYERS' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4040'>
  <font color=#993300>subroutine </font><font color=#cc0000>DivideSnowLayers</font>(lbc, ubc,                             &amp; <font color=#447700>!i <A href='../../call_to/DIVIDESNOWLAYERS.html' TARGET='index'>2</A>,<A href='../../call_from/DIVIDESNOWLAYERS.html' TARGET='index'>10</A><a name='4041'></font>
                             num_snowc, filter_snowc,  &amp; <font color=#447700>!i&amp;o<a name='4042'></font>
                             snl,dz,zi,t_soisno,                   &amp; <font color=#447700>!i&amp;o<a name='4043'></font>
                             h2osoi_ice,h2osoi_liq,                &amp; <font color=#447700>!i&amp;o<a name='4044'></font>
                             z)  <font color=#447700>!o<a name='4045'></font>
<a name='4046'>
<a name='4047'>
<font color=#447700>!============================================================================<a name='4048'></font>
<font color=#447700>! !DESCRIPTION:<a name='4049'></font>
<font color=#447700>! Subdivides snow layers if they exceed their prescribed maximum thickness.<a name='4050'></font>
<font color=#447700>! !CALLED FROM:<a name='4051'></font>
<font color=#447700>! subroutine Hydrology2 in module Hydrology2Mod<a name='4052'></font>
<font color=#447700>!<a name='4053'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4054'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='4055'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='4056'></font>
<font color=#447700>! 2/28/02, Peter Thornton: Migrated to new data structures.<a name='4057'></font>
<font color=#447700>!============================================================================<a name='4058'></font>
<font color=#447700>! !USES:<a name='4059'></font>
 <font color=#447700>!   use clmtype<a name='4060'></font>
<font color=#447700>!<a name='4061'></font>
<font color=#447700>! !ARGUMENTS:<a name='4062'></font>
    implicit none<a name='4063'>
<a name='4064'>
<font color=#447700>!in:<a name='4065'></font>
    integer, intent(in)    :: lbc, ubc                    <font color=#447700>! column bounds<a name='4066'></font>
<a name='4067'>
<font color=#447700>!inout:<a name='4068'></font>
<a name='4069'>
    integer, intent(inout) :: num_snowc                   <font color=#447700>! number of column snow points in column filter<a name='4070'></font>
    integer, intent(inout) :: filter_snowc(ubc-lbc+1)     <font color=#447700>! column filter for snow points<a name='4071'></font>
    integer , intent(inout) :: snl(1)            <font color=#447700>!number of snow layers<a name='4072'></font>
    real(r8), intent(inout) :: dz(1,-nlevsnow+1:nlevsoil)           <font color=#447700>!layer depth (m)<a name='4073'></font>
    real(r8), intent(inout) :: zi(1,-nlevsnow+0:nlevsoil)           <font color=#447700>!interface level below a "z" level (m)<a name='4074'></font>
    real(r8), intent(inout) :: t_soisno(1,-nlevsnow+1:nlevsoil)     <font color=#447700>!soil temperature (Kelvin)<a name='4075'></font>
    real(r8), intent(inout) :: h2osoi_ice(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!ice lens (kg/m2)<a name='4076'></font>
    real(r8), intent(inout) :: h2osoi_liq(1,-nlevsnow+1:nlevsoil)   <font color=#447700>!liquid water (kg/m2)<a name='4077'></font>
<a name='4078'>
<font color=#447700>!out: <a name='4079'></font>
<a name='4080'>
    real(r8), intent(out) :: z(1,-nlevsnow+1:nlevsoil)            <font color=#447700>!layer thickness (m)<a name='4081'></font>
<a name='4082'>
<a name='4083'>
<a name='4084'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='4085'></font>
<a name='4086'>
    integer  :: j, c, fc               <font color=#447700>! indices<a name='4087'></font>
    real(r8) :: drr                    <font color=#447700>! thickness of the combined [m]<a name='4088'></font>
    integer  :: msno                   <font color=#447700>! number of snow layer 1 (top) to msno (bottom)<a name='4089'></font>
    real(r8) :: dzsno(lbc:ubc,nlevsnow) <font color=#447700>! Snow layer thickness [m]<a name='4090'></font>
    real(r8) :: swice(lbc:ubc,nlevsnow) <font color=#447700>! Partial volume of ice [m3/m3]<a name='4091'></font>
    real(r8) :: swliq(lbc:ubc,nlevsnow) <font color=#447700>! Partial volume of liquid water [m3/m3]<a name='4092'></font>
    real(r8) :: tsno(lbc:ubc ,nlevsnow) <font color=#447700>! Nodel temperature [K]<a name='4093'></font>
    real(r8) :: zwice                  <font color=#447700>! temporary<a name='4094'></font>
    real(r8) :: zwliq                  <font color=#447700>! temporary<a name='4095'></font>
    real(r8) :: propor                 <font color=#447700>! temporary<a name='4096'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='4097'></font>
<a name='4098'>
    <font color=#447700>! Begin calculation - note that the following column loops are only invoked<a name='4099'></font>
    <font color=#447700>! for snow-covered columns<a name='4100'></font>
<a name='4101'>
    do j = 1,nlevsnow<a name='4102'>
<font color=#447700>!dir$ concurrent<a name='4103'></font>
<font color=#447700>!cdir nodep<a name='4104'></font>
       do fc = 1, num_snowc<a name='4105'>
          c = filter_snowc(fc)<a name='4106'>
          if (j &lt;= abs(snl(c))) then<a name='4107'>
             dzsno(c,j) = dz(c,j+snl(c))<a name='4108'>
             swice(c,j) = h2osoi_ice(c,j+snl(c))<a name='4109'>
             swliq(c,j) = h2osoi_liq(c,j+snl(c))<a name='4110'>
             tsno(c,j)  = t_soisno(c,j+snl(c))<a name='4111'>
          end if<a name='4112'>
       end do<a name='4113'>
    end do<a name='4114'>
<a name='4115'>
<font color=#447700>!dir$ concurrent<a name='4116'></font>
<font color=#447700>!cdir nodep<a name='4117'></font>
    do fc = 1, num_snowc<a name='4118'>
       c = filter_snowc(fc)<a name='4119'>
<a name='4120'>
       msno = abs(snl(c))<a name='4121'>
<a name='4122'>
       if (msno == 1) then<a name='4123'>
          <font color=#447700>! Specify a new snow layer<a name='4124'></font>
          if (dzsno(c,1) &gt; 0.03) then<a name='4125'>
             msno = 2<a name='4126'>
             dzsno(c,1) = dzsno(c,1)/2.<a name='4127'>
             swice(c,1) = swice(c,1)/2.<a name='4128'>
             swliq(c,1) = swliq(c,1)/2.<a name='4129'>
             dzsno(c,2) = dzsno(c,1)<a name='4130'>
             swice(c,2) = swice(c,1)<a name='4131'>
             swliq(c,2) = swliq(c,1)<a name='4132'>
             tsno(c,2)  = tsno(c,1)<a name='4133'>
          end if<a name='4134'>
       end if<a name='4135'>
<a name='4136'>
       if (msno &gt; 1) then<a name='4137'>
          if (dzsno(c,1) &gt; 0.02) then<a name='4138'>
             drr = dzsno(c,1) - 0.02<a name='4139'>
             propor = drr/dzsno(c,1)<a name='4140'>
             zwice = propor*swice(c,1)<a name='4141'>
             zwliq = propor*swliq(c,1)<a name='4142'>
             propor = 0.02/dzsno(c,1)<a name='4143'>
             swice(c,1) = propor*swice(c,1)<a name='4144'>
             swliq(c,1) = propor*swliq(c,1)<a name='4145'>
             dzsno(c,1) = 0.02<a name='4146'>
<a name='4147'>
             call <A href='../../html_code/phys/module_sf_ssib.F.html#COMBO'>Combo</A><A href='../../html_code/phys/module_sf_lake.F.html#DIVIDESNOWLAYERS' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMBO_7"> (dzsno(c,2), swliq(c,2), swice(c,2), tsno(c,2), drr, &amp;<a name='4148'>
                  zwliq, zwice, tsno(c,1))<a name='4149'>
<a name='4150'>
             <font color=#447700>! Subdivide a new layer<a name='4151'></font>
             if (msno &lt;= 2 .and. dzsno(c,2) &gt; 0.07) then<a name='4152'>
                msno = 3<a name='4153'>
                dzsno(c,2) = dzsno(c,2)/2.<a name='4154'>
                swice(c,2) = swice(c,2)/2.<a name='4155'>
                swliq(c,2) = swliq(c,2)/2.<a name='4156'>
                dzsno(c,3) = dzsno(c,2)<a name='4157'>
                swice(c,3) = swice(c,2)<a name='4158'>
                swliq(c,3) = swliq(c,2)<a name='4159'>
                tsno(c,3)  = tsno(c,2)<a name='4160'>
             end if<a name='4161'>
          end if<a name='4162'>
       end if<a name='4163'>
<a name='4164'>
       if (msno &gt; 2) then<a name='4165'>
          if (dzsno(c,2) &gt; 0.05) then<a name='4166'>
             drr = dzsno(c,2) - 0.05<a name='4167'>
             propor = drr/dzsno(c,2)<a name='4168'>
             zwice = propor*swice(c,2)<a name='4169'>
             zwliq = propor*swliq(c,2)<a name='4170'>
             propor = 0.05/dzsno(c,2)<a name='4171'>
             swice(c,2) = propor*swice(c,2)<a name='4172'>
             swliq(c,2) = propor*swliq(c,2)<a name='4173'>
             dzsno(c,2) = 0.05<a name='4174'>
<a name='4175'>
             call <A href='../../html_code/phys/module_sf_ssib.F.html#COMBO'>Combo</A><A href='../../html_code/phys/module_sf_lake.F.html#DIVIDESNOWLAYERS' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMBO_8"> (dzsno(c,3), swliq(c,3), swice(c,3), tsno(c,3), drr, &amp;<a name='4176'>
                  zwliq, zwice, tsno(c,2))<a name='4177'>
<a name='4178'>
             <font color=#447700>! Subdivided a new layer<a name='4179'></font>
             if (msno &lt;= 3 .and. dzsno(c,3) &gt; 0.18) then<a name='4180'>
                msno =  4<a name='4181'>
                dzsno(c,3) = dzsno(c,3)/2.<a name='4182'>
                swice(c,3) = swice(c,3)/2.<a name='4183'>
                swliq(c,3) = swliq(c,3)/2.<a name='4184'>
                dzsno(c,4) = dzsno(c,3)<a name='4185'>
                swice(c,4) = swice(c,3)<a name='4186'>
                swliq(c,4) = swliq(c,3)<a name='4187'>
                tsno(c,4)  = tsno(c,3)<a name='4188'>
             end if<a name='4189'>
          end if<a name='4190'>
       end if<a name='4191'>
<a name='4192'>
       if (msno &gt; 3) then<a name='4193'>
          if (dzsno(c,3) &gt; 0.11) then<a name='4194'>
             drr = dzsno(c,3) - 0.11<a name='4195'>
             propor = drr/dzsno(c,3)<a name='4196'>
             zwice = propor*swice(c,3)<a name='4197'>
             zwliq = propor*swliq(c,3)<a name='4198'>
             propor = 0.11/dzsno(c,3)<a name='4199'>
             swice(c,3) = propor*swice(c,3)<a name='4200'>
             swliq(c,3) = propor*swliq(c,3)<a name='4201'>
             dzsno(c,3) = 0.11<a name='4202'>
<a name='4203'>
             call <A href='../../html_code/phys/module_sf_ssib.F.html#COMBO'>Combo</A><A href='../../html_code/phys/module_sf_lake.F.html#DIVIDESNOWLAYERS' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMBO_9"> (dzsno(c,4), swliq(c,4), swice(c,4), tsno(c,4), drr, &amp;<a name='4204'>
                  zwliq, zwice, tsno(c,3))<a name='4205'>
<a name='4206'>
             <font color=#447700>! Subdivided a new layer<a name='4207'></font>
             if (msno &lt;= 4 .and. dzsno(c,4) &gt; 0.41) then<a name='4208'>
                msno = 5<a name='4209'>
                dzsno(c,4) = dzsno(c,4)/2.<a name='4210'>
                swice(c,4) = swice(c,4)/2.<a name='4211'>
                swliq(c,4) = swliq(c,4)/2.<a name='4212'>
                dzsno(c,5) = dzsno(c,4)<a name='4213'>
                swice(c,5) = swice(c,4)<a name='4214'>
                swliq(c,5) = swliq(c,4)<a name='4215'>
                tsno(c,5)  = tsno(c,4)<a name='4216'>
             end if<a name='4217'>
          end if<a name='4218'>
       end if<a name='4219'>
<a name='4220'>
       if (msno &gt; 4) then<a name='4221'>
          if (dzsno(c,4) &gt; 0.23) then<a name='4222'>
             drr = dzsno(c,4) - 0.23<a name='4223'>
             propor = drr/dzsno(c,4)<a name='4224'>
             zwice = propor*swice(c,4)<a name='4225'>
             zwliq = propor*swliq(c,4)<a name='4226'>
             propor = 0.23/dzsno(c,4)<a name='4227'>
             swice(c,4) = propor*swice(c,4)<a name='4228'>
             swliq(c,4) = propor*swliq(c,4)<a name='4229'>
             dzsno(c,4) = 0.23<a name='4230'>
<a name='4231'>
             call <A href='../../html_code/phys/module_sf_ssib.F.html#COMBO'>Combo</A><A href='../../html_code/phys/module_sf_lake.F.html#DIVIDESNOWLAYERS' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMBO_10"> (dzsno(c,5), swliq(c,5), swice(c,5), tsno(c,5), drr, &amp;<a name='4232'>
                  zwliq, zwice, tsno(c,4))<a name='4233'>
          end if<a name='4234'>
       end if<a name='4235'>
<a name='4236'>
       snl(c) = -msno<a name='4237'>
<a name='4238'>
    end do<a name='4239'>
<a name='4240'>
    do j = -nlevsnow+1,0<a name='4241'>
<font color=#447700>!dir$ concurrent<a name='4242'></font>
<font color=#447700>!cdir nodep<a name='4243'></font>
       do fc = 1, num_snowc<a name='4244'>
          c = filter_snowc(fc)<a name='4245'>
          if (j &gt;= snl(c)+1) then<a name='4246'>
             dz(c,j)         = dzsno(c,j-snl(c))<a name='4247'>
             h2osoi_ice(c,j) = swice(c,j-snl(c))<a name='4248'>
             h2osoi_liq(c,j) = swliq(c,j-snl(c))<a name='4249'>
             t_soisno(c,j)   = tsno(c,j-snl(c))<a name='4250'>
          end if<a name='4251'>
       end do<a name='4252'>
    end do<a name='4253'>
<a name='4254'>
    do j = 0, -nlevsnow+1, -1<a name='4255'>
<font color=#447700>!dir$ concurrent<a name='4256'></font>
<font color=#447700>!cdir nodep<a name='4257'></font>
       do fc = 1, num_snowc<a name='4258'>
          c = filter_snowc(fc)<a name='4259'>
          if (j &gt;= snl(c)+1) then<a name='4260'>
             z(c,j)    = zi(c,j) - 0.5*dz(c,j)<a name='4261'>
             zi(c,j-1) = zi(c,j) - dz(c,j)<a name='4262'>
          end if<a name='4263'>
       end do<a name='4264'>
    end do<a name='4265'>
<a name='4266'>
  end subroutine DivideSnowLayers<a name='4267'>
<a name='4268'>
<A NAME='COMBO'><A href='../../html_code/phys/module_sf_lake.F.html#COMBO' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4269'>
  <font color=#993300>subroutine </font><font color=#cc0000>Combo</font>(dz,  wliq,  wice, t, dz2, wliq2, wice2, t2) <A href='../../call_to/COMBO.html' TARGET='index'>17</A>,<A href='../../call_from/COMBO.html' TARGET='index'>1</A><a name='4270'>
<font color=#447700>!<a name='4271'></font>
<font color=#447700>! !DESCRIPTION:<a name='4272'></font>
<font color=#447700>! Combines two elements and returns the following combined<a name='4273'></font>
<font color=#447700>! variables: dz, t, wliq, wice.<a name='4274'></font>
<font color=#447700>! The combined temperature is based on the equation:<a name='4275'></font>
<font color=#447700>! the sum of the enthalpies of the two elements =<a name='4276'></font>
<font color=#447700>! that of the combined element.<a name='4277'></font>
<font color=#447700>!<a name='4278'></font>
<font color=#447700>! !USES:<a name='4279'></font>
<font color=#447700>!<a name='4280'></font>
<font color=#447700>! !ARGUMENTS:<a name='4281'></font>
    implicit none<a name='4282'>
    real(r8), intent(in)    :: dz2   <font color=#447700>! nodal thickness of 2 elements being combined [m]<a name='4283'></font>
    real(r8), intent(in)    :: wliq2 <font color=#447700>! liquid water of element 2 [kg/m2]<a name='4284'></font>
    real(r8), intent(in)    :: wice2 <font color=#447700>! ice of element 2 [kg/m2]<a name='4285'></font>
    real(r8), intent(in)    :: t2    <font color=#447700>! nodal temperature of element 2 [K]<a name='4286'></font>
    real(r8), intent(inout) :: dz    <font color=#447700>! nodal thickness of 1 elements being combined [m]<a name='4287'></font>
    real(r8), intent(inout) :: wliq  <font color=#447700>! liquid water of element 1<a name='4288'></font>
    real(r8), intent(inout) :: wice  <font color=#447700>! ice of element 1 [kg/m2]<a name='4289'></font>
    real(r8), intent(inout) :: t     <font color=#447700>! nodel temperature of elment 1 [K]<a name='4290'></font>
<font color=#447700>!<a name='4291'></font>
<font color=#447700>! !CALLED FROM:<a name='4292'></font>
<font color=#447700>! subroutine CombineSnowLayers in this module<a name='4293'></font>
<font color=#447700>! subroutine DivideSnowLayers in this module<a name='4294'></font>
<font color=#447700>!<a name='4295'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4296'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='4297'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='4298'></font>
<font color=#447700>!<a name='4299'></font>
<font color=#447700>!EOP<a name='4300'></font>
<font color=#447700>!<a name='4301'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='4302'></font>
<font color=#447700>!<a name='4303'></font>
    real(r8) :: dzc   <font color=#447700>! Total thickness of nodes 1 and 2 (dzc=dz+dz2).<a name='4304'></font>
    real(r8) :: wliqc <font color=#447700>! Combined liquid water [kg/m2]<a name='4305'></font>
    real(r8) :: wicec <font color=#447700>! Combined ice [kg/m2]<a name='4306'></font>
    real(r8) :: tc    <font color=#447700>! Combined node temperature [K]<a name='4307'></font>
    real(r8) :: h     <font color=#447700>! enthalpy of element 1 [J/m2]<a name='4308'></font>
    real(r8) :: h2    <font color=#447700>! enthalpy of element 2 [J/m2]<a name='4309'></font>
    real(r8) :: hc    <font color=#447700>! temporary<a name='4310'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='4311'></font>
<a name='4312'>
    dzc = dz+dz2<a name='4313'>
    wicec = (wice+wice2)<a name='4314'>
    wliqc = (wliq+wliq2)<a name='4315'>
    h = (cpice*wice+cpliq*wliq) * (t-tfrz)+hfus*wliq<a name='4316'>
    h2= (cpice*wice2+cpliq*wliq2) * (t2-tfrz)+hfus*wliq2<a name='4317'>
<a name='4318'>
    hc = h + h2<a name='4319'>
    if(hc &lt; 0.)then<a name='4320'>
       tc = tfrz + hc/(cpice*wicec + cpliq*wliqc)<a name='4321'>
    else if (hc.le.hfus*wliqc) then<a name='4322'>
       tc = tfrz<a name='4323'>
    else<a name='4324'>
       tc = tfrz + (hc - hfus*wliqc) / (cpice*wicec + cpliq*wliqc)<a name='4325'>
    end if<a name='4326'>
<a name='4327'>
    dz = dzc<a name='4328'>
    wice = wicec<a name='4329'>
    wliq = wliqc<a name='4330'>
    t = tc<a name='4331'>
<a name='4332'>
  end subroutine Combo<a name='4333'>
<a name='4334'>
<A NAME='BUILDSNOWFILTER'><A href='../../html_code/phys/module_sf_lake.F.html#BUILDSNOWFILTER' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4335'>
  <font color=#993300>subroutine </font><font color=#cc0000>BuildSnowFilter</font>(lbc, ubc, num_nolakec, filter_nolakec,snl, &amp; <font color=#447700>!i <A href='../../call_to/BUILDSNOWFILTER.html' TARGET='index'>4</A>,<A href='../../call_from/BUILDSNOWFILTER.html' TARGET='index'>1</A><a name='4336'></font>
                             num_snowc, filter_snowc, &amp;                   <font color=#447700>!o<a name='4337'></font>
                             num_nosnowc, filter_nosnowc)                 <font color=#447700>!o<a name='4338'></font>
<font color=#447700>!<a name='4339'></font>
<font color=#447700>! !DESCRIPTION:<a name='4340'></font>
<font color=#447700>! Constructs snow filter for use in vectorized loops for snow hydrology.<a name='4341'></font>
<font color=#447700>!<a name='4342'></font>
<font color=#447700>! !USES:<a name='4343'></font>
<font color=#447700>!    use clmtype<a name='4344'></font>
<font color=#447700>!<a name='4345'></font>
<font color=#447700>! !ARGUMENTS:<a name='4346'></font>
    implicit none<a name='4347'>
    integer, intent(in)  :: lbc, ubc                    <font color=#447700>! column bounds<a name='4348'></font>
    integer, intent(in)  :: num_nolakec                 <font color=#447700>! number of column non-lake points in column filter<a name='4349'></font>
    integer, intent(in)  :: filter_nolakec(ubc-lbc+1)   <font color=#447700>! column filter for non-lake points<a name='4350'></font>
    integer, intent(in)  :: snl(1)                        <font color=#447700>! number of snow layers<a name='4351'></font>
    integer, intent(out) :: num_snowc                   <font color=#447700>! number of column snow points in column filter<a name='4352'></font>
    integer, intent(out) :: filter_snowc(ubc-lbc+1)     <font color=#447700>! column filter for snow points<a name='4353'></font>
    integer, intent(out) :: num_nosnowc                 <font color=#447700>! number of column non-snow points in column filter<a name='4354'></font>
    integer, intent(out) :: filter_nosnowc(ubc-lbc+1)   <font color=#447700>! column filter for non-snow points<a name='4355'></font>
<font color=#447700>!<a name='4356'></font>
<font color=#447700>! !CALLED FROM:<a name='4357'></font>
<font color=#447700>! subroutine Hydrology2 in Hydrology2Mod<a name='4358'></font>
<font color=#447700>! subroutine CombineSnowLayers in this module<a name='4359'></font>
<font color=#447700>!<a name='4360'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4361'></font>
<font color=#447700>! 2003 July 31: Forrest Hoffman<a name='4362'></font>
<font color=#447700>!<a name='4363'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='4364'></font>
<font color=#447700>! local pointers to implicit in arguments<a name='4365'></font>
<font color=#447700>!<a name='4366'></font>
<font color=#447700>!EOP<a name='4367'></font>
<font color=#447700>!<a name='4368'></font>
<font color=#447700>! !OTHER LOCAL VARIABLES:<a name='4369'></font>
    integer  :: fc, c<a name='4370'>
<font color=#447700>!-----------------------------------------------------------------------<a name='4371'></font>
<a name='4372'>
<a name='4373'>
    <font color=#447700>! Build snow/no-snow filters for other subroutines<a name='4374'></font>
<a name='4375'>
    num_snowc = 0<a name='4376'>
    num_nosnowc = 0<a name='4377'>
    do fc = 1, num_nolakec<a name='4378'>
       c = filter_nolakec(fc)<a name='4379'>
       if (snl(c) &lt; 0) then<a name='4380'>
          num_snowc = num_snowc + 1<a name='4381'>
          filter_snowc(num_snowc) = c<a name='4382'>
       else<a name='4383'>
          num_nosnowc = num_nosnowc + 1<a name='4384'>
          filter_nosnowc(num_nosnowc) = c<a name='4385'>
       end if<a name='4386'>
    end do<a name='4387'>
<a name='4388'>
  end subroutine BuildSnowFilter<a name='4389'>
<a name='4390'>
<a name='4391'>
<a name='4392'>
<A NAME='FRICTIONVELOCITY'><A href='../../html_code/phys/module_sf_lake.F.html#FRICTIONVELOCITY' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4393'>
<font color=#993300>subroutine </font><font color=#cc0000>FrictionVelocity</font>(pgridcell,forc_hgt,forc_hgt_u,        &amp; <font color=#447700>!i  <A href='../../call_to/FRICTIONVELOCITY.html' TARGET='index'>4</A>,<A href='../../call_from/FRICTIONVELOCITY.html' TARGET='index'>2</A><a name='4394'></font>
                             forc_hgt_t,forc_hgt_q,                  &amp; <font color=#447700>!i <a name='4395'></font>
                             lbp, ubp, fn, filterp,                  &amp; <font color=#447700>!i <a name='4396'></font>
                             displa, z0m, z0h, z0q,                  &amp; <font color=#447700>!i <a name='4397'></font>
                             obu, iter, ur, um,                      &amp; <font color=#447700>!i <a name='4398'></font>
                             ustar,temp1, temp2, temp12m, temp22m,   &amp; <font color=#447700>!o <a name='4399'></font>
                             u10,fv,                                 &amp; <font color=#447700>!o <a name='4400'></font>
                             fm)  <font color=#447700>!i&amp;o <a name='4401'></font>
<a name='4402'>
<font color=#447700>!=============================================================================<a name='4403'></font>
<font color=#447700>! !DESCRIPTION:<a name='4404'></font>
<font color=#447700>! Calculation of the friction velocity, relation for potential<a name='4405'></font>
<font color=#447700>! temperature and humidity profiles of surface boundary layer.<a name='4406'></font>
<font color=#447700>! The scheme is based on the work of Zeng et al. (1998):<a name='4407'></font>
<font color=#447700>! Intercomparison of bulk aerodynamic algorithms for the computation<a name='4408'></font>
<font color=#447700>! of sea surface fluxes using TOGA CORE and TAO data. J. Climate,<a name='4409'></font>
<font color=#447700>! Vol. 11, 2628-2644.<a name='4410'></font>
<font color=#447700>!<a name='4411'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4412'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='4413'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='4414'></font>
<font color=#447700>! 12/19/01, Peter Thornton<a name='4415'></font>
<font color=#447700>! Added arguments to eliminate passing clm derived type into this function.<a name='4416'></font>
<font color=#447700>! Created by Mariana Vertenstein<a name='4417'></font>
<font color=#447700>!============================================================================<a name='4418'></font>
<font color=#447700>! !USES:<a name='4419'></font>
  <font color=#447700>! use clmtype<a name='4420'></font>
   <font color=#447700>!!use clm_atmlnd, only : clm_a2l<a name='4421'></font>
<font color=#447700>!<a name='4422'></font>
<font color=#447700>! !ARGUMENTS:<a name='4423'></font>
   implicit none<a name='4424'>
<a name='4425'>
<font color=#447700>!in:<a name='4426'></font>
<a name='4427'>
   integer , intent(in) :: pgridcell(1)   <font color=#447700>! pft's gridcell index<a name='4428'></font>
   real(r8), intent(in) :: forc_hgt(1)    <font color=#447700>! atmospheric reference height (m)<a name='4429'></font>
   real(r8), intent(in) :: forc_hgt_u(1)  <font color=#447700>! observational height of wind [m]<a name='4430'></font>
   real(r8), intent(in) :: forc_hgt_t(1)  <font color=#447700>! observational height of temperature [m]<a name='4431'></font>
   real(r8), intent(in) :: forc_hgt_q(1)  <font color=#447700>! observational height of humidity [m]<a name='4432'></font>
   integer , intent(in)  :: lbp, ubp         <font color=#447700>! pft array bounds<a name='4433'></font>
   integer , intent(in)  :: fn               <font color=#447700>! number of filtered pft elements<a name='4434'></font>
   integer , intent(in)  :: filterp(fn)      <font color=#447700>! pft filter<a name='4435'></font>
   real(r8), intent(in)  :: displa(lbp:ubp)  <font color=#447700>! displacement height (m)<a name='4436'></font>
   real(r8), intent(in)  :: z0m(lbp:ubp)     <font color=#447700>! roughness length over vegetation, momentum [m]<a name='4437'></font>
   real(r8), intent(in)  :: z0h(lbp:ubp)     <font color=#447700>! roughness length over vegetation, sensible heat [m]<a name='4438'></font>
   real(r8), intent(in)  :: z0q(lbp:ubp)     <font color=#447700>! roughness length over vegetation, latent heat [m]<a name='4439'></font>
   real(r8), intent(in)  :: obu(lbp:ubp)     <font color=#447700>! monin-obukhov length (m)<a name='4440'></font>
   integer,  intent(in)  :: iter             <font color=#447700>! iteration number<a name='4441'></font>
   real(r8), intent(in)  :: ur(lbp:ubp)      <font color=#447700>! wind speed at reference height [m/s]<a name='4442'></font>
   real(r8), intent(in)  :: um(lbp:ubp)      <font color=#447700>! wind speed including the stablity effect [m/s]<a name='4443'></font>
<a name='4444'>
<font color=#447700>!out:<a name='4445'></font>
<a name='4446'>
   real(r8), intent(out) :: ustar(lbp:ubp)   <font color=#447700>! friction velocity [m/s]<a name='4447'></font>
   real(r8), intent(out) :: temp1(lbp:ubp)   <font color=#447700>! relation for potential temperature profile<a name='4448'></font>
   real(r8), intent(out) :: temp12m(lbp:ubp) <font color=#447700>! relation for potential temperature profile applied at 2-m<a name='4449'></font>
   real(r8), intent(out) :: temp2(lbp:ubp)   <font color=#447700>! relation for specific humidity profile<a name='4450'></font>
   real(r8), intent(out) :: temp22m(lbp:ubp) <font color=#447700>! relation for specific humidity profile applied at 2-m<a name='4451'></font>
   real(r8), intent(out) :: u10(1)         <font color=#447700>! 10-m wind (m/s) (for dust model)<a name='4452'></font>
   real(r8), intent(out) :: fv(1)          <font color=#447700>! friction velocity (m/s) (for dust model)<a name='4453'></font>
<a name='4454'>
<font color=#447700>!inout:<a name='4455'></font>
   real(r8), intent(inout) :: fm(lbp:ubp)    <font color=#447700>! needed for DGVM only to diagnose 10m wind<a name='4456'></font>
<a name='4457'>
<font color=#447700>! OTHER LOCAL VARIABLES:<a name='4458'></font>
<a name='4459'>
   real(r8), parameter :: zetam = 1.574_r8 <font color=#447700>! transition point of flux-gradient relation (wind profile)<a name='4460'></font>
   real(r8), parameter :: zetat = 0.465_r8 <font color=#447700>! transition point of flux-gradient relation (temp. profile)<a name='4461'></font>
   integer :: f                         <font color=#447700>! pft-filter index<a name='4462'></font>
   integer :: p                         <font color=#447700>! pft index<a name='4463'></font>
   integer :: g                         <font color=#447700>! gridcell index<a name='4464'></font>
   real(r8):: zldis(lbp:ubp)            <font color=#447700>! reference height "minus" zero displacement heght [m]<a name='4465'></font>
   real(r8):: zeta(lbp:ubp)             <font color=#447700>! dimensionless height used in Monin-Obukhov theory<a name='4466'></font>
#if (defined DGVM) || (defined DUST)<a name='4467'>
   real(r8) :: tmp1,tmp2,tmp3,tmp4      <font color=#447700>! Used to diagnose the 10 meter wind<a name='4468'></font>
   real(r8) :: fmnew                    <font color=#447700>! Used to diagnose the 10 meter wind<a name='4469'></font>
   real(r8) :: fm10                     <font color=#447700>! Used to diagnose the 10 meter wind<a name='4470'></font>
   real(r8) :: zeta10                   <font color=#447700>! Used to diagnose the 10 meter wind<a name='4471'></font>
#endif<a name='4472'>
<font color=#447700>!------------------------------------------------------------------------------<a name='4473'></font>
<a name='4474'>
<a name='4475'>
   <font color=#447700>! Adjustment factors for unstable (moz &lt; 0) or stable (moz &gt; 0) conditions.<a name='4476'></font>
<a name='4477'>
#if (<font color=#447700>!defined PERGRO)<a name='4478'></font>
<a name='4479'>
<font color=#447700>!dir$ concurrent<a name='4480'></font>
<font color=#447700>!cdir nodep<a name='4481'></font>
   do f = 1, fn<a name='4482'>
      p = filterp(f)<a name='4483'>
      g = pgridcell(p)<a name='4484'>
<a name='4485'>
      <font color=#447700>! Wind profile<a name='4486'></font>
<a name='4487'>
      zldis(p) = forc_hgt_u(g)-displa(p)<a name='4488'>
      zeta(p) = zldis(p)/obu(p)<a name='4489'>
      if (zeta(p) &lt; -zetam) then<a name='4490'>
         ustar(p) = vkc*um(p)/(log(-zetam*obu(p)/z0m(p))&amp;<a name='4491'>
              - StabilityFunc1(-zetam) &amp;<a name='4492'>
              + StabilityFunc1(z0m(p)/obu(p)) &amp;<a name='4493'>
              + 1.14_r8*((-zeta(p))**0.333_r8-(zetam)**0.333_r8))<a name='4494'>
      else if (zeta(p) &lt; 0._r8) then<a name='4495'>
         ustar(p) = vkc*um(p)/(log(zldis(p)/z0m(p))&amp;<a name='4496'>
              - StabilityFunc1(zeta(p))&amp;<a name='4497'>
              + StabilityFunc1(z0m(p)/obu(p)))<a name='4498'>
      else if (zeta(p) &lt;=  1._r8) then<a name='4499'>
         ustar(p) = vkc*um(p)/(log(zldis(p)/z0m(p)) + 5._r8*zeta(p) -5._r8*z0m(p)/obu(p))<a name='4500'>
      else<a name='4501'>
         ustar(p) = vkc*um(p)/(log(obu(p)/z0m(p))+5._r8-5._r8*z0m(p)/obu(p) &amp;<a name='4502'>
              +(5._r8*log(zeta(p))+zeta(p)-1._r8))<a name='4503'>
      end if<a name='4504'>
<a name='4505'>
      <font color=#447700>! Temperature profile<a name='4506'></font>
<a name='4507'>
      zldis(p) = forc_hgt_t(g)-displa(p)<a name='4508'>
      zeta(p) = zldis(p)/obu(p)<a name='4509'>
      if (zeta(p) &lt; -zetat) then<a name='4510'>
         temp1(p) = vkc/(log(-zetat*obu(p)/z0h(p))&amp;<a name='4511'>
              - StabilityFunc2(-zetat) &amp;<a name='4512'>
              + StabilityFunc2(z0h(p)/obu(p)) &amp;<a name='4513'>
              + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta(p))**(-0.333_r8)))<a name='4514'>
      else if (zeta(p) &lt; 0._r8) then<a name='4515'>
         temp1(p) = vkc/(log(zldis(p)/z0h(p)) &amp;<a name='4516'>
              - StabilityFunc2(zeta(p)) &amp;<a name='4517'>
              + StabilityFunc2(z0h(p)/obu(p)))<a name='4518'>
      else if (zeta(p) &lt;=  1._r8) then<a name='4519'>
         temp1(p) = vkc/(log(zldis(p)/z0h(p)) + 5._r8*zeta(p) - 5._r8*z0h(p)/obu(p))<a name='4520'>
      else<a name='4521'>
         temp1(p) = vkc/(log(obu(p)/z0h(p)) + 5._r8 - 5._r8*z0h(p)/obu(p) &amp;<a name='4522'>
              + (5._r8*log(zeta(p))+zeta(p)-1._r8))<a name='4523'>
      end if<a name='4524'>
<a name='4525'>
      <font color=#447700>! Humidity profile<a name='4526'></font>
<a name='4527'>
      if (forc_hgt_q(g) == forc_hgt_t(g) .and. z0q(p) == z0h(p)) then<a name='4528'>
         temp2(p) = temp1(p)<a name='4529'>
      else<a name='4530'>
         zldis(p) = forc_hgt_q(g)-displa(p)<a name='4531'>
         zeta(p) = zldis(p)/obu(p)<a name='4532'>
         if (zeta(p) &lt; -zetat) then<a name='4533'>
            temp2(p) = vkc/(log(-zetat*obu(p)/z0q(p)) &amp;<a name='4534'>
                 - StabilityFunc2(-zetat) &amp;<a name='4535'>
                 + StabilityFunc2(z0q(p)/obu(p)) &amp;<a name='4536'>
                 + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta(p))**(-0.333_r8)))<a name='4537'>
         else if (zeta(p) &lt; 0._r8) then<a name='4538'>
            temp2(p) = vkc/(log(zldis(p)/z0q(p)) &amp;<a name='4539'>
                 - StabilityFunc2(zeta(p)) &amp;<a name='4540'>
                 + StabilityFunc2(z0q(p)/obu(p)))<a name='4541'>
         else if (zeta(p) &lt;=  1._r8) then<a name='4542'>
            temp2(p) = vkc/(log(zldis(p)/z0q(p)) + 5._r8*zeta(p)-5._r8*z0q(p)/obu(p))<a name='4543'>
         else<a name='4544'>
            temp2(p) = vkc/(log(obu(p)/z0q(p)) + 5._r8 - 5._r8*z0q(p)/obu(p) &amp;<a name='4545'>
                 + (5._r8*log(zeta(p))+zeta(p)-1._r8))<a name='4546'>
         end if<a name='4547'>
      endif<a name='4548'>
<a name='4549'>
      <font color=#447700>! Temperature profile applied at 2-m<a name='4550'></font>
<a name='4551'>
      zldis(p) = 2.0_r8 + z0h(p)<a name='4552'>
      zeta(p) = zldis(p)/obu(p)<a name='4553'>
      if (zeta(p) &lt; -zetat) then<a name='4554'>
         temp12m(p) = vkc/(log(-zetat*obu(p)/z0h(p))&amp;<a name='4555'>
              - StabilityFunc2(-zetat) &amp;<a name='4556'>
              + StabilityFunc2(z0h(p)/obu(p)) &amp;<a name='4557'>
              + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta(p))**(-0.333_r8)))<a name='4558'>
      else if (zeta(p) &lt; 0._r8) then<a name='4559'>
         temp12m(p) = vkc/(log(zldis(p)/z0h(p)) &amp;<a name='4560'>
              - StabilityFunc2(zeta(p))  &amp;<a name='4561'>
              + StabilityFunc2(z0h(p)/obu(p)))<a name='4562'>
      else if (zeta(p) &lt;=  1._r8) then<a name='4563'>
         temp12m(p) = vkc/(log(zldis(p)/z0h(p)) + 5._r8*zeta(p) - 5._r8*z0h(p)/obu(p))<a name='4564'>
      else<a name='4565'>
         temp12m(p) = vkc/(log(obu(p)/z0h(p)) + 5._r8 - 5._r8*z0h(p)/obu(p) &amp;<a name='4566'>
              + (5._r8*log(zeta(p))+zeta(p)-1._r8))<a name='4567'>
      end if<a name='4568'>
<a name='4569'>
      <font color=#447700>! Humidity profile applied at 2-m<a name='4570'></font>
<a name='4571'>
      if (z0q(p) == z0h(p)) then<a name='4572'>
         temp22m(p) = temp12m(p)<a name='4573'>
      else<a name='4574'>
         zldis(p) = 2.0_r8 + z0q(p)<a name='4575'>
         zeta(p) = zldis(p)/obu(p)<a name='4576'>
         if (zeta(p) &lt; -zetat) then<a name='4577'>
            temp22m(p) = vkc/(log(-zetat*obu(p)/z0q(p)) - &amp;<a name='4578'>
                 StabilityFunc2(-zetat) + StabilityFunc2(z0q(p)/obu(p)) &amp;<a name='4579'>
                 + 0.8_r8*((zetat)**(-0.333_r8)-(-zeta(p))**(-0.333_r8)))<a name='4580'>
         else if (zeta(p) &lt; 0._r8) then<a name='4581'>
            temp22m(p) = vkc/(log(zldis(p)/z0q(p)) - &amp;<a name='4582'>
                 StabilityFunc2(zeta(p))+StabilityFunc2(z0q(p)/obu(p)))<a name='4583'>
         else if (zeta(p) &lt;=  1._r8) then<a name='4584'>
            temp22m(p) = vkc/(log(zldis(p)/z0q(p)) + 5._r8*zeta(p)-5._r8*z0q(p)/obu(p))<a name='4585'>
         else<a name='4586'>
            temp22m(p) = vkc/(log(obu(p)/z0q(p)) + 5._r8 - 5._r8*z0q(p)/obu(p) &amp;<a name='4587'>
                 + (5._r8*log(zeta(p))+zeta(p)-1._r8))<a name='4588'>
         end if<a name='4589'>
      end if<a name='4590'>
<a name='4591'>
#if (defined DGVM) || (defined DUST)<a name='4592'>
      <font color=#447700>! diagnose 10-m wind for dust model (dstmbl.F)<a name='4593'></font>
      <font color=#447700>! Notes from C. Zender's dst.F:<a name='4594'></font>
      <font color=#447700>! According to Bon96 p. 62, the displacement height d (here displa) is<a name='4595'></font>
      <font color=#447700>! 0.0 &lt;= d &lt;= 0.34 m in dust source regions (i.e., regions w/o trees).<a name='4596'></font>
      <font color=#447700>! Therefore d &lt;= 0.034*z1 and may safely be neglected.<a name='4597'></font>
      <font color=#447700>! Code from LSM routine SurfaceTemperature was used to obtain u10<a name='4598'></font>
<a name='4599'>
      zldis(p) = forc_hgt_u(g)-displa(p)<a name='4600'>
      zeta(p) = zldis(p)/obu(p)<a name='4601'>
      if (min(zeta(p), 1._r8) &lt; 0._r8) then<a name='4602'>
         tmp1 = (1._r8 - 16._r8*min(zeta(p),1._r8))**0.25_r8<a name='4603'>
         tmp2 = log((1._r8+tmp1*tmp1)/2._r8)<a name='4604'>
         tmp3 = log((1._r8+tmp1)/2._r8)<a name='4605'>
         fmnew = 2._r8*tmp3 + tmp2 - 2._r8*atan(tmp1) + 1.5707963_r8<a name='4606'>
      else<a name='4607'>
         fmnew = -5._r8*min(zeta(p),1._r8)<a name='4608'>
      endif<a name='4609'>
      if (iter == 1) then<a name='4610'>
         fm(p) = fmnew<a name='4611'>
      else<a name='4612'>
         fm(p) = 0.5_r8 * (fm(p)+fmnew)<a name='4613'>
      end if<a name='4614'>
      zeta10 = min(10._r8/obu(p), 1._r8)<a name='4615'>
      if (zeta(p) == 0._r8) zeta10 = 0._r8<a name='4616'>
      if (zeta10 &lt; 0._r8) then<a name='4617'>
         tmp1 = (1.0_r8 - 16.0_r8 * zeta10)**0.25_r8<a name='4618'>
         tmp2 = log((1.0_r8 + tmp1*tmp1)/2.0_r8)<a name='4619'>
         tmp3 = log((1.0_r8 + tmp1)/2.0_r8)<a name='4620'>
         fm10 = 2.0_r8*tmp3 + tmp2 - 2.0_r8*atan(tmp1) + 1.5707963_r8<a name='4621'>
      else                <font color=#447700>! not stable<a name='4622'></font>
         fm10 = -5.0_r8 * zeta10<a name='4623'>
      end if<a name='4624'>
      tmp4 = log(forc_hgt(g) / 10._r8)<a name='4625'>
      u10(p) = ur(p) - ustar(p)/vkc * (tmp4 - fm(p) + fm10)<a name='4626'>
      fv(p)  = ustar(p)<a name='4627'>
#endif<a name='4628'>
<a name='4629'>
   end do<a name='4630'>
#endif<a name='4631'>
<a name='4632'>
<a name='4633'>
#if (defined PERGRO)<a name='4634'>
<a name='4635'>
   <font color=#447700>!===============================================================================<a name='4636'></font>
   <font color=#447700>! The following only applies when PERGRO is defined<a name='4637'></font>
   <font color=#447700>!===============================================================================<a name='4638'></font>
<a name='4639'>
<font color=#447700>!dir$ concurrent<a name='4640'></font>
<font color=#447700>!cdir nodep<a name='4641'></font>
   do f = 1, fn<a name='4642'>
      p = filterp(f)<a name='4643'>
      g = pgridcell(p)<a name='4644'>
<a name='4645'>
      zldis(p) = forc_hgt_u(g)-displa(p)<a name='4646'>
      zeta(p) = zldis(p)/obu(p)<a name='4647'>
      if (zeta(p) &lt; -zetam) then           <font color=#447700>! zeta &lt; -1<a name='4648'></font>
         ustar(p) = vkc * um(p) / log(-zetam*obu(p)/z0m(p))<a name='4649'>
      else if (zeta(p) &lt; 0._r8) then         <font color=#447700>! -1 &lt;= zeta &lt; 0<a name='4650'></font>
         ustar(p) = vkc * um(p) / log(zldis(p)/z0m(p))<a name='4651'>
      else if (zeta(p) &lt;= 1._r8) then        <font color=#447700>!  0 &lt;= ztea &lt;= 1<a name='4652'></font>
         ustar(p)=vkc * um(p)/log(zldis(p)/z0m(p))<a name='4653'>
      else                             <font color=#447700>!  1 &lt; zeta, phi=5+zeta<a name='4654'></font>
         ustar(p)=vkc * um(p)/log(obu(p)/z0m(p))<a name='4655'>
      endif<a name='4656'>
<a name='4657'>
      zldis(p) = forc_hgt_t(g)-displa(p)<a name='4658'>
      zeta(p) = zldis(p)/obu(p)<a name='4659'>
      if (zeta(p) &lt; -zetat) then<a name='4660'>
         temp1(p)=vkc/log(-zetat*obu(p)/z0h(p))<a name='4661'>
      else if (zeta(p) &lt; 0._r8) then<a name='4662'>
         temp1(p)=vkc/log(zldis(p)/z0h(p))<a name='4663'>
      else if (zeta(p) &lt;= 1._r8) then<a name='4664'>
         temp1(p)=vkc/log(zldis(p)/z0h(p))<a name='4665'>
      else<a name='4666'>
         temp1(p)=vkc/log(obu(p)/z0h(p))<a name='4667'>
      end if<a name='4668'>
<a name='4669'>
      zldis(p) = forc_hgt_q(g)-displa(p)<a name='4670'>
      zeta(p) = zldis(p)/obu(p)<a name='4671'>
      if (zeta(p) &lt; -zetat) then<a name='4672'>
         temp2(p)=vkc/log(-zetat*obu(p)/z0q(p))<a name='4673'>
      else if (zeta(p) &lt; 0._r8) then<a name='4674'>
         temp2(p)=vkc/log(zldis(p)/z0q(p))<a name='4675'>
      else if (zeta(p) &lt;= 1._r8) then<a name='4676'>
         temp2(p)=vkc/log(zldis(p)/z0q(p))<a name='4677'>
      else<a name='4678'>
         temp2(p)=vkc/log(obu(p)/z0q(p))<a name='4679'>
      end if<a name='4680'>
<a name='4681'>
      zldis(p) = 2.0_r8 + z0h(p)<a name='4682'>
      zeta(p) = zldis(p)/obu(p)<a name='4683'>
      if (zeta(p) &lt; -zetat) then<a name='4684'>
         temp12m(p)=vkc/log(-zetat*obu(p)/z0h(p))<a name='4685'>
      else if (zeta(p) &lt; 0._r8) then<a name='4686'>
         temp12m(p)=vkc/log(zldis(p)/z0h(p))<a name='4687'>
      else if (zeta(p) &lt;= 1._r8) then<a name='4688'>
         temp12m(p)=vkc/log(zldis(p)/z0h(p))<a name='4689'>
      else<a name='4690'>
         temp12m(p)=vkc/log(obu(p)/z0h(p))<a name='4691'>
      end if<a name='4692'>
<a name='4693'>
      zldis(p) = 2.0_r8 + z0q(p)<a name='4694'>
      zeta(p) = zldis(p)/obu(p)<a name='4695'>
      if (zeta(p) &lt; -zetat) then<a name='4696'>
         temp22m(p)=vkc/log(-zetat*obu(p)/z0q(p))<a name='4697'>
      else if (zeta(p) &lt; 0._r8) then<a name='4698'>
         temp22m(p)=vkc/log(zldis(p)/z0q(p))<a name='4699'>
      else if (zeta(p) &lt;= 1._r8) then<a name='4700'>
         temp22m(p)=vkc/log(zldis(p)/z0q(p))<a name='4701'>
      else<a name='4702'>
         temp22m(p)=vkc/log(obu(p)/z0q(p))<a name='4703'>
      end if<a name='4704'>
#if (defined DGVM) || (defined DUST)<a name='4705'>
      <font color=#447700>! diagnose 10-m wind for dust model (dstmbl.F)<a name='4706'></font>
      <font color=#447700>! Notes from C. Zender's dst.F:<a name='4707'></font>
      <font color=#447700>! According to Bon96 p. 62, the displacement height d (here displa) is<a name='4708'></font>
      <font color=#447700>! 0.0 &lt;= d &lt;= 0.34 m in dust source regions (i.e., regions w/o trees).<a name='4709'></font>
      <font color=#447700>! Therefore d &lt;= 0.034*z1 and may safely be neglected.<a name='4710'></font>
      <font color=#447700>! Code from LSM routine SurfaceTemperature was used to obtain u10<a name='4711'></font>
<a name='4712'>
      zldis(p) = forc_hgt_u(g)-displa(p)<a name='4713'>
      zeta(p) = zldis(p)/obu(p)<a name='4714'>
      if (min(zeta(p), 1._r8) &lt; 0._r8) then<a name='4715'>
         tmp1 = (1._r8 - 16._r8*min(zeta(p),1._r8))**0.25_r8<a name='4716'>
         tmp2 = log((1._r8+tmp1*tmp1)/2._r8)<a name='4717'>
         tmp3 = log((1._r8+tmp1)/2._r8)<a name='4718'>
         fmnew = 2._r8*tmp3 + tmp2 - 2._r8*atan(tmp1) + 1.5707963_r8<a name='4719'>
      else<a name='4720'>
         fmnew = -5._r8*min(zeta(p),1._r8)<a name='4721'>
      endif<a name='4722'>
      if (iter == 1) then<a name='4723'>
         fm(p) = fmnew<a name='4724'>
      else<a name='4725'>
         fm(p) = 0.5_r8 * (fm(p)+fmnew)<a name='4726'>
      end if<a name='4727'>
      zeta10 = min(10._r8/obu(p), 1._r8)<a name='4728'>
      if (zeta(p) == 0._r8) zeta10 = 0._r8<a name='4729'>
      if (zeta10 &lt; 0._r8) then<a name='4730'>
         tmp1 = (1.0_r8 - 16.0_r8 * zeta10)**0.25_r8<a name='4731'>
         tmp2 = log((1.0_r8 + tmp1*tmp1)/2.0_r8)<a name='4732'>
         tmp3 = log((1.0_r8 + tmp1)/2.0_r8)<a name='4733'>
         fm10 = 2.0_r8*tmp3 + tmp2 - 2.0_r8*atan(tmp1) + 1.5707963_r8<a name='4734'>
      else                <font color=#447700>! not stable<a name='4735'></font>
         fm10 = -5.0_r8 * zeta10<a name='4736'>
      end if<a name='4737'>
      tmp4 = log(forc_hgt(g) / 10._r8)<a name='4738'>
      u10(p) = ur(p) - ustar(p)/vkc * (tmp4 - fm(p) + fm10)<a name='4739'>
      fv(p)  = ustar(p)<a name='4740'>
#endif<a name='4741'>
   end do<a name='4742'>
<a name='4743'>
#endif<a name='4744'>
<a name='4745'>
   end subroutine FrictionVelocity<a name='4746'>
<a name='4747'>
<font color=#447700>! !IROUTINE: StabilityFunc<a name='4748'></font>
<font color=#447700>!<a name='4749'></font>
<font color=#447700>! !INTERFACE:<a name='4750'></font>
<A NAME='STABILITYFUNC1'><A href='../../html_code/phys/module_sf_lake.F.html#STABILITYFUNC1' TARGET='top_target'><IMG SRC="../../gif/bar_green.gif" border=0></A><a name='4751'>
   real(r8) <font color=#993300>function </font><font color=#cc0000>StabilityFunc1</font>(zeta),<A href='../../call_from/STABILITYFUNC1.html' TARGET='index'>1</A><a name='4752'>
<font color=#447700>!<a name='4753'></font>
<font color=#447700>! !DESCRIPTION:<a name='4754'></font>
<font color=#447700>! Stability function for rib &lt; 0.<a name='4755'></font>
<font color=#447700>!<a name='4756'></font>
<font color=#447700>! !USES:<a name='4757'></font>
<font color=#447700>!      use shr_const_mod, only: SHR_CONST_PI<a name='4758'></font>
<font color=#447700>!Zack Subin, 7/8/08<a name='4759'></font>
<font color=#447700>!<a name='4760'></font>
<font color=#447700>! !ARGUMENTS:<a name='4761'></font>
      implicit none<a name='4762'>
      real(r8), intent(in) :: zeta  <font color=#447700>! dimensionless height used in Monin-Obukhov theory<a name='4763'></font>
<font color=#447700>!<a name='4764'></font>
<font color=#447700>! !CALLED FROM:<a name='4765'></font>
<font color=#447700>! subroutine FrictionVelocity in this module<a name='4766'></font>
<font color=#447700>!<a name='4767'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4768'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='4769'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='4770'></font>
<font color=#447700>!<a name='4771'></font>
<font color=#447700>!EOP<a name='4772'></font>
<font color=#447700>!<a name='4773'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='4774'></font>
      real(r8) :: chik, chik2<a name='4775'>
<font color=#447700>!------------------------------------------------------------------------------<a name='4776'></font>
<a name='4777'>
      chik2 = sqrt(1._r8-16._r8*zeta)<a name='4778'>
      chik = sqrt(chik2)<a name='4779'>
      StabilityFunc1 = 2._r8*log((1._r8+chik)*0.5_r8) &amp;<a name='4780'>
<font color=#447700>!Changed to pie, Zack Subin, 7/9/08<a name='4781'></font>
           + log((1._r8+chik2)*0.5_r8)-2._r8*atan(chik)+pie*0.5_r8<a name='4782'>
<a name='4783'>
    end function StabilityFunc1<a name='4784'>
<a name='4785'>
<font color=#447700>!------------------------------------------------------------------------------<a name='4786'></font>
<font color=#447700>!BOP<a name='4787'></font>
<font color=#447700>!<a name='4788'></font>
<font color=#447700>! !IROUTINE: StabilityFunc2<a name='4789'></font>
<font color=#447700>!<a name='4790'></font>
<font color=#447700>! !INTERFACE:<a name='4791'></font>
<A NAME='STABILITYFUNC2'><A href='../../html_code/phys/module_sf_lake.F.html#STABILITYFUNC2' TARGET='top_target'><IMG SRC="../../gif/bar_green.gif" border=0></A><a name='4792'>
   real(r8) <font color=#993300>function </font><font color=#cc0000>StabilityFunc2</font>(zeta),<A href='../../call_from/STABILITYFUNC2.html' TARGET='index'>1</A><a name='4793'>
<font color=#447700>!<a name='4794'></font>
<font color=#447700>! !DESCRIPTION:<a name='4795'></font>
<font color=#447700>! Stability function for rib &lt; 0.<a name='4796'></font>
<font color=#447700>!<a name='4797'></font>
<font color=#447700>! !USES:<a name='4798'></font>
<font color=#447700>!Removed by Zack Subin, 7/9/08<a name='4799'></font>
<font color=#447700>!     use shr_const_mod, only: SHR_CONST_PI<a name='4800'></font>
<font color=#447700>!<a name='4801'></font>
<font color=#447700>! !ARGUMENTS:<a name='4802'></font>
     implicit none<a name='4803'>
     real(r8), intent(in) :: zeta  <font color=#447700>! dimensionless height used in Monin-Obukhov theory<a name='4804'></font>
<font color=#447700>!<a name='4805'></font>
<font color=#447700>! !CALLED FROM:<a name='4806'></font>
<font color=#447700>! subroutine FrictionVelocity in this module<a name='4807'></font>
<font color=#447700>!<a name='4808'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4809'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='4810'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='4811'></font>
<font color=#447700>!<a name='4812'></font>
<font color=#447700>!EOP<a name='4813'></font>
<font color=#447700>!<a name='4814'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='4815'></font>
     real(r8) :: chik2<a name='4816'>
<font color=#447700>!------------------------------------------------------------------------------<a name='4817'></font>
<a name='4818'>
     chik2 = sqrt(1._r8-16._r8*zeta)<a name='4819'>
     StabilityFunc2 = 2._r8*log((1._r8+chik2)*0.5_r8)<a name='4820'>
<a name='4821'>
   end function StabilityFunc2<a name='4822'>
<a name='4823'>
<font color=#447700>!-----------------------------------------------------------------------<a name='4824'></font>
<font color=#447700>!BOP<a name='4825'></font>
<font color=#447700>!<a name='4826'></font>
<font color=#447700>! !IROUTINE: MoninObukIni<a name='4827'></font>
<font color=#447700>!<a name='4828'></font>
<font color=#447700>! !INTERFACE:<a name='4829'></font>
<A NAME='MONINOBUKINI'><A href='../../html_code/phys/module_sf_lake.F.html#MONINOBUKINI' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4830'>
  <font color=#993300>subroutine </font><font color=#cc0000>MoninObukIni</font> (ur, thv, dthv, zldis, z0m, um, obu) <A href='../../call_to/MONINOBUKINI.html' TARGET='index'>4</A>,<A href='../../call_from/MONINOBUKINI.html' TARGET='index'>1</A><a name='4831'>
<font color=#447700>!<a name='4832'></font>
<font color=#447700>! !DESCRIPTION:<a name='4833'></font>
<font color=#447700>! Initialization of the Monin-Obukhov length.<a name='4834'></font>
<font color=#447700>! The scheme is based on the work of Zeng et al. (1998):<a name='4835'></font>
<font color=#447700>! Intercomparison of bulk aerodynamic algorithms for the computation<a name='4836'></font>
<font color=#447700>! of sea surface fluxes using TOGA CORE and TAO data. J. Climate,<a name='4837'></font>
<font color=#447700>! Vol. 11, 2628-2644.<a name='4838'></font>
<font color=#447700>!<a name='4839'></font>
<font color=#447700>! !USES:<a name='4840'></font>
<font color=#447700>!<a name='4841'></font>
<font color=#447700>! !ARGUMENTS:<a name='4842'></font>
    implicit none<a name='4843'>
    real(r8), intent(in)  :: ur    <font color=#447700>! wind speed at reference height [m/s]<a name='4844'></font>
    real(r8), intent(in)  :: thv   <font color=#447700>! virtual potential temperature (kelvin)<a name='4845'></font>
    real(r8), intent(in)  :: dthv  <font color=#447700>! diff of vir. poten. temp. between ref. height and surface<a name='4846'></font>
    real(r8), intent(in)  :: zldis <font color=#447700>! reference height "minus" zero displacement heght [m]<a name='4847'></font>
    real(r8), intent(in)  :: z0m   <font color=#447700>! roughness length, momentum [m]<a name='4848'></font>
    real(r8), intent(out) :: um    <font color=#447700>! wind speed including the stability effect [m/s]<a name='4849'></font>
    real(r8), intent(out) :: obu   <font color=#447700>! monin-obukhov length (m)<a name='4850'></font>
<font color=#447700>!<a name='4851'></font>
<font color=#447700>! !CALLED FROM:<a name='4852'></font>
<font color=#447700>! subroutine BareGroundFluxes in module BareGroundFluxesMod.F90<a name='4853'></font>
<font color=#447700>! subroutine BiogeophysicsLake in module BiogeophysicsLakeMod.F90<a name='4854'></font>
<font color=#447700>! subroutine CanopyFluxes in module CanopyFluxesMod.F90<a name='4855'></font>
<font color=#447700>!<a name='4856'></font>
<font color=#447700>! !REVISION HISTORY:<a name='4857'></font>
<font color=#447700>! 15 September 1999: Yongjiu Dai; Initial code<a name='4858'></font>
<font color=#447700>! 15 December 1999:  Paul Houser and Jon Radakovich; F90 Revision<a name='4859'></font>
<font color=#447700>!<a name='4860'></font>
<font color=#447700>!EOP<a name='4861'></font>
<font color=#447700>!<a name='4862'></font>
<font color=#447700>! !LOCAL VARIABLES:<a name='4863'></font>
<font color=#447700>!<a name='4864'></font>
    real(r8) :: wc    <font color=#447700>! convective velocity [m/s]<a name='4865'></font>
    real(r8) :: rib   <font color=#447700>! bulk Richardson number<a name='4866'></font>
    real(r8) :: zeta  <font color=#447700>! dimensionless height used in Monin-Obukhov theory<a name='4867'></font>
    real(r8) :: ustar <font color=#447700>! friction velocity [m/s]<a name='4868'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='4869'></font>
<a name='4870'>
    <font color=#447700>! Initial values of u* and convective velocity<a name='4871'></font>
<a name='4872'>
    ustar=0.06_r8<a name='4873'>
    wc=0.5_r8<a name='4874'>
    if (dthv &gt;= 0._r8) then<a name='4875'>
       um=max(ur,0.1_r8)<a name='4876'>
    else<a name='4877'>
       um=sqrt(ur*ur+wc*wc)<a name='4878'>
    endif<a name='4879'>
<a name='4880'>
    rib=grav*zldis*dthv/(thv*um*um)<a name='4881'>
#if (defined PERGRO)<a name='4882'>
    rib = 0._r8<a name='4883'>
#endif<a name='4884'>
<a name='4885'>
    if (rib &gt;= 0._r8) then      <font color=#447700>! neutral or stable<a name='4886'></font>
       zeta = rib*log(zldis/z0m)/(1._r8-5._r8*min(rib,0.19_r8))<a name='4887'>
       zeta = min(2._r8,max(zeta,0.01_r8 ))<a name='4888'>
    else                     <font color=#447700>! unstable<a name='4889'></font>
       zeta=rib*log(zldis/z0m)<a name='4890'>
       zeta = max(-100._r8,min(zeta,-0.01_r8 ))<a name='4891'>
    endif<a name='4892'>
<a name='4893'>
    obu=zldis/zeta<a name='4894'>
<a name='4895'>
  end subroutine MoninObukIni<a name='4896'>
<a name='4897'>
<A NAME='LAKEDEBUG'><A href='../../html_code/phys/module_sf_lake.F.html#LAKEDEBUG' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4898'>
<font color=#993300>subroutine </font><font color=#cc0000>LakeDebug</font>( str ) ,<A href='../../call_from/LAKEDEBUG.html' TARGET='index'>1</A><a name='4899'>
 <a name='4900'>
  IMPLICIT NONE<a name='4901'>
  CHARACTER*(*), str<a name='4902'>
 <a name='4903'>
  CALL <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEDEBUG' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_830">( 0 , TRIM(str) )<a name='4904'>
 <a name='4905'>
end subroutine LakeDebug<a name='4906'>
<a name='4907'>
<A NAME='LAKEINI'><A href='../../html_code/phys/module_sf_lake.F.html#LAKEINI' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='4908'>
 <font color=#993300>SUBROUTINE </font><font color=#cc0000>lakeini</font>(IVGTYP,         ISLTYP,          HT,              SNOW,           &amp; <font color=#447700>!i <A href='../../call_to/LAKEINI.html' TARGET='index'>1</A>,<A href='../../call_from/LAKEINI.html' TARGET='index'>3</A><a name='4909'></font>
                    lake_min_elev,     restart,        lakedepth_default, lake_depth,     &amp;<a name='4910'>
                    lakedepth2d,    savedtke12d,     snowdp2d,        h2osno2d,       &amp; <font color=#447700>!o<a name='4911'></font>
                    snl2d,          t_grnd2d,        t_lake3d,        lake_icefrac3d, &amp;<a name='4912'>
                    z_lake3d,       dz_lake3d,       t_soisno3d,      h2osoi_ice3d,   &amp;<a name='4913'>
                    h2osoi_liq3d,   h2osoi_vol3d,    z3d,             dz3d,           &amp;<a name='4914'>
                    zi3d,           watsat3d,        csol3d,          tkmg3d,         &amp;<a name='4915'>
                    iswater,        xice,            xice_threshold,  xland,   tsk,   &amp;<a name='4916'>
#if (EM_CORE == 1)<a name='4917'>
                    lakemask,       lakeflag,                                         &amp;<a name='4918'>
#endif<a name='4919'>
                    lake_depth_flag, use_lakedepth,                                   &amp;<a name='4920'>
                    tkdry3d,        tksatu3d,        lake,            its, ite, jts, jte, &amp;<a name='4921'>
                    ims,ime, jms,jme)<a name='4922'>
<a name='4923'>
<font color=#447700>!==============================================================================<a name='4924'></font>
<font color=#447700>! This subroutine was first edited by Hongping Gu for coupling<a name='4925'></font>
<font color=#447700>! 07/20/2010<a name='4926'></font>
<font color=#447700>!==============================================================================<a name='4927'></font>
<a name='4928'>
  USE <A href='../../html_code/frame/module_wrf_error.F.html#MODULE_WRF_ERROR'>module_wrf_error</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEINI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_WRF_ERROR_86"><a name='4929'>
  implicit none<a name='4930'>
<a name='4931'>
  INTEGER , INTENT (IN) :: iswater<a name='4932'>
  REAL,     INTENT(IN)  :: xice_threshold<a name='4933'>
  REAL, DIMENSION( ims:ime , jms:jme ), INTENT(INOUT)::   XICE<a name='4934'>
  REAL, DIMENSION( ims:ime , jms:jme ), INTENT(IN)::      TSK<a name='4935'>
  REAL, DIMENSION( ims:ime, jms:jme )  ,INTENT(INOUT)  :: XLAND<a name='4936'>
<a name='4937'>
#if (EM_CORE == 1)<a name='4938'>
  REAL, DIMENSION( ims:ime , jms:jme ) ::   LAKEMASK<a name='4939'>
  INTEGER , INTENT (IN) :: lakeflag<a name='4940'>
#endif<a name='4941'>
  INTEGER , INTENT (INOUT) :: lake_depth_flag<a name='4942'>
  INTEGER , INTENT (IN) ::   use_lakedepth<a name='4943'>
<a name='4944'>
  LOGICAL , INTENT(IN)      ::     restart<a name='4945'>
  INTEGER,  INTENT(IN   )   ::     ims,ime, jms,jme<a name='4946'>
  INTEGER,  INTENT(IN   )   ::     its,ite, jts,jte<a name='4947'>
  INTEGER, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)       :: IVGTYP,       &amp;<a name='4948'>
                                                              ISLTYP<a name='4949'>
  REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(IN)       :: HT<a name='4950'>
  REAL,    DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)    :: SNOW<a name='4951'>
  real,    intent(in)                                      :: lakedepth_default,lake_min_elev<a name='4952'>
<a name='4953'>
  real,    dimension(ims:ime,jms:jme ),intent(out)                        :: lakedepth2d,    &amp;<a name='4954'>
                                                                             savedtke12d<a name='4955'>
  real,    dimension(ims:ime,jms:jme ),intent(out)                        :: snowdp2d,       &amp;<a name='4956'>
                                                                             h2osno2d,       &amp;<a name='4957'>
                                                                             snl2d,          &amp;<a name='4958'>
                                                                             t_grnd2d<a name='4959'>
                                                                              <a name='4960'>
  real,    dimension( ims:ime,1:nlevlake, jms:jme ),INTENT(out)            :: t_lake3d,       &amp;<a name='4961'>
                                                                             lake_icefrac3d, &amp;<a name='4962'>
                                                                             z_lake3d,       &amp;<a name='4963'>
                                                                             dz_lake3d<a name='4964'>
  real,    dimension( ims:ime,-nlevsnow+1:nlevsoil, jms:jme ),INTENT(out)   :: t_soisno3d,     &amp;<a name='4965'>
                                                                             h2osoi_ice3d,   &amp;<a name='4966'>
                                                                             h2osoi_liq3d,   &amp;<a name='4967'>
                                                                             h2osoi_vol3d,   &amp;<a name='4968'>
                                                                             z3d,            &amp;<a name='4969'>
                                                                             dz3d<a name='4970'>
  real,    dimension( ims:ime,1:nlevsoil, jms:jme ),INTENT(out)            :: watsat3d,       &amp;<a name='4971'>
                                                                             csol3d,         &amp;<a name='4972'>
                                                                             tkmg3d,         &amp;<a name='4973'>
                                                                             tkdry3d,        &amp;<a name='4974'>
                                                                             tksatu3d<a name='4975'>
  real,    dimension( ims:ime,-nlevsnow+0:nlevsoil, jms:jme ),INTENT(out)   :: zi3d            <a name='4976'>
<a name='4977'>
  LOGICAL, DIMENSION( ims:ime, jms:jme ),intent(out)                      :: lake<a name='4978'>
  REAL, OPTIONAL,    DIMENSION( ims:ime, jms:jme ), INTENT(IN)    ::  lake_depth<a name='4979'>
<a name='4980'>
  real,    dimension( ims:ime,1:nlevsoil, jms:jme )   :: bsw3d,    &amp;<a name='4981'>
                                                        bsw23d,   &amp;<a name='4982'>
                                                        psisat3d, &amp;<a name='4983'>
                                                        vwcsat3d, &amp;<a name='4984'>
                                                        watdry3d, &amp;<a name='4985'>
                                                        watopt3d, &amp;<a name='4986'>
                                                        hksat3d,  &amp;<a name='4987'>
                                                        sucsat3d, &amp;<a name='4988'>
                                                        clay3d,   &amp;<a name='4989'>
                                                        sand3d   <a name='4990'>
  integer  :: n,i,j,k,ib,lev,bottom      <font color=#447700>! indices<a name='4991'></font>
  real(r8),dimension(ims:ime,jms:jme )    :: bd2d               <font color=#447700>! bulk density of dry soil material [kg/m^3]<a name='4992'></font>
  real(r8),dimension(ims:ime,jms:jme )    :: tkm2d              <font color=#447700>! mineral conductivity<a name='4993'></font>
  real(r8),dimension(ims:ime,jms:jme )    :: xksat2d            <font color=#447700>! maximum hydraulic conductivity of soil [mm/s]<a name='4994'></font>
  real(r8),dimension(ims:ime,jms:jme )    :: depthratio2d       <font color=#447700>! ratio of lake depth to standard deep lake depth <a name='4995'></font>
  real(r8),dimension(ims:ime,jms:jme )    :: clay2d             <font color=#447700>! temporary<a name='4996'></font>
  real(r8),dimension(ims:ime,jms:jme )    :: sand2d             <font color=#447700>! temporary<a name='4997'></font>
<a name='4998'>
  real(r8)                 :: scalez  = 0.025_r8   <font color=#447700>! Soil layer thickness discretization (m)<a name='4999'></font>
  logical,parameter        :: arbinit = .true.<a name='5000'>
  real,parameter           :: defval  = -999.0<a name='5001'>
  integer                  :: isl<a name='5002'>
  integer                  :: numb_lak    <font color=#447700>! for debug<a name='5003'></font>
  character*256 :: message<a name='5004'>
<a name='5005'>
  IF ( RESTART ) RETURN <a name='5006'>
<a name='5007'>
  DO j = jts,jte<a name='5008'>
  DO i = its,ite<a name='5009'>
        snowdp2d(i,j)         = snow(i,j)*0.005               <font color=#447700>! SNOW in kg/m^2 and snowdp in m<a name='5010'></font>
	h2osno2d(i,j)         = snow(i,j) <font color=#447700>! mm <a name='5011'></font>
  ENDDO<a name='5012'>
  ENDDO<a name='5013'>
<a name='5014'>
<font color=#447700>! initialize all the grid with default value <a name='5015'></font>
  DO j = jts,jte<a name='5016'>
  DO i = its,ite<a name='5017'>
<a name='5018'>
    lakedepth2d(i,j)             = defval<a name='5019'>
    snl2d(i,j)                   = defval<a name='5020'>
    do k = -nlevsnow+1,nlevsoil<a name='5021'>
        h2osoi_liq3d(i,k,j)      = defval<a name='5022'>
        h2osoi_ice3d(i,k,j)      = defval<a name='5023'>
	t_soisno3d(i,k,j)        = defval<a name='5024'>
        z3d(i,k,j)               = defval <a name='5025'>
        dz3d(i,k,j)              = defval                           <a name='5026'>
    enddo<a name='5027'>
    do k = 1,nlevlake <a name='5028'>
	t_lake3d(i,k,j)          = defval<a name='5029'>
        lake_icefrac3d(i,k,j)    = defval<a name='5030'>
        z_lake3d(i,k,j)          = defval<a name='5031'>
        dz_lake3d(i,k,j)         = defval<a name='5032'>
    enddo<a name='5033'>
<a name='5034'>
  ENDDO<a name='5035'>
  ENDDO<a name='5036'>
<a name='5037'>
<font color=#447700>! judge whether the grid is lake grid<a name='5038'></font>
   numb_lak = 0<a name='5039'>
       do i=its,ite<a name='5040'>
         do j=jts,jte<a name='5041'>
#if (EM_CORE==1)<a name='5042'>
         IF (lakeflag.eq.0) THEN    <a name='5043'>
            if(ht(i,j)&gt;=lake_min_elev) then <a name='5044'>
              if ( xice(i,j).gt.xice_threshold) then   <font color=#447700>!mchen<a name='5045'></font>
                   ivgtyp(i,j) = iswater<a name='5046'>
                   xland(i,j) = 2. <a name='5047'>
                   lake_icefrac3d(i,1,j) = xice(i,j)<a name='5048'>
                   xice(i,j)=0.0<a name='5049'>
               endif<a name='5050'>
            endif<a name='5051'>
<a name='5052'>
            if(ivgtyp(i,j)==iswater.and.ht(i,j)&gt;=lake_min_elev) then <a name='5053'>
                lake(i,j)  = .true.<a name='5054'>
                lakemask(i,j) = 1<a name='5055'>
                numb_lak   = numb_lak + 1<a name='5056'>
            else <a name='5057'>
                lake(i,j)  = .false.<a name='5058'>
                lakemask(i,j) = 0<a name='5059'>
            end if<a name='5060'>
          ELSE<a name='5061'>
            if(lakemask(i,j).eq.1) then <a name='5062'>
                lake(i,j)  = .true.<a name='5063'>
                numb_lak   = numb_lak + 1<a name='5064'>
                if ( xice(i,j).gt.xice_threshold) then   <font color=#447700>!mchen<a name='5065'></font>
                   ivgtyp(i,j) = iswater<a name='5066'>
                   xland(i,j) = 2. <a name='5067'>
                   lake_icefrac3d(i,1,j) = xice(i,j)<a name='5068'>
                   xice(i,j)=0.0<a name='5069'>
                endif<a name='5070'>
             else  <a name='5071'>
                lake(i,j)  = .false.<a name='5072'>
             endif<a name='5073'>
         ENDIF   <font color=#447700>! end if lakeflag=0<a name='5074'></font>
#else<a name='5075'>
            if(ht(i,j)&gt;=lake_min_elev) then <a name='5076'>
              if ( xice(i,j).gt.xice_threshold) then   <font color=#447700>!mchen<a name='5077'></font>
                   ivgtyp(i,j) = iswater<a name='5078'>
                   xland(i,j) = 2. <a name='5079'>
                   lake_icefrac3d(i,1,j) = xice(i,j)<a name='5080'>
                   xice(i,j)=0.0<a name='5081'>
               endif<a name='5082'>
            endif<a name='5083'>
            if(ivgtyp(i,j)==iswater.and.ht(i,j)&gt;=lake_min_elev) then <a name='5084'>
                lake(i,j)  = .true.<a name='5085'>
                numb_lak   = numb_lak + 1<a name='5086'>
            else <a name='5087'>
                lake(i,j)  = .false.<a name='5088'>
            end if<a name='5089'>
<a name='5090'>
#endif<a name='5091'>
        end do<a name='5092'>
       end do<a name='5093'>
    write(message,*) "the total number of lake grid is :", numb_lak<a name='5094'>
    CALL <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEINI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_907">(message)<a name='5095'>
<font color=#447700>!    CALL LakeDebug(msg)<a name='5096'></font>
<font color=#447700>! initialize lake grid <a name='5097'></font>
<a name='5098'>
  DO j = jts,jte<a name='5099'>
  DO i = its,ite<a name='5100'>
<a name='5101'>
     if ( lake(i,j) ) then<a name='5102'>
<a name='5103'>
<font color=#447700>!	t_soisno3d(i,:,j)      = tsk(i,j)<a name='5104'></font>
<font color=#447700>!        t_lake3d(i,:,j)        = tsk(i,j)<a name='5105'></font>
<font color=#447700>!        t_grnd2d(i,j)          = tsk(i,j)<a name='5106'></font>
<a name='5107'>
        z3d(i,:,j)             = 0.0<a name='5108'>
        dz3d(i,:,j)            = 0.0<a name='5109'>
        zi3d(i,:,j)            = 0.0<a name='5110'>
        h2osoi_liq3d(i,:,j)    = 0.0<a name='5111'>
        h2osoi_ice3d(i,:,j)    = 0.0<a name='5112'>
        lake_icefrac3d(i,:,j)  = 0.0<a name='5113'>
        h2osoi_vol3d(i,:,j)    = 0.0<a name='5114'>
        snl2d(i,j)             = 0.0<a name='5115'>
          if ( use_lakedepth.eq.1 .and.lake_depth_flag.eq.0 ) then <font color=#447700>!mchen<a name='5116'></font>
          call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_ERROR_FATAL'>wrf_error_fatal</A><A href='../../html_code/phys/module_sf_lake.F.html#LAKEINI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_ERROR_FATAL_1148"> ( 'STOP: You need lake-depth information. Rerun WPS or set use_lakedepth = 0')<a name='5117'>
          end if<a name='5118'>
          if ( use_lakedepth.eq.0 .and.lake_depth_flag.eq.1 ) then <font color=#447700>!mchen<a name='5119'></font>
          lake_depth_flag = 0 <a name='5120'>
          end if<a name='5121'>
        if ( lake_depth_flag.eq.1 ) then<a name='5122'>
<a name='5123'>
          if (lake_depth(i,j) &gt; 0.0) then <a name='5124'>
            lakedepth2d(i,j)   = lake_depth(i,j)<a name='5125'>
          else<a name='5126'>
            if ( lakedepth_default  &gt; 0.0 ) then<a name='5127'>
               lakedepth2d(i,j)   = lakedepth_default<a name='5128'>
            else <a name='5129'>
               lakedepth2d(i,j)   = spval<a name='5130'>
            endif<a name='5131'>
          endif<a name='5132'>
<a name='5133'>
        else<a name='5134'>
          if ( lakedepth_default  &gt; 0.0 ) then<a name='5135'>
             lakedepth2d(i,j)   = lakedepth_default<a name='5136'>
          else <a name='5137'>
             lakedepth2d(i,j)   = spval<a name='5138'>
          endif<a name='5139'>
        endif<a name='5140'>
     endif<a name='5141'>
<a name='5142'>
  ENDDO<a name='5143'>
  ENDDO <a name='5144'>
<a name='5145'>
  <a name='5146'>
#ifndef EXTRALAKELAYERS   <a name='5147'>
<font color=#447700>!  dzlak(1) = 0.1_r8<a name='5148'></font>
<font color=#447700>!  dzlak(2) = 1._r8<a name='5149'></font>
<font color=#447700>!  dzlak(3) = 2._r8<a name='5150'></font>
<font color=#447700>!  dzlak(4) = 3._r8<a name='5151'></font>
<font color=#447700>!  dzlak(5) = 4._r8<a name='5152'></font>
<font color=#447700>!  dzlak(6) = 5._r8<a name='5153'></font>
<font color=#447700>!  dzlak(7) = 7._r8<a name='5154'></font>
<font color=#447700>!  dzlak(8) = 7._r8<a name='5155'></font>
<font color=#447700>!  dzlak(9) = 10.45_r8<a name='5156'></font>
<font color=#447700>!  dzlak(10)= 10.45_r8<a name='5157'></font>
<font color=#447700>!<a name='5158'></font>
<font color=#447700>!  zlak(1) =  0.05_r8<a name='5159'></font>
<font color=#447700>!  zlak(2) =  0.6_r8<a name='5160'></font>
<font color=#447700>!  zlak(3) =  2.1_r8<a name='5161'></font>
<font color=#447700>!  zlak(4) =  4.6_r8<a name='5162'></font>
<font color=#447700>!  zlak(5) =  8.1_r8<a name='5163'></font>
<font color=#447700>!  zlak(6) = 12.6_r8<a name='5164'></font>
<font color=#447700>!  zlak(7) = 18.6_r8<a name='5165'></font>
<font color=#447700>!  zlak(8) = 25.6_r8<a name='5166'></font>
<font color=#447700>!  zlak(9) = 34.325_r8<a name='5167'></font>
<font color=#447700>!  zlak(10)= 44.775_r8<a name='5168'></font>
  dzlak(1) = 0.1_r8<a name='5169'>
  dzlak(2) = 0.1_r8<a name='5170'>
  dzlak(3) = 0.1_r8<a name='5171'>
  dzlak(4) = 0.1_r8<a name='5172'>
  dzlak(5) = 0.1_r8<a name='5173'>
  dzlak(6) = 0.1_r8<a name='5174'>
  dzlak(7) = 0.1_r8<a name='5175'>
  dzlak(8) = 0.1_r8<a name='5176'>
  dzlak(9) = 0.1_r8<a name='5177'>
  dzlak(10)= 0.1_r8<a name='5178'>
 <a name='5179'>
  zlak(1) =  0.05_r8<a name='5180'>
  zlak(2) =  0.15_r8<a name='5181'>
  zlak(3) =  0.25_r8<a name='5182'>
  zlak(4) =  0.35_r8<a name='5183'>
  zlak(5) =  0.45_r8<a name='5184'>
  zlak(6) = 0.55_r8<a name='5185'>
  zlak(7) = 0.65_r8<a name='5186'>
  zlak(8) = 0.75_r8<a name='5187'>
  zlak(9) = 0.85_r8<a name='5188'>
  zlak(10)= 0.95_r8<a name='5189'>
#else<a name='5190'>
  dzlak(1) =0.1_r8<a name='5191'>
  dzlak(2) =0.25_r8<a name='5192'>
  dzlak(3) =0.25_r8<a name='5193'>
  dzlak(4) =0.25_r8<a name='5194'>
  dzlak(5) =0.25_r8<a name='5195'>
  dzlak(6) =0.5_r8<a name='5196'>
  dzlak(7) =0.5_r8<a name='5197'>
  dzlak(8) =0.5_r8<a name='5198'>
  dzlak(9) =0.5_r8<a name='5199'>
  dzlak(10) =0.75_r8<a name='5200'>
  dzlak(11) =0.75_r8<a name='5201'>
  dzlak(12) =0.75_r8<a name='5202'>
  dzlak(13) =0.75_r8<a name='5203'>
  dzlak(14) =2_r8<a name='5204'>
  dzlak(15) =2_r8<a name='5205'>
  dzlak(16) =2.5_r8<a name='5206'>
  dzlak(17) =2.5_r8<a name='5207'>
  dzlak(18) =3.5_r8<a name='5208'>
  dzlak(19) =3.5_r8<a name='5209'>
  dzlak(20) =3.5_r8<a name='5210'>
  dzlak(21) =3.5_r8<a name='5211'>
  dzlak(22) =5.225_r8<a name='5212'>
  dzlak(23) =5.225_r8<a name='5213'>
  dzlak(24) =5.225_r8<a name='5214'>
  dzlak(25) =5.225_r8<a name='5215'>
<a name='5216'>
  zlak(1) = dzlak(1)/2._r8<a name='5217'>
  do k = 2,nlevlake<a name='5218'>
     zlak(k) = zlak(k-1) + (dzlak(k-1)+dzlak(k))/2._r8<a name='5219'>
  end do<a name='5220'>
#endif<a name='5221'>
<a name='5222'>
   <font color=#447700>! "0" refers to soil surface and "nlevsoil" refers to the bottom of model soil<a name='5223'></font>
<a name='5224'>
   do j = 1, nlevsoil<a name='5225'>
      zsoi(j) = scalez*(exp(0.5_r8*(j-0.5_r8))-1._r8)    <font color=#447700>!node depths<a name='5226'></font>
   enddo<a name='5227'>
<a name='5228'>
   dzsoi(1) = 0.5_r8*(zsoi(1)+zsoi(2))             <font color=#447700>!thickness b/n two interfaces<a name='5229'></font>
   do j = 2,nlevsoil-1<a name='5230'>
      dzsoi(j)= 0.5_r8*(zsoi(j+1)-zsoi(j-1))<a name='5231'>
   enddo<a name='5232'>
   dzsoi(nlevsoil) = zsoi(nlevsoil)-zsoi(nlevsoil-1)<a name='5233'>
<a name='5234'>
   zisoi(0) = 0._r8<a name='5235'>
   do j = 1, nlevsoil-1<a name='5236'>
      zisoi(j) = 0.5_r8*(zsoi(j)+zsoi(j+1))         <font color=#447700>!interface depths<a name='5237'></font>
   enddo<a name='5238'>
   zisoi(nlevsoil) = zsoi(nlevsoil) + 0.5_r8*dzsoi(nlevsoil)<a name='5239'>
<a name='5240'>
<a name='5241'>
<font color=#447700>!!!!!!!!!!!!!!!!!!begin to initialize lake variables!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='5242'></font>
<a name='5243'>
  DO j = jts,jte<a name='5244'>
  DO i = its,ite<a name='5245'>
      <a name='5246'>
     if ( lake(i,j) ) then<a name='5247'>
<a name='5248'>
                             <font color=#447700>! Soil hydraulic and thermal properties<a name='5249'></font>
         isl = ISLTYP(i,j)   <a name='5250'>
         if (isl == 14 ) isl = isl + 1 <a name='5251'>
         do k = 1,nlevsoil<a name='5252'>
            sand3d(i,k,j)  = sand(isl)<a name='5253'>
            clay3d(i,k,j)  = clay(isl)<a name='5254'>
         enddo<a name='5255'>
<a name='5256'>
         do k = 1,nlevsoil<a name='5257'>
            clay2d(i,j) = clay3d(i,k,j)<a name='5258'>
            sand2d(i,j) = sand3d(i,k,j)<a name='5259'>
            watsat3d(i,k,j) = 0.489_r8 - 0.00126_r8*sand2d(i,j)<a name='5260'>
            bd2d(i,j)    = (1._r8-watsat3d(i,k,j))*2.7e3_r8<a name='5261'>
            xksat2d(i,j) = 0.0070556_r8 *( 10._r8**(-0.884_r8+0.0153_r8*sand2d(i,j)) ) <font color=#447700>! mm/s<a name='5262'></font>
            tkm2d(i,j) = (8.80_r8*sand2d(i,j)+2.92_r8*clay2d(i,j))/(sand2d(i,j)+clay2d(i,j))          <font color=#447700>! W/(m K)<a name='5263'></font>
<a name='5264'>
            bsw3d(i,k,j) = 2.91_r8 + 0.159_r8*clay2d(i,j)<a name='5265'>
            bsw23d(i,k,j) = -(3.10_r8 + 0.157_r8*clay2d(i,j) - 0.003_r8*sand2d(i,j))<a name='5266'>
            psisat3d(i,k,j) = -(exp((1.54_r8 - 0.0095_r8*sand2d(i,j) + 0.0063_r8*(100.0_r8-sand2d(i,j)  &amp;<a name='5267'>
                              -clay2d(i,j)))*log(10.0_r8))*9.8e-5_r8)<a name='5268'>
            vwcsat3d(i,k,j) = (50.5_r8 - 0.142_r8*sand2d(i,j) - 0.037_r8*clay2d(i,j))/100.0_r8<a name='5269'>
            hksat3d(i,k,j) = xksat2d(i,j)<a name='5270'>
            sucsat3d(i,k,j) = 10._r8 * ( 10._r8**(1.88_r8-0.0131_r8*sand2d(i,j)) )<a name='5271'>
            tkmg3d(i,k,j) = tkm2d(i,j) ** (1._r8- watsat3d(i,k,j))<a name='5272'>
            tksatu3d(i,k,j) = tkmg3d(i,k,j)*0.57_r8**watsat3d(i,k,j)<a name='5273'>
            tkdry3d(i,k,j) = (0.135_r8*bd2d(i,j) + 64.7_r8) / (2.7e3_r8 - 0.947_r8*bd2d(i,j))<a name='5274'>
            csol3d(i,k,j) = (2.128_r8*sand2d(i,j)+2.385_r8*clay2d(i,j)) / (sand2d(i,j)+clay2d(i,j))*1.e6_r8  <font color=#447700>! J/(m3 K)<a name='5275'></font>
            watdry3d(i,k,j) = watsat3d(i,k,j) * (316230._r8/sucsat3d(i,k,j)) ** (-1._r8/bsw3d(i,k,j))<a name='5276'>
            watopt3d(i,k,j) = watsat3d(i,k,j) * (158490._r8/sucsat3d(i,k,j)) ** (-1._r8/bsw3d(i,k,j))<a name='5277'>
         end do<a name='5278'>
         if (lakedepth2d(i,j) == spval) then<a name='5279'>
            lakedepth2d(i,j) = zlak(nlevlake) + 0.5_r8*dzlak(nlevlake)<a name='5280'>
            z_lake3d(i,1:nlevlake,j) = zlak(1:nlevlake)<a name='5281'>
            dz_lake3d(i,1:nlevlake,j) = dzlak(1:nlevlake)<a name='5282'>
         else<a name='5283'>
            depthratio2d(i,j) = lakedepth2d(i,j) / (zlak(nlevlake) + 0.5_r8*dzlak(nlevlake)) <a name='5284'>
            z_lake3d(i,1,j) = zlak(1)<a name='5285'>
            dz_lake3d(i,1,j) = dzlak(1)<a name='5286'>
            dz_lake3d(i,2:nlevlake,j) = dzlak(2:nlevlake)*depthratio2d(i,j)<a name='5287'>
            z_lake3d(i,2:nlevlake,j) = zlak(2:nlevlake)*depthratio2d(i,j) + dz_lake3d(i,1,j)*(1._r8 - depthratio2d(i,j))<a name='5288'>
         end if<a name='5289'>
<font color=#447700>! initial t_lake3d here<a name='5290'></font>
	t_soisno3d(i,1,j)      = tsk(i,j)<a name='5291'>
        t_lake3d(i,1,j)        = tsk(i,j)<a name='5292'>
        t_grnd2d(i,j)          = 277.0<a name='5293'>
        do k = 2, nlevlake<a name='5294'>
        if(z_lake3d(i,k,j).le.depth_c) then <a name='5295'>
         t_soisno3d(i,k,j)=tsk(i,j)+(277.0-tsk(i,j))/depth_c*z_lake3d(i,k,j)<a name='5296'>
         t_lake3d(i,k,j)=tsk(i,j)+(277.0-tsk(i,j))/depth_c*z_lake3d(i,k,j)<a name='5297'>
        else<a name='5298'>
	t_soisno3d(i,k,j)      = 277.0<a name='5299'>
        t_lake3d(i,k,j)        = 277.0<a name='5300'>
        end if <a name='5301'>
        enddo<a name='5302'>
<font color=#447700>!end initial t_lake3d here<a name='5303'></font>
         z3d(i,1:nlevsoil,j) = zsoi(1:nlevsoil)<a name='5304'>
         zi3d(i,0:nlevsoil,j) = zisoi(0:nlevsoil)<a name='5305'>
         dz3d(i,1:nlevsoil,j) = dzsoi(1:nlevsoil)<a name='5306'>
         savedtke12d(i,j) = tkwat <font color=#447700>! Initialize for first timestep.<a name='5307'></font>
   <a name='5308'>
<a name='5309'>
        if (snowdp2d(i,j) &lt; 0.01_r8) then<a name='5310'>
           snl2d(i,j) = 0<a name='5311'>
           dz3d(i,-nlevsnow+1:0,j) = 0._r8<a name='5312'>
           z3d (i,-nlevsnow+1:0,j) = 0._r8<a name='5313'>
           zi3d(i,-nlevsnow+0:0,j) = 0._r8<a name='5314'>
        else<a name='5315'>
           if ((snowdp2d(i,j) &gt;= 0.01_r8) .and. (snowdp2d(i,j) &lt;= 0.03_r8)) then<a name='5316'>
              snl2d(i,j) = -1<a name='5317'>
              dz3d(i,0,j)  = snowdp2d(i,j)<a name='5318'>
           else if ((snowdp2d(i,j) &gt; 0.03_r8) .and. (snowdp2d(i,j) &lt;= 0.04_r8)) then<a name='5319'>
              snl2d(i,j) = -2<a name='5320'>
              dz3d(i,-1,j) = snowdp2d(i,j)/2._r8<a name='5321'>
              dz3d(i, 0,j) = dz3d(i,-1,j)<a name='5322'>
           else if ((snowdp2d(i,j) &gt; 0.04_r8) .and. (snowdp2d(i,j) &lt;= 0.07_r8)) then<a name='5323'>
              snl2d(i,j) = -2<a name='5324'>
              dz3d(i,-1,j) = 0.02_r8<a name='5325'>
              dz3d(i, 0,j) = snowdp2d(i,j) - dz3d(i,-1,j)<a name='5326'>
           else if ((snowdp2d(i,j) &gt; 0.07_r8) .and. (snowdp2d(i,j) &lt;= 0.12_r8)) then<a name='5327'>
              snl2d(i,j) = -3<a name='5328'>
              dz3d(i,-2,j) = 0.02_r8<a name='5329'>
              dz3d(i,-1,j) = (snowdp2d(i,j) - 0.02_r8)/2._r8<a name='5330'>
              dz3d(i, 0,j) = dz3d(i,-1,j)<a name='5331'>
           else if ((snowdp2d(i,j) &gt; 0.12_r8) .and. (snowdp2d(i,j) &lt;= 0.18_r8)) then<a name='5332'>
              snl2d(i,j) = -3<a name='5333'>
              dz3d(i,-2,j) = 0.02_r8<a name='5334'>
              dz3d(i,-1,j) = 0.05_r8<a name='5335'>
              dz3d(i, 0,j) = snowdp2d(i,j) - dz3d(i,-2,j) - dz3d(i,-1,j)<a name='5336'>
           else if ((snowdp2d(i,j) &gt; 0.18_r8) .and. (snowdp2d(i,j) &lt;= 0.29_r8)) then<a name='5337'>
              snl2d(i,j) = -4<a name='5338'>
              dz3d(i,-3,j) = 0.02_r8<a name='5339'>
              dz3d(i,-2,j) = 0.05_r8<a name='5340'>
              dz3d(i,-1,j) = (snowdp2d(i,j) - dz3d(i,-3,j) - dz3d(i,-2,j))/2._r8<a name='5341'>
              dz3d(i, 0,j) = dz3d(i,-1,j)<a name='5342'>
           else if ((snowdp2d(i,j) &gt; 0.29_r8) .and. (snowdp2d(i,j) &lt;= 0.41_r8)) then<a name='5343'>
              snl2d(i,j) = -4<a name='5344'>
              dz3d(i,-3,j) = 0.02_r8<a name='5345'>
              dz3d(i,-2,j) = 0.05_r8<a name='5346'>
              dz3d(i,-1,j) = 0.11_r8<a name='5347'>
              dz3d(i, 0,j) = snowdp2d(i,j) - dz3d(i,-3,j) - dz3d(i,-2,j) - dz3d(i,-1,j)<a name='5348'>
           else if ((snowdp2d(i,j) &gt; 0.41_r8) .and. (snowdp2d(i,j) &lt;= 0.64_r8)) then<a name='5349'>
              snl2d(i,j) = -5<a name='5350'>
              dz3d(i,-4,j) = 0.02_r8<a name='5351'>
              dz3d(i,-3,j) = 0.05_r8<a name='5352'>
              dz3d(i,-2,j) = 0.11_r8<a name='5353'>
              dz3d(i,-1,j) = (snowdp2d(i,j) - dz3d(i,-4,j) - dz3d(i,-3,j) - dz3d(i,-2,j))/2._r8<a name='5354'>
              dz3d(i, 0,j) = dz3d(i,-1,j)<a name='5355'>
           else if (snowdp2d(i,j) &gt; 0.64_r8) then<a name='5356'>
              snl2d(i,j) = -5<a name='5357'>
              dz3d(i,-4,j) = 0.02_r8<a name='5358'>
              dz3d(i,-3,j) = 0.05_r8<a name='5359'>
              dz3d(i,-2,j) = 0.11_r8<a name='5360'>
              dz3d(i,-1,j) = 0.23_r8<a name='5361'>
              dz3d(i, 0,j)=snowdp2d(i,j)-dz3d(i,-4,j)-dz3d(i,-3,j)-dz3d(i,-2,j)-dz3d(i,-1,j)<a name='5362'>
           endif<a name='5363'>
        end if<a name='5364'>
 <a name='5365'>
        do k = 0, snl2d(i,j)+1, -1<a name='5366'>
           z3d(i,k,j)    = zi3d(i,k,j) - 0.5_r8*dz3d(i,k,j)<a name='5367'>
           zi3d(i,k-1,j) = zi3d(i,k,j) - dz3d(i,k,j)<a name='5368'>
        end do<a name='5369'>
<a name='5370'>
<font color=#447700>! 3:subroutine makearbinit<a name='5371'></font>
<a name='5372'>
        if (snl2d(i,j) &lt; 0) then<a name='5373'>
           do k = snl2d(i,j)+1, 0<a name='5374'>
                <font color=#447700>! Be careful because there may be new snow layers with bad temperatures like 0 even if<a name='5375'></font>
                <font color=#447700>! coming from init. con. file.<a name='5376'></font>
              if(arbinit .or. t_soisno3d(i,k,j) &gt; 300 .or. t_soisno3d(i,k,j) &lt; 200) t_soisno3d(i,k,j) = 250._r8<a name='5377'>
           enddo<a name='5378'>
        end if<a name='5379'>
<a name='5380'>
        do k = 1, nlevsoil<a name='5381'>
           if(arbinit .or. t_soisno3d(i,k,j) &gt; 1000 .or. t_soisno3d(i,k,j) &lt; 0) t_soisno3d(i,k,j) = t_lake3d(i,nlevlake,j)<a name='5382'>
        end do<a name='5383'>
<a name='5384'>
        do k = 1, nlevlake<a name='5385'>
           if(arbinit .or. lake_icefrac3d(i,k,j) &gt; 1._r8 .or. lake_icefrac3d(i,k,j) &lt; 0._r8) then<a name='5386'>
              if(t_lake3d(i,k,j) &gt;= tfrz) then<a name='5387'>
                 lake_icefrac3d(i,k,j) = 0._r8<a name='5388'>
              else<a name='5389'>
                 lake_icefrac3d(i,k,j) = 1._r8<a name='5390'>
              end if<a name='5391'>
           end if<a name='5392'>
        end do<a name='5393'>
        <a name='5394'>
        do k = 1,nlevsoil<a name='5395'>
           if (arbinit .or. h2osoi_vol3d(i,k,j) &gt; 10._r8 .or. h2osoi_vol3d(i,k,j) &lt; 0._r8) h2osoi_vol3d(i,k,j) = 1.0_r8<a name='5396'>
           h2osoi_vol3d(i,k,j) = min(h2osoi_vol3d(i,k,j),watsat3d(i,k,j))<a name='5397'>
<a name='5398'>
             <font color=#447700>! soil layers<a name='5399'></font>
           if (t_soisno3d(i,k,j) &lt;= tfrz) then<a name='5400'>
              h2osoi_ice3d(i,k,j)  = dz3d(i,k,j)*denice*h2osoi_vol3d(i,k,j)<a name='5401'>
              h2osoi_liq3d(i,k,j) = 0._r8<a name='5402'>
           else<a name='5403'>
              h2osoi_ice3d(i,k,j) = 0._r8<a name='5404'>
              h2osoi_liq3d(i,k,j) = dz3d(i,k,j)*denh2o*h2osoi_vol3d(i,k,j)<a name='5405'>
           endif<a name='5406'>
        enddo<a name='5407'>
<a name='5408'>
        do k = -nlevsnow+1, 0<a name='5409'>
           if (k &gt; snl2d(i,j)) then<a name='5410'>
              h2osoi_ice3d(i,k,j) = dz3d(i,k,j)*bdsno<a name='5411'>
              h2osoi_liq3d(i,k,j) = 0._r8<a name='5412'>
           end if<a name='5413'>
        end do<a name='5414'>
<a name='5415'>
    end if   <font color=#447700>!lake(i,j)<a name='5416'></font>
  ENDDO<a name='5417'>
  ENDDO<a name='5418'>
<a name='5419'>
  END SUBROUTINE lakeini<a name='5420'>
<a name='5421'>
END MODULE module_sf_lake<a name='5422'>
</pre></body></html>