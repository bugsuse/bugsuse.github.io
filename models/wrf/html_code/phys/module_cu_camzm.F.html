<HTML> <BODY BGCOLOR=#ddddee LINK=#0000aa VLINK=#0000ff ALINK=#ff0000 ><BASE TARGET="bottom_target"><PRE><a name='1'>
#define WRF_PORT<a name='2'>
#define MODAL_AERO<a name='3'>
<font color=#447700>! Updated to CESM1.0.3 (CAM5.1.01) by Balwinder.Singh@pnnl.gov<a name='4'></font>
<A NAME='MODULE_CU_CAMZM'><A href='../../html_code/phys/module_cu_camzm.F.html#MODULE_CU_CAMZM' TARGET='top_target'><IMG SRC="../../gif/bar_purple.gif" border=0></A><a name='5'>
<font color=#993300>module </font><font color=#cc0000>module_cu_camzm</font> <A href='../../call_to/MODULE_CU_CAMZM.html' TARGET='index'>2</A><a name='6'>
<a name='7'>
<font color=#447700>!---------------------------------------------------------------------------------<a name='8'></font>
<font color=#447700>! Purpose:<a name='9'></font>
<font color=#447700>!<a name='10'></font>
<font color=#447700>! Interface from Zhang-McFarlane convection scheme, includes evaporation of convective <a name='11'></font>
<font color=#447700>! precip from the ZM scheme<a name='12'></font>
<font color=#447700>!<a name='13'></font>
<font color=#447700>! Apr 2006: RBN: Code added to perform a dilute ascent for closure of the CM mass flux<a name='14'></font>
<font color=#447700>!                based on an entraining plume a la Raymond and Blythe (1992)<a name='15'></font>
<font color=#447700>!<a name='16'></font>
<font color=#447700>! Author: Byron Boville, from code in tphysbc<a name='17'></font>
<font color=#447700>!<a name='18'></font>
<font color=#447700>!---------------------------------------------------------------------------------<a name='19'></font>
  use <A href='../../html_code/phys/module_cam_shr_kind_mod.F.html#SHR_KIND_MOD'>shr_kind_mod</A><A href='../../html_code/phys/module_cu_camzm.F.html#module_cu_camzm.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SHR_KIND_MOD_22">,    only: r8 =&gt; shr_kind_r8<a name='20'>
#ifndef WRF_PORT<a name='21'>
  use spmd_utils,      only: masterproc<a name='22'>
  use ppgrid,          only: pcols, pver, pverp<a name='23'>
#else<a name='24'>
  use <A href='../../html_code/phys/module_cam_support.F.html#MODULE_CAM_SUPPORT'>module_cam_support</A><A href='../../html_code/phys/module_cu_camzm.F.html#module_cu_camzm.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CAM_SUPPORT_39">, only: masterproc, pcols, pver, pverp <a name='25'>
#endif<a name='26'>
  use <A href='../../html_code/phys/module_cam_cldwat.F.html#CLDWAT'>cldwat</A><A href='../../html_code/phys/module_cu_camzm.F.html#module_cu_camzm.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CLDWAT_1">,          only: cldwat_fice<a name='27'>
  use <A href='../../html_code/phys/module_cam_physconst.F.html#PHYSCONST'>physconst</A><A href='../../html_code/phys/module_cu_camzm.F.html#module_cu_camzm.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="PHYSCONST_16">,       only: cpair, epsilo, gravit, latice, latvap, tmelt, rair, &amp;<a name='28'>
                             cpwv, cpliq, rh2o<a name='29'>
#ifndef WRF_PORT<a name='30'>
  use abortutils,      only: endrun<a name='31'>
  use cam_logfile,     only: iulog<a name='32'>
#else<a name='33'>
  use <A href='../../html_code/phys/module_cam_support.F.html#MODULE_CAM_SUPPORT'>module_cam_support</A><A href='../../html_code/phys/module_cu_camzm.F.html#module_cu_camzm.F' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CAM_SUPPORT_40">,only: endrun, iulog<a name='34'>
#endif<a name='35'>
<a name='36'>
  implicit none<a name='37'>
<a name='38'>
  save<a name='39'>
  private                         <font color=#447700>! Make default type private to the module<a name='40'></font>
<font color=#447700>!<a name='41'></font>
<font color=#447700>! PUBLIC: interfaces<a name='42'></font>
<font color=#447700>!<a name='43'></font>
  public zmconv_readnl            <font color=#447700>! read zmconv_nl namelist<a name='44'></font>
  public zm_convi                 <font color=#447700>! ZM schemea<a name='45'></font>
  public zm_convr                 <font color=#447700>! ZM schemea<a name='46'></font>
  public zm_conv_evap             <font color=#447700>! evaporation of precip from ZM schemea<a name='47'></font>
  public convtran                 <font color=#447700>! convective transport<a name='48'></font>
  public momtran                  <font color=#447700>! convective momentum transport<a name='49'></font>
<a name='50'>
<font color=#447700>!<a name='51'></font>
<font color=#447700>! Private data<a name='52'></font>
<font color=#447700>!<a name='53'></font>
   real(r8), parameter :: unset_r8 = huge(1.0_r8)<a name='54'>
   real(r8) :: zmconv_c0_lnd = unset_r8    <a name='55'>
   real(r8) :: zmconv_c0_ocn = unset_r8    <a name='56'>
   real(r8) :: zmconv_ke     = unset_r8    <a name='57'>
<a name='58'>
   real(r8) rl         <font color=#447700>! wg latent heat of vaporization.<a name='59'></font>
   real(r8) cpres      <font color=#447700>! specific heat at constant pressure in j/kg-degk.<a name='60'></font>
   real(r8), parameter :: capelmt = 70._r8  <font color=#447700>! threshold value for cape for deep convection.<a name='61'></font>
   real(r8) :: ke           <font color=#447700>! Tunable evaporation efficiency set from namelist input zmconv_ke<a name='62'></font>
   real(r8) :: c0_lnd       <font color=#447700>! set from namelist input zmconv_c0_lnd<a name='63'></font>
   real(r8) :: c0_ocn       <font color=#447700>! set from namelist input zmconv_c0_ocn<a name='64'></font>
   real(r8) tau   <font color=#447700>! convective time scale<a name='65'></font>
   real(r8),parameter :: a = 21.656_r8<a name='66'>
   real(r8),parameter :: b = 5418._r8<a name='67'>
   real(r8),parameter :: c1 = 6.112_r8<a name='68'>
   real(r8),parameter :: c2 = 17.67_r8<a name='69'>
   real(r8),parameter :: c3 = 243.5_r8<a name='70'>
   real(r8) :: tfreez<a name='71'>
   real(r8) :: eps1<a name='72'>
      <a name='73'>
<a name='74'>
   logical :: no_deep_pbl <font color=#447700>! default = .false.<a name='75'></font>
                          <font color=#447700>! no_deep_pbl = .true. eliminates deep convection entirely within PBL <a name='76'></font>
   <a name='77'>
<a name='78'>
<font color=#447700>!moved from moistconvection.F90<a name='79'></font>
   real(r8) :: rgrav       <font color=#447700>! reciprocal of grav<a name='80'></font>
   real(r8) :: rgas        <font color=#447700>! gas constant for dry air<a name='81'></font>
   real(r8) :: grav        <font color=#447700>! = gravit<a name='82'></font>
   real(r8) :: cp          <font color=#447700>! = cpres = cpair<a name='83'></font>
   <a name='84'>
   integer  limcnv       <font color=#447700>! top interface level limit for convection<a name='85'></font>
<a name='86'>
   real(r8),parameter ::  tiedke_add = 0.5_r8   <a name='87'>
<a name='88'>
contains<a name='89'>
<a name='90'>
<A NAME='ZMCONV_READNL'><A href='../../html_code/phys/module_cu_camzm.F.html#ZMCONV_READNL' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='91'>
<font color=#993300>subroutine </font><font color=#cc0000>zmconv_readnl</font>(nlfile) <A href='../../call_to/ZMCONV_READNL.html' TARGET='index'>1</A>,<A href='../../call_from/ZMCONV_READNL.html' TARGET='index'>1</A><a name='92'>
#ifndef WRF_PORT<a name='93'>
   use namelist_utils,  only: find_group_name<a name='94'>
   use units,           only: getunit, freeunit<a name='95'>
   use mpishorthand<a name='96'>
#endif<a name='97'>
<a name='98'>
   character(len=*), intent(in) :: nlfile  <font color=#447700>! filepath for file containing namelist input<a name='99'></font>
#ifndef WRF_PORT<a name='100'>
   <font color=#447700>! Local variables<a name='101'></font>
   integer :: unitn, ierr<a name='102'>
   character(len=*), parameter :: subname = 'zmconv_readnl'<a name='103'>
<a name='104'>
   namelist /zmconv_nl/ zmconv_c0_lnd, zmconv_c0_ocn, zmconv_ke<a name='105'>
   <font color=#447700>!-----------------------------------------------------------------------------<a name='106'></font>
<a name='107'>
   if (masterproc) then<a name='108'>
      unitn = getunit()<a name='109'>
      open( unitn, file=trim(nlfile), status='old' )<a name='110'>
      call find_group_name(unitn, 'zmconv_nl', status=ierr)<a name='111'>
      if (ierr == 0) then<a name='112'>
         read(unitn, zmconv_nl, iostat=ierr)<a name='113'>
         if (ierr /= 0) then<a name='114'>
            call <A href='../../html_code/phys/module_sf_clm.F.html#ENDRUN'>endrun</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZMCONV_READNL' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ENDRUN_26">(subname // ':: ERROR reading namelist')<a name='115'>
         end if<a name='116'>
      end if<a name='117'>
      close(unitn)<a name='118'>
      call freeunit(unitn)<a name='119'>
<a name='120'>
      <font color=#447700>! set local variables<a name='121'></font>
      c0_lnd = zmconv_c0_lnd<a name='122'>
      c0_ocn = zmconv_c0_ocn<a name='123'>
      ke = zmconv_ke<a name='124'>
<a name='125'>
   end if<a name='126'>
<a name='127'>
#ifdef SPMD<a name='128'>
   <font color=#447700>! Broadcast namelist variables<a name='129'></font>
   call mpibcast(c0_lnd,            1, mpir8,  0, mpicom)<a name='130'>
   call mpibcast(c0_ocn,            1, mpir8,  0, mpicom)<a name='131'>
   call mpibcast(ke,                1, mpir8,  0, mpicom)<a name='132'>
#endif<a name='133'>
#else<a name='134'>
<font color=#447700>! WRF_PORT currently uses hard-wired values for the namelist input. The<a name='135'></font>
<font color=#447700>! values could easily be setup to come from the Registry in the future.<a name='136'></font>
<font color=#447700>! The hard-wired values are the defaults for the fv core. They should be<a name='137'></font>
<font color=#447700>! verified by somebody knowledgable on the matter.<a name='138'></font>
   c0_lnd = 0.0059D0 <a name='139'>
   c0_ocn = 0.0450D0 <a name='140'>
   ke     = 1.0E-6 <a name='141'>
#endif<a name='142'>
end subroutine zmconv_readnl<a name='143'>
<a name='144'>
<a name='145'>
#ifndef WRF_PORT<a name='146'>
<A NAME='ZM_CONVI'><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='147'>
   <font color=#993300>subroutine </font><font color=#cc0000>zm_convi</font>(limcnv_in, no_deep_pbl_in) <A href='../../call_to/ZM_CONVI.html' TARGET='index'>1</A>,<A href='../../call_from/ZM_CONVI.html' TARGET='index'>8</A><a name='148'>
   use dycore,       only: dycore_is, get_resolution<a name='149'>
#else<a name='150'>
<A NAME='ZM_CONVI'><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='151'>
   <font color=#993300>subroutine </font><font color=#cc0000>zm_convi</font>(DT,DX,limcnv_in, no_deep_pbl_in) <A href='../../call_to/ZM_CONVI.html' TARGET='index'>1</A>,<A href='../../call_from/ZM_CONVI.html' TARGET='index'>8</A><a name='152'>
#endif<a name='153'>
<a name='154'>
<a name='155'>
   integer, intent(in)           :: limcnv_in       <font color=#447700>! top interface level limit for convection<a name='156'></font>
   logical, intent(in), optional :: no_deep_pbl_in  <font color=#447700>! no_deep_pbl = .true. eliminates ZM convection entirely within PBL <a name='157'></font>
#ifdef WRF_PORT<a name='158'>
   REAL ,    INTENT(IN)        :: DT, DX<a name='159'>
#endif<a name='160'>
   real(r8) :: DTT<a name='161'>
<a name='162'>
<a name='163'>
<a name='164'>
   <font color=#447700>! local variables<a name='165'></font>
   character(len=32)   :: hgrid           <font color=#447700>! horizontal grid specifier<a name='166'></font>
<a name='167'>
#ifdef WRF_PORT<a name='168'>
   real(r8) :: deltax     <font color=#447700>! model delta x   <a name='169'></font>
   real(r8) :: ref_dx     <font color=#447700>! reference delta x (CAM5 1.9 x 2.5 deg)<a name='170'></font>
   real(r8) :: taumin     <font color=#447700>! minimum allowable tau<a name='171'></font>
   real(r8) :: taumax     <font color=#447700>! maximum allowable tau <a name='172'></font>
#endif<a name='173'>
<a name='174'>
   <font color=#447700>! Initialization of ZM constants<a name='175'></font>
   limcnv = limcnv_in<a name='176'>
   tfreez = tmelt<a name='177'>
   eps1   = epsilo<a name='178'>
   rl     = latvap<a name='179'>
   cpres  = cpair<a name='180'>
   rgrav  = 1.0_r8/gravit<a name='181'>
   rgas   = rair<a name='182'>
   grav   = gravit<a name='183'>
   cp     = cpres<a name='184'>
#ifdef WRF_PORT<a name='185'>
   <font color=#447700>!PMA sets parameters<a name='186'></font>
   ref_dx = 275000._r8<a name='187'>
   taumin = 600._r8<a name='188'>
   taumax = 3600._r8<a name='189'>
   deltax=dx<a name='190'>
#endif<a name='191'>
<a name='192'>
   if ( present(no_deep_pbl_in) )  then<a name='193'>
      no_deep_pbl = no_deep_pbl_in<a name='194'>
   else<a name='195'>
      no_deep_pbl = .true.<a name='196'>
   endif<a name='197'>
<a name='198'>
   DTT=DT<a name='199'>
<a name='200'>
   <font color=#447700>! tau=4800. were used in canadian climate center. however, in echam3 t42, <a name='201'></font>
   <font color=#447700>! convection is too weak, thus adjusted to 2400.<a name='202'></font>
#ifndef WRF_PORT<a name='203'>
   hgrid = get_resolution()<a name='204'>
   tau = 3600._r8<a name='205'>
<font color=#447700>!  PMA: Standard 2-deg CAM5.1 uses 1-hr relaxation time scale which is too long for the<a name='206'></font>
<font color=#447700>!  mesoscale model to remove CAPE quickly. As a result, the model generates grid-scale <a name='207'></font>
<font color=#447700>!  storms and becomes unstable sometimes (Williamson, 2012). Hence, we sets tau as a function<a name='208'></font>
<font color=#447700>!  of the length of time step. The caveat of this is that the model behavior<a name='209'></font>
<font color=#447700>!  of precipitation will be different to CAM5. We acknowledge that reducing dynamical<a name='210'></font>
<font color=#447700>!  time step can also make a stable model simulation. March 12, 2013<a name='211'></font>
<font color=#447700>!<a name='212'></font>
   tau = max(min(2._r8*DTT,1200._r8),120._r8)<a name='213'>
#else<a name='214'>
<a name='215'>
<font color=#447700>!PMA: The 1.9x2.5 deg CAM5 uses tau = 3600s. With higher resolution and shorter timestep in CAM,<a name='216'></font>
<font color=#447700>!     tau is set to a smaller value. Williamson (2012) found that without reducing tau in a high-res<a name='217'></font>
<font color=#447700>!     simulation, 'grid-scale storms' can form because the ZM scheme fails to remove CAPE quickly enough<a name='218'></font>
<font color=#447700>!     so that the resolved scheme (micro+macro) has to work very hard. WRF usually is run at much higher <a name='219'></font>
<font color=#447700>!     resolution than CAM and this grid-scale storm problem is apparent, which can cause the model to <a name='220'></font>
<font color=#447700>!     crash. Hence, we make tau to be a function of spatial resolution. <a name='221'></font>
<font color=#447700>!     For WRF, one needs to make dt very small if tau=3600s for the model to run stably. <a name='222'></font>
<a name='223'>
<font color=#447700>!   tau = 3600._r8<a name='224'></font>
<a name='225'>
<font color=#447700>!PMA formula: tau = 3600s when dx = 275km ~ 2.5deg<a name='226'></font>
<font color=#447700>!             tau =  600s when dx = 10km<a name='227'></font>
<a name='228'>
<font color=#447700>!  tau = 11.32_r8 * deltax + 489.68_r8<a name='229'></font>
<a name='230'>
<font color=#447700>!PMA adopts PJR formula<a name='231'></font>
<a name='232'>
   tau = max(taumin, taumax*min(1._r8,deltax/ref_dx))<a name='233'>
<a name='234'>
#endif<a name='235'>
   if ( masterproc ) then<a name='236'>
      write(iulog,*) 'delta X =',deltax<a name='237'>
#ifdef WRF_PORT<a name='238'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_526">(1,iulog)<a name='239'>
#endif<a name='240'>
      write(iulog,*) 'Convective relaxation time scale (tau) is a tunable parameter in CAM and is a function of spatial resolution.'<a name='241'>
      write(iulog,*) 'Users are encouraged to consult with the PNNL WRF-CAM5 development team if they want to change tau.'<a name='242'>
#ifdef WRF_PORT<a name='243'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_527">(1,iulog)<a name='244'>
#endif<a name='245'>
      write(iulog,*) 'tuning parameters zm_convi: tau',tau<a name='246'>
#ifdef WRF_PORT<a name='247'>
      call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_626">(iulog)<a name='248'>
#endif<a name='249'>
      write(iulog,*) 'Standard 2-deg CAM5.1 sets tau=3600s and is reduced for the mesoscale model WRF'<a name='250'>
#ifdef WRF_PORT<a name='251'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_528">(1,iulog)<a name='252'>
#endif<a name='253'>
      write(iulog,*) 'tuning parameters zm_convi: c0_lnd',c0_lnd, ', c0_ocn', c0_ocn <a name='254'>
#ifdef WRF_PORT<a name='255'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_529">(1,iulog)<a name='256'>
#endif<a name='257'>
      write(iulog,*) 'tuning parameters zm_convi: ke',ke<a name='258'>
#ifdef WRF_PORT<a name='259'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_530">(1,iulog)<a name='260'>
#endif<a name='261'>
      write(iulog,*) 'tuning parameters zm_convi: no_deep_pbl',no_deep_pbl<a name='262'>
#ifdef WRF_PORT<a name='263'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_531">(1,iulog)<a name='264'>
#endif<a name='265'>
   endif<a name='266'>
<a name='267'>
   if (masterproc) write(iulog,*)'**** ZM: DILUTE Buoyancy Calculation ****'<a name='268'>
#ifdef WRF_PORT<a name='269'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVI' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_532">(1,iulog)<a name='270'>
#endif<a name='271'>
<a name='272'>
end subroutine zm_convi<a name='273'>
<a name='274'>
<a name='275'>
<a name='276'>
<A NAME='ZM_CONVR'><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='277'>
<font color=#993300>subroutine </font><font color=#cc0000>zm_convr</font>(lchnk   ,ncol    , &amp; <A href='../../call_to/ZM_CONVR.html' TARGET='index'>1</A>,<A href='../../call_from/ZM_CONVR.html' TARGET='index'>7</A><a name='278'>
                    t       ,qh      ,prec    ,jctop   ,jcbot   , &amp;<a name='279'>
                    pblh    ,zm      ,geos    ,zi      ,qtnd    , &amp;<a name='280'>
                    heat    ,pap     ,paph    ,dpp     , &amp;<a name='281'>
                    delt    ,mcon    ,cme     ,cape    , &amp;<a name='282'>
                    tpert   ,dlf     ,pflx    ,zdu     ,rprd    , &amp;<a name='283'>
                    mu      ,md      ,du      ,eu      ,ed      , &amp;<a name='284'>
                    dp      ,dsubcld ,jt      ,maxg    ,ideep   , &amp;<a name='285'>
                    lengath ,ql      ,rliq    ,landfrac)<a name='286'>
<font color=#447700>!----------------------------------------------------------------------- <a name='287'></font>
<font color=#447700>! <a name='288'></font>
<font color=#447700>! Purpose: <a name='289'></font>
<font color=#447700>! Main driver for zhang-mcfarlane convection scheme <a name='290'></font>
<font color=#447700>! <a name='291'></font>
<font color=#447700>! Method: <a name='292'></font>
<font color=#447700>! performs deep convective adjustment based on mass-flux closure<a name='293'></font>
<font color=#447700>! algorithm.<a name='294'></font>
<font color=#447700>! <a name='295'></font>
<font color=#447700>! Author:guang jun zhang, m.lazare, n.mcfarlane. CAM Contact: P. Rasch<a name='296'></font>
<font color=#447700>!<a name='297'></font>
<font color=#447700>! This is contributed code not fully standardized by the CAM core group.<a name='298'></font>
<font color=#447700>! All variables have been typed, where most are identified in comments<a name='299'></font>
<font color=#447700>! The current procedure will be reimplemented in a subsequent version<a name='300'></font>
<font color=#447700>! of the CAM where it will include a more straightforward formulation<a name='301'></font>
<font color=#447700>! and will make use of the standard CAM nomenclature<a name='302'></font>
<font color=#447700>! <a name='303'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='304'></font>
#ifdef WRF_PORT<a name='305'>
  use <A href='../../html_code/phys/module_cam_support.F.html#MODULE_CAM_SUPPORT'>module_cam_support</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CAM_SUPPORT_41">, only: pcnst =&gt;pcnst_runtime<a name='306'>
#else<a name='307'>
   use <A href='../../html_code/phys/module_cam_constituents.F.html#CONSTITUENTS'>constituents</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CONSTITUENTS_14">, only: pcnst<a name='308'>
   use phys_control, only: cam_physpkg_is<a name='309'>
#endif<a name='310'>
<a name='311'>
<font color=#447700>!<a name='312'></font>
<font color=#447700>! ************************ index of variables **********************<a name='313'></font>
<font color=#447700>!<a name='314'></font>
<font color=#447700>!  wg * alpha    array of vertical differencing used (=1. for upstream).<a name='315'></font>
<font color=#447700>!  w  * cape     convective available potential energy.<a name='316'></font>
<font color=#447700>!  wg * capeg    gathered convective available potential energy.<a name='317'></font>
<font color=#447700>!  c  * capelmt  threshold value for cape for deep convection.<a name='318'></font>
<font color=#447700>!  ic  * cpres    specific heat at constant pressure in j/kg-degk.<a name='319'></font>
<font color=#447700>!  i  * dpp      <a name='320'></font>
<font color=#447700>!  ic  * delt     length of model time-step in seconds.<a name='321'></font>
<font color=#447700>!  wg * dp       layer thickness in mbs (between upper/lower interface).<a name='322'></font>
<font color=#447700>!  wg * dqdt     mixing ratio tendency at gathered points.<a name='323'></font>
<font color=#447700>!  wg * dsdt     dry static energy ("temp") tendency at gathered points.<a name='324'></font>
<font color=#447700>!  wg * dudt     u-wind tendency at gathered points.<a name='325'></font>
<font color=#447700>!  wg * dvdt     v-wind tendency at gathered points.<a name='326'></font>
<font color=#447700>!  wg * dsubcld  layer thickness in mbs between lcl and maxi.<a name='327'></font>
<font color=#447700>!  ic  * grav     acceleration due to gravity in m/sec2.<a name='328'></font>
<font color=#447700>!  wg * du       detrainment in updraft. specified in mid-layer<a name='329'></font>
<font color=#447700>!  wg * ed       entrainment in downdraft.<a name='330'></font>
<font color=#447700>!  wg * eu       entrainment in updraft.<a name='331'></font>
<font color=#447700>!  wg * hmn      moist static energy.<a name='332'></font>
<font color=#447700>!  wg * hsat     saturated moist static energy.<a name='333'></font>
<font color=#447700>!  w  * ideep    holds position of gathered points vs longitude index.<a name='334'></font>
<font color=#447700>!  ic  * pver     number of model levels.<a name='335'></font>
<font color=#447700>!  wg * j0       detrainment initiation level index.<a name='336'></font>
<font color=#447700>!  wg * jd       downdraft   initiation level index.<a name='337'></font>
<font color=#447700>!  ic  * jlatpr   gaussian latitude index for printing grids (if needed).<a name='338'></font>
<font color=#447700>!  wg * jt       top  level index of deep cumulus convection.<a name='339'></font>
<font color=#447700>!  w  * lcl      base level index of deep cumulus convection.<a name='340'></font>
<font color=#447700>!  wg * lclg     gathered values of lcl.<a name='341'></font>
<font color=#447700>!  w  * lel      index of highest theoretical convective plume.<a name='342'></font>
<font color=#447700>!  wg * lelg     gathered values of lel.<a name='343'></font>
<font color=#447700>!  w  * lon      index of onset level for deep convection.<a name='344'></font>
<font color=#447700>!  w  * maxi     index of level with largest moist static energy.<a name='345'></font>
<font color=#447700>!  wg * maxg     gathered values of maxi.<a name='346'></font>
<font color=#447700>!  wg * mb       cloud base mass flux.<a name='347'></font>
<font color=#447700>!  wg * mc       net upward (scaled by mb) cloud mass flux.<a name='348'></font>
<font color=#447700>!  wg * md       downward cloud mass flux (positive up).<a name='349'></font>
<font color=#447700>!  wg * mu       upward   cloud mass flux (positive up). specified<a name='350'></font>
<font color=#447700>!                at interface<a name='351'></font>
<font color=#447700>!  ic  * msg      number of missing moisture levels at the top of model.<a name='352'></font>
<font color=#447700>!  w  * p        grid slice of ambient mid-layer pressure in mbs.<a name='353'></font>
<font color=#447700>!  i  * pblt     row of pbl top indices.<a name='354'></font>
<font color=#447700>!  w  * pcpdh    scaled surface pressure.<a name='355'></font>
<font color=#447700>!  w  * pf       grid slice of ambient interface pressure in mbs.<a name='356'></font>
<font color=#447700>!  wg * pg       grid slice of gathered values of p.<a name='357'></font>
<font color=#447700>!  w  * q        grid slice of mixing ratio.<a name='358'></font>
<font color=#447700>!  wg * qd       grid slice of mixing ratio in downdraft.<a name='359'></font>
<font color=#447700>!  wg * qg       grid slice of gathered values of q.<a name='360'></font>
<font color=#447700>!  i/o * qh       grid slice of specific humidity.<a name='361'></font>
<font color=#447700>!  w  * qh0      grid slice of initial specific humidity.<a name='362'></font>
<font color=#447700>!  wg * qhat     grid slice of upper interface mixing ratio.<a name='363'></font>
<font color=#447700>!  wg * ql       grid slice of cloud liquid water.<a name='364'></font>
<font color=#447700>!  wg * qs       grid slice of saturation mixing ratio.<a name='365'></font>
<font color=#447700>!  w  * qstp     grid slice of parcel temp. saturation mixing ratio.<a name='366'></font>
<font color=#447700>!  wg * qstpg    grid slice of gathered values of qstp.<a name='367'></font>
<font color=#447700>!  wg * qu       grid slice of mixing ratio in updraft.<a name='368'></font>
<font color=#447700>!  ic  * rgas     dry air gas constant.<a name='369'></font>
<font color=#447700>!  wg * rl       latent heat of vaporization.<a name='370'></font>
<font color=#447700>!  w  * s        grid slice of scaled dry static energy (t+gz/cp).<a name='371'></font>
<font color=#447700>!  wg * sd       grid slice of dry static energy in downdraft.<a name='372'></font>
<font color=#447700>!  wg * sg       grid slice of gathered values of s.<a name='373'></font>
<font color=#447700>!  wg * shat     grid slice of upper interface dry static energy.<a name='374'></font>
<font color=#447700>!  wg * su       grid slice of dry static energy in updraft.<a name='375'></font>
<font color=#447700>!  i/o * t       <a name='376'></font>
<font color=#447700>!  o  * jctop    row of top-of-deep-convection indices passed out.<a name='377'></font>
<font color=#447700>!  O  * jcbot    row of base of cloud indices passed out.<a name='378'></font>
<font color=#447700>!  wg * tg       grid slice of gathered values of t.<a name='379'></font>
<font color=#447700>!  w  * tl       row of parcel temperature at lcl.<a name='380'></font>
<font color=#447700>!  wg * tlg      grid slice of gathered values of tl.<a name='381'></font>
<font color=#447700>!  w  * tp       grid slice of parcel temperatures.<a name='382'></font>
<font color=#447700>!  wg * tpg      grid slice of gathered values of tp.<a name='383'></font>
<font color=#447700>!  i/o * u        grid slice of u-wind (real).<a name='384'></font>
<font color=#447700>!  wg * ug       grid slice of gathered values of u.<a name='385'></font>
<font color=#447700>!  i/o * utg      grid slice of u-wind tendency (real).<a name='386'></font>
<font color=#447700>!  i/o * v        grid slice of v-wind (real).<a name='387'></font>
<font color=#447700>!  w  * va       work array re-used by called subroutines.<a name='388'></font>
<font color=#447700>!  wg * vg       grid slice of gathered values of v.<a name='389'></font>
<font color=#447700>!  i/o * vtg      grid slice of v-wind tendency (real).<a name='390'></font>
<font color=#447700>!  i  * w        grid slice of diagnosed large-scale vertical velocity.<a name='391'></font>
<font color=#447700>!  w  * z        grid slice of ambient mid-layer height in metres.<a name='392'></font>
<font color=#447700>!  w  * zf       grid slice of ambient interface height in metres.<a name='393'></font>
<font color=#447700>!  wg * zfg      grid slice of gathered values of zf.<a name='394'></font>
<font color=#447700>!  wg * zg       grid slice of gathered values of z.<a name='395'></font>
<font color=#447700>!<a name='396'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='397'></font>
<font color=#447700>!<a name='398'></font>
<font color=#447700>! multi-level i/o fields:<a name='399'></font>
<font color=#447700>!  i      =&gt; input arrays.<a name='400'></font>
<font color=#447700>!  i/o    =&gt; input/output arrays.<a name='401'></font>
<font color=#447700>!  w      =&gt; work arrays.<a name='402'></font>
<font color=#447700>!  wg     =&gt; work arrays operating only on gathered points.<a name='403'></font>
<font color=#447700>!  ic     =&gt; input data constants.<a name='404'></font>
<font color=#447700>!  c      =&gt; data constants pertaining to subroutine itself.<a name='405'></font>
<font color=#447700>!<a name='406'></font>
<font color=#447700>! input arguments<a name='407'></font>
<font color=#447700>!<a name='408'></font>
   integer, intent(in) :: lchnk                   <font color=#447700>! chunk identifier<a name='409'></font>
   integer, intent(in) :: ncol                    <font color=#447700>! number of atmospheric columns<a name='410'></font>
<a name='411'>
   real(r8), intent(in) :: t(pcols,pver)          <font color=#447700>! grid slice of temperature at mid-layer.<a name='412'></font>
   real(r8), intent(in) :: qh(pcols,pver,pcnst)   <font color=#447700>! grid slice of specific humidity.<a name='413'></font>
   real(r8), intent(in) :: pap(pcols,pver)     <a name='414'>
   real(r8), intent(in) :: paph(pcols,pver+1)<a name='415'>
   real(r8), intent(in) :: dpp(pcols,pver)        <font color=#447700>! local sigma half-level thickness (i.e. dshj).<a name='416'></font>
   real(r8), intent(in) :: zm(pcols,pver)<a name='417'>
   real(r8), intent(in) :: geos(pcols)<a name='418'>
   real(r8), intent(in) :: zi(pcols,pver+1)<a name='419'>
   real(r8), intent(in) :: pblh(pcols)<a name='420'>
   real(r8), intent(in) :: tpert(pcols)<a name='421'>
   real(r8), intent(in) :: landfrac(pcols) <font color=#447700>! RBN Landfrac<a name='422'></font>
<font color=#447700>!<a name='423'></font>
<font color=#447700>! output arguments<a name='424'></font>
<font color=#447700>!<a name='425'></font>
   real(r8), intent(out) :: qtnd(pcols,pver)           <font color=#447700>! specific humidity tendency (kg/kg/s)<a name='426'></font>
   real(r8), intent(out) :: heat(pcols,pver)           <font color=#447700>! heating rate (dry static energy tendency, W/kg)<a name='427'></font>
   real(r8), intent(out) :: mcon(pcols,pverp)<a name='428'>
   real(r8), intent(out) :: dlf(pcols,pver)    <font color=#447700>! scattrd version of the detraining cld h2o tend<a name='429'></font>
   real(r8), intent(out) :: pflx(pcols,pverp)  <font color=#447700>! scattered precip flux at each level<a name='430'></font>
   real(r8), intent(out) :: cme(pcols,pver)<a name='431'>
   real(r8), intent(out) :: cape(pcols)        <font color=#447700>! w  convective available potential energy.<a name='432'></font>
   real(r8), intent(out) :: zdu(pcols,pver)<a name='433'>
   real(r8), intent(out) :: rprd(pcols,pver)     <font color=#447700>! rain production rate<a name='434'></font>
<font color=#447700>! move these vars from local storage to output so that convective<a name='435'></font>
<font color=#447700>! transports can be done in outside of conv_cam.<a name='436'></font>
   real(r8), intent(out) :: mu(pcols,pver)<a name='437'>
   real(r8), intent(out) :: eu(pcols,pver)<a name='438'>
   real(r8), intent(out) :: du(pcols,pver)<a name='439'>
   real(r8), intent(out) :: md(pcols,pver)<a name='440'>
   real(r8), intent(out) :: ed(pcols,pver)<a name='441'>
   real(r8), intent(out) :: dp(pcols,pver)       <font color=#447700>! wg layer thickness in mbs (between upper/lower interface).<a name='442'></font>
   real(r8), intent(out) :: dsubcld(pcols)       <font color=#447700>! wg layer thickness in mbs between lcl and maxi.<a name='443'></font>
   real(r8), intent(out) :: jctop(pcols)  <font color=#447700>! o row of top-of-deep-convection indices passed out.<a name='444'></font>
   real(r8), intent(out) :: jcbot(pcols)  <font color=#447700>! o row of base of cloud indices passed out.<a name='445'></font>
   real(r8), intent(out) :: prec(pcols)<a name='446'>
   real(r8), intent(out) :: rliq(pcols) <font color=#447700>! reserved liquid (not yet in cldliq) for energy integrals<a name='447'></font>
<a name='448'>
   real(r8) zs(pcols)<a name='449'>
   real(r8) dlg(pcols,pver)    <font color=#447700>! gathrd version of the detraining cld h2o tend<a name='450'></font>
   real(r8) pflxg(pcols,pverp) <font color=#447700>! gather precip flux at each level<a name='451'></font>
   real(r8) cug(pcols,pver)    <font color=#447700>! gathered condensation rate<a name='452'></font>
   real(r8) evpg(pcols,pver)   <font color=#447700>! gathered evap rate of rain in downdraft<a name='453'></font>
   real(r8) mumax(pcols)<a name='454'>
   integer jt(pcols)                          <font color=#447700>! wg top  level index of deep cumulus convection.<a name='455'></font>
   integer maxg(pcols)                        <font color=#447700>! wg gathered values of maxi.<a name='456'></font>
   integer ideep(pcols)                       <font color=#447700>! w holds position of gathered points vs longitude index.<a name='457'></font>
   integer lengath<a name='458'>
<font color=#447700>!     diagnostic field used by chem/wetdep codes<a name='459'></font>
   real(r8) ql(pcols,pver)                    <font color=#447700>! wg grid slice of cloud liquid water.<a name='460'></font>
<font color=#447700>!<a name='461'></font>
   real(r8) pblt(pcols)           <font color=#447700>! i row of pbl top indices.<a name='462'></font>
<a name='463'>
<a name='464'>
<a name='465'>
<a name='466'>
<font color=#447700>!<a name='467'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='468'></font>
<font color=#447700>!<a name='469'></font>
<font color=#447700>! general work fields (local variables):<a name='470'></font>
<font color=#447700>!<a name='471'></font>
   real(r8) q(pcols,pver)              <font color=#447700>! w  grid slice of mixing ratio.<a name='472'></font>
   real(r8) p(pcols,pver)              <font color=#447700>! w  grid slice of ambient mid-layer pressure in mbs.<a name='473'></font>
   real(r8) z(pcols,pver)              <font color=#447700>! w  grid slice of ambient mid-layer height in metres.<a name='474'></font>
   real(r8) s(pcols,pver)              <font color=#447700>! w  grid slice of scaled dry static energy (t+gz/cp).<a name='475'></font>
   real(r8) tp(pcols,pver)             <font color=#447700>! w  grid slice of parcel temperatures.<a name='476'></font>
   real(r8) zf(pcols,pver+1)           <font color=#447700>! w  grid slice of ambient interface height in metres.<a name='477'></font>
   real(r8) pf(pcols,pver+1)           <font color=#447700>! w  grid slice of ambient interface pressure in mbs.<a name='478'></font>
   real(r8) qstp(pcols,pver)           <font color=#447700>! w  grid slice of parcel temp. saturation mixing ratio.<a name='479'></font>
<a name='480'>
   real(r8) tl(pcols)                  <font color=#447700>! w  row of parcel temperature at lcl.<a name='481'></font>
<a name='482'>
   integer lcl(pcols)                  <font color=#447700>! w  base level index of deep cumulus convection.<a name='483'></font>
   integer lel(pcols)                  <font color=#447700>! w  index of highest theoretical convective plume.<a name='484'></font>
   integer lon(pcols)                  <font color=#447700>! w  index of onset level for deep convection.<a name='485'></font>
   integer maxi(pcols)                 <font color=#447700>! w  index of level with largest moist static energy.<a name='486'></font>
   integer index(pcols)<a name='487'>
   real(r8) precip<a name='488'>
<font color=#447700>!<a name='489'></font>
<font color=#447700>! gathered work fields:<a name='490'></font>
<font color=#447700>!<a name='491'></font>
   real(r8) qg(pcols,pver)             <font color=#447700>! wg grid slice of gathered values of q.<a name='492'></font>
   real(r8) tg(pcols,pver)             <font color=#447700>! w  grid slice of temperature at interface.<a name='493'></font>
   real(r8) pg(pcols,pver)             <font color=#447700>! wg grid slice of gathered values of p.<a name='494'></font>
   real(r8) zg(pcols,pver)             <font color=#447700>! wg grid slice of gathered values of z.<a name='495'></font>
   real(r8) sg(pcols,pver)             <font color=#447700>! wg grid slice of gathered values of s.<a name='496'></font>
   real(r8) tpg(pcols,pver)            <font color=#447700>! wg grid slice of gathered values of tp.<a name='497'></font>
   real(r8) zfg(pcols,pver+1)          <font color=#447700>! wg grid slice of gathered values of zf.<a name='498'></font>
   real(r8) qstpg(pcols,pver)          <font color=#447700>! wg grid slice of gathered values of qstp.<a name='499'></font>
   real(r8) ug(pcols,pver)             <font color=#447700>! wg grid slice of gathered values of u.<a name='500'></font>
   real(r8) vg(pcols,pver)             <font color=#447700>! wg grid slice of gathered values of v.<a name='501'></font>
   real(r8) cmeg(pcols,pver)<a name='502'>
<a name='503'>
   real(r8) rprdg(pcols,pver)           <font color=#447700>! wg gathered rain production rate<a name='504'></font>
   real(r8) capeg(pcols)               <font color=#447700>! wg gathered convective available potential energy.<a name='505'></font>
   real(r8) tlg(pcols)                 <font color=#447700>! wg grid slice of gathered values of tl.<a name='506'></font>
   real(r8) landfracg(pcols)            <font color=#447700>! wg grid slice of landfrac  <a name='507'></font>
<a name='508'>
   integer lclg(pcols)       <font color=#447700>! wg gathered values of lcl.<a name='509'></font>
   integer lelg(pcols)<a name='510'>
<font color=#447700>!<a name='511'></font>
<font color=#447700>! work fields arising from gathered calculations.<a name='512'></font>
<font color=#447700>!<a name='513'></font>
   real(r8) dqdt(pcols,pver)           <font color=#447700>! wg mixing ratio tendency at gathered points.<a name='514'></font>
   real(r8) dsdt(pcols,pver)           <font color=#447700>! wg dry static energy ("temp") tendency at gathered points.<a name='515'></font>
<font color=#447700>!      real(r8) alpha(pcols,pver)      ! array of vertical differencing used (=1. for upstream).<a name='516'></font>
   real(r8) sd(pcols,pver)             <font color=#447700>! wg grid slice of dry static energy in downdraft.<a name='517'></font>
   real(r8) qd(pcols,pver)             <font color=#447700>! wg grid slice of mixing ratio in downdraft.<a name='518'></font>
   real(r8) mc(pcols,pver)             <font color=#447700>! wg net upward (scaled by mb) cloud mass flux.<a name='519'></font>
   real(r8) qhat(pcols,pver)           <font color=#447700>! wg grid slice of upper interface mixing ratio.<a name='520'></font>
   real(r8) qu(pcols,pver)             <font color=#447700>! wg grid slice of mixing ratio in updraft.<a name='521'></font>
   real(r8) su(pcols,pver)             <font color=#447700>! wg grid slice of dry static energy in updraft.<a name='522'></font>
   real(r8) qs(pcols,pver)             <font color=#447700>! wg grid slice of saturation mixing ratio.<a name='523'></font>
   real(r8) shat(pcols,pver)           <font color=#447700>! wg grid slice of upper interface dry static energy.<a name='524'></font>
   real(r8) hmn(pcols,pver)            <font color=#447700>! wg moist static energy.<a name='525'></font>
   real(r8) hsat(pcols,pver)           <font color=#447700>! wg saturated moist static energy.<a name='526'></font>
   real(r8) qlg(pcols,pver)<a name='527'>
   real(r8) dudt(pcols,pver)           <font color=#447700>! wg u-wind tendency at gathered points.<a name='528'></font>
   real(r8) dvdt(pcols,pver)           <font color=#447700>! wg v-wind tendency at gathered points.<a name='529'></font>
<font color=#447700>!      real(r8) ud(pcols,pver)<a name='530'></font>
<font color=#447700>!      real(r8) vd(pcols,pver)<a name='531'></font>
<a name='532'>
   real(r8) mb(pcols)                  <font color=#447700>! wg cloud base mass flux.<a name='533'></font>
<a name='534'>
   integer jlcl(pcols)<a name='535'>
   integer j0(pcols)                 <font color=#447700>! wg detrainment initiation level index.<a name='536'></font>
   integer jd(pcols)                 <font color=#447700>! wg downdraft initiation level index.<a name='537'></font>
<a name='538'>
   real(r8) delt                     <font color=#447700>! length of model time-step in seconds.<a name='539'></font>
<a name='540'>
   integer i<a name='541'>
   integer ii<a name='542'>
   integer k<a name='543'>
   integer msg                      <font color=#447700>!  ic number of missing moisture levels at the top of model.<a name='544'></font>
   real(r8) qdifr<a name='545'>
   real(r8) sdifr<a name='546'>
<a name='547'>
<font color=#447700>!<a name='548'></font>
<font color=#447700>!--------------------------Data statements------------------------------<a name='549'></font>
<font color=#447700>!<a name='550'></font>
<font color=#447700>! Set internal variable "msg" (convection limit) to "limcnv-1"<a name='551'></font>
<font color=#447700>!<a name='552'></font>
   msg = limcnv - 1<a name='553'>
<font color=#447700>!<a name='554'></font>
<font color=#447700>! initialize necessary arrays.<a name='555'></font>
<font color=#447700>! zero out variables not used in cam<a name='556'></font>
<font color=#447700>!<a name='557'></font>
   qtnd(:,:) = 0._r8<a name='558'>
   heat(:,:) = 0._r8<a name='559'>
   mcon(:,:) = 0._r8<a name='560'>
   rliq(:ncol)   = 0._r8<a name='561'>
<font color=#447700>!<a name='562'></font>
<font color=#447700>! initialize convective tendencies<a name='563'></font>
<font color=#447700>!<a name='564'></font>
   prec(:ncol) = 0._r8<a name='565'>
   do k = 1,pver<a name='566'>
      do i = 1,ncol<a name='567'>
         dqdt(i,k)  = 0._r8<a name='568'>
         dsdt(i,k)  = 0._r8<a name='569'>
         dudt(i,k)  = 0._r8<a name='570'>
         dvdt(i,k)  = 0._r8<a name='571'>
         pflx(i,k)  = 0._r8<a name='572'>
         pflxg(i,k) = 0._r8<a name='573'>
         cme(i,k)   = 0._r8<a name='574'>
         rprd(i,k)  = 0._r8<a name='575'>
         zdu(i,k)   = 0._r8<a name='576'>
         ql(i,k)    = 0._r8<a name='577'>
         qlg(i,k)   = 0._r8<a name='578'>
         dlf(i,k)   = 0._r8<a name='579'>
         dlg(i,k)   = 0._r8<a name='580'>
      end do<a name='581'>
   end do<a name='582'>
   do i = 1,ncol<a name='583'>
      pflx(i,pverp) = 0<a name='584'>
      pflxg(i,pverp) = 0<a name='585'>
   end do<a name='586'>
<font color=#447700>!<a name='587'></font>
   do i = 1,ncol<a name='588'>
      pblt(i) = pver<a name='589'>
      dsubcld(i) = 0._r8<a name='590'>
<a name='591'>
      jctop(i) = pver<a name='592'>
      jcbot(i) = 1<a name='593'>
<a name='594'>
   end do<a name='595'>
<font color=#447700>!<a name='596'></font>
<font color=#447700>! calculate local pressure (mbs) and height (m) for both interface<a name='597'></font>
<font color=#447700>! and mid-layer locations.<a name='598'></font>
<font color=#447700>!<a name='599'></font>
   do i = 1,ncol<a name='600'>
      zs(i) = geos(i)*rgrav<a name='601'>
      pf(i,pver+1) = paph(i,pver+1)*0.01_r8<a name='602'>
      zf(i,pver+1) = zi(i,pver+1) + zs(i)<a name='603'>
   end do<a name='604'>
   do k = 1,pver<a name='605'>
      do i = 1,ncol<a name='606'>
         p(i,k) = pap(i,k)*0.01_r8<a name='607'>
         pf(i,k) = paph(i,k)*0.01_r8<a name='608'>
         z(i,k) = zm(i,k) + zs(i)<a name='609'>
         zf(i,k) = zi(i,k) + zs(i)<a name='610'>
      end do<a name='611'>
   end do<a name='612'>
<font color=#447700>!<a name='613'></font>
   do k = pver - 1,msg + 1,-1<a name='614'>
      do i = 1,ncol<a name='615'>
         if (abs(z(i,k)-zs(i)-pblh(i)) &lt; (zf(i,k)-zf(i,k+1))*0.5_r8) pblt(i) = k<a name='616'>
      end do<a name='617'>
   end do<a name='618'>
<font color=#447700>!<a name='619'></font>
<font color=#447700>! store incoming specific humidity field for subsequent calculation<a name='620'></font>
<font color=#447700>! of precipitation (through change in storage).<a name='621'></font>
<font color=#447700>! define dry static energy (normalized by cp).<a name='622'></font>
<font color=#447700>!<a name='623'></font>
   do k = 1,pver<a name='624'>
      do i = 1,ncol<a name='625'>
         q(i,k) = qh(i,k,1)<a name='626'>
         s(i,k) = t(i,k) + (grav/cpres)*z(i,k)<a name='627'>
         tp(i,k)=0.0_r8<a name='628'>
         shat(i,k) = s(i,k)<a name='629'>
         qhat(i,k) = q(i,k)<a name='630'>
      end do<a name='631'>
   end do<a name='632'>
<a name='633'>
   do i = 1,ncol<a name='634'>
      capeg(i) = 0._r8<a name='635'>
      lclg(i) = 1<a name='636'>
      lelg(i) = pver<a name='637'>
      maxg(i) = 1<a name='638'>
      tlg(i) = 400._r8<a name='639'>
      dsubcld(i) = 0._r8<a name='640'>
   end do<a name='641'>
#ifndef WRF_PORT<a name='642'>
   if( cam_physpkg_is('cam3')) then<a name='643'>
<a name='644'>
      <font color=#447700>!  For cam3 physics package, call non-dilute<a name='645'></font>
<a name='646'>
      call <A href='../../html_code/phys/module_cu_camzm.F.html#BUOYAN'>buoyan</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="BUOYAN_1">(lchnk   ,ncol    , &amp;<a name='647'>
                  q       ,t       ,p       ,z       ,pf       , &amp;<a name='648'>
                  tp      ,qstp    ,tl      ,rl      ,cape     , &amp;<a name='649'>
                  pblt    ,lcl     ,lel     ,lon     ,maxi     , &amp;<a name='650'>
                  rgas    ,grav    ,cpres   ,msg     , &amp;<a name='651'>
                  tpert   )<a name='652'>
   else<a name='653'>
#else<a name='654'>
<a name='655'>
      <font color=#447700>!  Evaluate Tparcel, qsat(Tparcel), buoyancy and CAPE, <a name='656'></font>
      <font color=#447700>!     lcl, lel, parcel launch level at index maxi()=hmax<a name='657'></font>
<a name='658'>
      call <A href='../../html_code/phys/module_cu_camzm.F.html#BUOYAN_DILUTE'>buoyan_dilute</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="BUOYAN_DILUTE_1">(lchnk   ,ncol    , &amp;<a name='659'>
                  q       ,t       ,p       ,z       ,pf       , &amp;<a name='660'>
                  tp      ,qstp    ,tl      ,rl      ,cape     , &amp;<a name='661'>
                  pblt    ,lcl     ,lel     ,lon     ,maxi     , &amp;<a name='662'>
                  rgas    ,grav    ,cpres   ,msg     , &amp;<a name='663'>
                  tpert   )<a name='664'>
#endif<a name='665'>
#ifndef WRF_PORT<a name='666'>
   end if<a name='667'>
#endif<a name='668'>
<a name='669'>
<font color=#447700>!<a name='670'></font>
<font color=#447700>! determine whether grid points will undergo some deep convection<a name='671'></font>
<font color=#447700>! (ideep=1) or not (ideep=0), based on values of cape,lcl,lel<a name='672'></font>
<font color=#447700>! (require cape.gt. 0 and lel&lt;lcl as minimum conditions).<a name='673'></font>
<font color=#447700>!<a name='674'></font>
   lengath = 0<a name='675'>
   do i=1,ncol<a name='676'>
      if (cape(i) &gt; capelmt) then<a name='677'>
         lengath = lengath + 1<a name='678'>
         index(lengath) = i<a name='679'>
      end if<a name='680'>
   end do<a name='681'>
<a name='682'>
   if (lengath.eq.0) return<a name='683'>
   do ii=1,lengath<a name='684'>
      i=index(ii)<a name='685'>
      ideep(ii)=i<a name='686'>
   end do<a name='687'>
<font color=#447700>!<a name='688'></font>
<font color=#447700>! obtain gathered arrays necessary for ensuing calculations.<a name='689'></font>
<font color=#447700>!<a name='690'></font>
   do k = 1,pver<a name='691'>
      do i = 1,lengath<a name='692'>
         dp(i,k) = 0.01_r8*dpp(ideep(i),k)<a name='693'>
         qg(i,k) = q(ideep(i),k)<a name='694'>
         tg(i,k) = t(ideep(i),k)<a name='695'>
         pg(i,k) = p(ideep(i),k)<a name='696'>
         zg(i,k) = z(ideep(i),k)<a name='697'>
         sg(i,k) = s(ideep(i),k)<a name='698'>
         tpg(i,k) = tp(ideep(i),k)<a name='699'>
         zfg(i,k) = zf(ideep(i),k)<a name='700'>
         qstpg(i,k) = qstp(ideep(i),k)<a name='701'>
         ug(i,k) = 0._r8<a name='702'>
         vg(i,k) = 0._r8<a name='703'>
      end do<a name='704'>
   end do<a name='705'>
<font color=#447700>!<a name='706'></font>
   do i = 1,lengath<a name='707'>
      zfg(i,pver+1) = zf(ideep(i),pver+1)<a name='708'>
   end do<a name='709'>
   do i = 1,lengath<a name='710'>
      capeg(i) = cape(ideep(i))<a name='711'>
      lclg(i) = lcl(ideep(i))<a name='712'>
      lelg(i) = lel(ideep(i))<a name='713'>
      maxg(i) = maxi(ideep(i))<a name='714'>
      tlg(i) = tl(ideep(i))<a name='715'>
      landfracg(i) = landfrac(ideep(i))<a name='716'>
   end do<a name='717'>
<font color=#447700>!<a name='718'></font>
<font color=#447700>! calculate sub-cloud layer pressure "thickness" for use in<a name='719'></font>
<font color=#447700>! closure and tendency routines.<a name='720'></font>
<font color=#447700>!<a name='721'></font>
   do k = msg + 1,pver<a name='722'>
      do i = 1,lengath<a name='723'>
         if (k &gt;= maxg(i)) then<a name='724'>
            dsubcld(i) = dsubcld(i) + dp(i,k)<a name='725'>
         end if<a name='726'>
      end do<a name='727'>
   end do<a name='728'>
<font color=#447700>!<a name='729'></font>
<font color=#447700>! define array of factors (alpha) which defines interfacial<a name='730'></font>
<font color=#447700>! values, as well as interfacial values for (q,s) used in<a name='731'></font>
<font color=#447700>! subsequent routines.<a name='732'></font>
<font color=#447700>!<a name='733'></font>
   do k = msg + 2,pver<a name='734'>
      do i = 1,lengath<a name='735'>
<font color=#447700>!            alpha(i,k) = 0.5<a name='736'></font>
         sdifr = 0._r8<a name='737'>
         qdifr = 0._r8<a name='738'>
         if (sg(i,k) &gt; 0._r8 .or. sg(i,k-1) &gt; 0._r8) &amp;<a name='739'>
            sdifr = abs((sg(i,k)-sg(i,k-1))/max(sg(i,k-1),sg(i,k)))<a name='740'>
         if (qg(i,k) &gt; 0._r8 .or. qg(i,k-1) &gt; 0._r8) &amp;<a name='741'>
            qdifr = abs((qg(i,k)-qg(i,k-1))/max(qg(i,k-1),qg(i,k)))<a name='742'>
         if (sdifr &gt; 1.E-6_r8) then<a name='743'>
            shat(i,k) = log(sg(i,k-1)/sg(i,k))*sg(i,k-1)*sg(i,k)/(sg(i,k-1)-sg(i,k))<a name='744'>
         else<a name='745'>
            shat(i,k) = 0.5_r8* (sg(i,k)+sg(i,k-1))<a name='746'>
         end if<a name='747'>
         if (qdifr &gt; 1.E-6_r8) then<a name='748'>
            qhat(i,k) = log(qg(i,k-1)/qg(i,k))*qg(i,k-1)*qg(i,k)/(qg(i,k-1)-qg(i,k))<a name='749'>
         else<a name='750'>
            qhat(i,k) = 0.5_r8* (qg(i,k)+qg(i,k-1))<a name='751'>
         end if<a name='752'>
      end do<a name='753'>
   end do<a name='754'>
<font color=#447700>!<a name='755'></font>
<font color=#447700>! obtain cloud properties.<a name='756'></font>
<font color=#447700>!<a name='757'></font>
<a name='758'>
   call <A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP'>cldprp</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CLDPRP_1">(lchnk   , &amp;<a name='759'>
               qg      ,tg      ,ug      ,vg      ,pg      , &amp;<a name='760'>
               zg      ,sg      ,mu      ,eu      ,du      , &amp;<a name='761'>
               md      ,ed      ,sd      ,qd      ,mc      , &amp;<a name='762'>
               qu      ,su      ,zfg     ,qs      ,hmn     , &amp;<a name='763'>
               hsat    ,shat    ,qlg     , &amp;<a name='764'>
               cmeg    ,maxg    ,lelg    ,jt      ,jlcl    , &amp;<a name='765'>
               maxg    ,j0      ,jd      ,rl      ,lengath , &amp;<a name='766'>
               rgas    ,grav    ,cpres   ,msg     , &amp;<a name='767'>
               pflxg   ,evpg    ,cug     ,rprdg   ,limcnv  ,landfracg)<a name='768'>
<font color=#447700>!<a name='769'></font>
<font color=#447700>! convert detrainment from units of "1/m" to "1/mb".<a name='770'></font>
<font color=#447700>!<a name='771'></font>
   do k = msg + 1,pver<a name='772'>
      do i = 1,lengath<a name='773'>
         du   (i,k) = du   (i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='774'>
         eu   (i,k) = eu   (i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='775'>
         ed   (i,k) = ed   (i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='776'>
         cug  (i,k) = cug  (i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='777'>
         cmeg (i,k) = cmeg (i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='778'>
         rprdg(i,k) = rprdg(i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='779'>
         evpg (i,k) = evpg (i,k)* (zfg(i,k)-zfg(i,k+1))/dp(i,k)<a name='780'>
      end do<a name='781'>
   end do<a name='782'>
<a name='783'>
   call <A href='../../html_code/phys/module_cu_camzm.F.html#CLOSURE'>closure</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CLOSURE_1">(lchnk   , &amp;<a name='784'>
                qg      ,tg      ,pg      ,zg      ,sg      , &amp;<a name='785'>
                tpg     ,qs      ,qu      ,su      ,mc      , &amp;<a name='786'>
                du      ,mu      ,md      ,qd      ,sd      , &amp;<a name='787'>
                qhat    ,shat    ,dp      ,qstpg   ,zfg     , &amp;<a name='788'>
                qlg     ,dsubcld ,mb      ,capeg   ,tlg     , &amp;<a name='789'>
                lclg    ,lelg    ,jt      ,maxg    ,1       , &amp;<a name='790'>
                lengath ,rgas    ,grav    ,cpres   ,rl      , &amp;<a name='791'>
                msg     ,capelmt    )<a name='792'>
<font color=#447700>!<a name='793'></font>
<font color=#447700>! limit cloud base mass flux to theoretical upper bound.<a name='794'></font>
<font color=#447700>!<a name='795'></font>
   do i=1,lengath<a name='796'>
      mumax(i) = 0<a name='797'>
   end do<a name='798'>
   do k=msg + 2,pver<a name='799'>
      do i=1,lengath<a name='800'>
        mumax(i) = max(mumax(i), mu(i,k)/dp(i,k))<a name='801'>
      end do<a name='802'>
   end do<a name='803'>
<a name='804'>
   do i=1,lengath<a name='805'>
      if (mumax(i) &gt; 0._r8) then<a name='806'>
         mb(i) = min(mb(i),0.5_r8/(delt*mumax(i)))<a name='807'>
      else<a name='808'>
         mb(i) = 0._r8<a name='809'>
      endif<a name='810'>
   end do<a name='811'>
   <font color=#447700>! If no_deep_pbl = .true., don't allow convection entirely <a name='812'></font>
   <font color=#447700>! within PBL (suggestion of Bjorn Stevens, 8-2000)<a name='813'></font>
<a name='814'>
   if (no_deep_pbl) then<a name='815'>
      do i=1,lengath<a name='816'>
         if (zm(ideep(i),jt(i)) &lt; pblh(ideep(i))) mb(i) = 0<a name='817'>
      end do<a name='818'>
   end if<a name='819'>
<a name='820'>
<a name='821'>
   do k=msg+1,pver<a name='822'>
      do i=1,lengath<a name='823'>
         mu   (i,k)  = mu   (i,k)*mb(i)<a name='824'>
         md   (i,k)  = md   (i,k)*mb(i)<a name='825'>
         mc   (i,k)  = mc   (i,k)*mb(i)<a name='826'>
         du   (i,k)  = du   (i,k)*mb(i)<a name='827'>
         eu   (i,k)  = eu   (i,k)*mb(i)<a name='828'>
         ed   (i,k)  = ed   (i,k)*mb(i)<a name='829'>
         cmeg (i,k)  = cmeg (i,k)*mb(i)<a name='830'>
         rprdg(i,k)  = rprdg(i,k)*mb(i)<a name='831'>
         cug  (i,k)  = cug  (i,k)*mb(i)<a name='832'>
         evpg (i,k)  = evpg (i,k)*mb(i)<a name='833'>
         pflxg(i,k+1)= pflxg(i,k+1)*mb(i)*100._r8/grav<a name='834'>
      end do<a name='835'>
   end do<a name='836'>
<font color=#447700>!<a name='837'></font>
<font color=#447700>! compute temperature and moisture changes due to convection.<a name='838'></font>
<font color=#447700>!<a name='839'></font>
   call <A href='../../html_code/phys/module_cu_camzm.F.html#Q1Q2_PJR'>q1q2_pjr</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONVR' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="Q1Q2_PJR_1">(lchnk   , &amp;<a name='840'>
                 dqdt    ,dsdt    ,qg      ,qs      ,qu      , &amp;<a name='841'>
                 su      ,du      ,qhat    ,shat    ,dp      , &amp;<a name='842'>
                 mu      ,md      ,sd      ,qd      ,qlg     , &amp;<a name='843'>
                 dsubcld ,jt      ,maxg    ,1       ,lengath , &amp;<a name='844'>
                 cpres   ,rl      ,msg     ,          &amp;<a name='845'>
                 dlg     ,evpg    ,cug     )<a name='846'>
<font color=#447700>!<a name='847'></font>
<font color=#447700>! gather back temperature and mixing ratio.<a name='848'></font>
<font color=#447700>!<a name='849'></font>
   do k = msg + 1,pver<a name='850'>
<font color=#447700>!DIR$ CONCURRENT<a name='851'></font>
      do i = 1,lengath<a name='852'>
<font color=#447700>!<a name='853'></font>
<font color=#447700>! q is updated to compute net precip.<a name='854'></font>
<font color=#447700>!<a name='855'></font>
         q(ideep(i),k) = qh(ideep(i),k,1) + 2._r8*delt*dqdt(i,k)<a name='856'>
         qtnd(ideep(i),k) = dqdt (i,k)<a name='857'>
         cme (ideep(i),k) = cmeg (i,k)<a name='858'>
         rprd(ideep(i),k) = rprdg(i,k)<a name='859'>
         zdu (ideep(i),k) = du   (i,k)<a name='860'>
         mcon(ideep(i),k) = mc   (i,k)<a name='861'>
         heat(ideep(i),k) = dsdt (i,k)*cpres<a name='862'>
         dlf (ideep(i),k) = dlg  (i,k)<a name='863'>
         pflx(ideep(i),k) = pflxg(i,k)<a name='864'>
         ql  (ideep(i),k) = qlg  (i,k)<a name='865'>
      end do<a name='866'>
   end do<a name='867'>
<font color=#447700>!<a name='868'></font>
<font color=#447700>!DIR$ CONCURRENT<a name='869'></font>
   do i = 1,lengath<a name='870'>
      jctop(ideep(i)) = jt(i)<a name='871'>
<font color=#447700>!++bee<a name='872'></font>
      jcbot(ideep(i)) = maxg(i)<a name='873'>
<font color=#447700>!--bee<a name='874'></font>
      pflx(ideep(i),pverp) = pflxg(i,pverp)<a name='875'>
   end do<a name='876'>
<a name='877'>
<font color=#447700>! Compute precip by integrating change in water vapor minus detrained cloud water<a name='878'></font>
   do k = pver,msg + 1,-1<a name='879'>
      do i = 1,ncol<a name='880'>
         prec(i) = prec(i) - dpp(i,k)* (q(i,k)-qh(i,k,1)) - dpp(i,k)*dlf(i,k)*2._r8*delt<a name='881'>
      end do<a name='882'>
   end do<a name='883'>
<a name='884'>
<font color=#447700>! obtain final precipitation rate in m/s.<a name='885'></font>
   do i = 1,ncol<a name='886'>
      prec(i) = rgrav*max(prec(i),0._r8)/ (2._r8*delt)/1000._r8<a name='887'>
   end do<a name='888'>
<a name='889'>
<font color=#447700>! Compute reserved liquid (not yet in cldliq) for energy integrals.<a name='890'></font>
<font color=#447700>! Treat rliq as flux out bottom, to be added back later.<a name='891'></font>
   do k = 1, pver<a name='892'>
      do i = 1, ncol<a name='893'>
         rliq(i) = rliq(i) + dlf(i,k)*dpp(i,k)/gravit<a name='894'>
      end do<a name='895'>
   end do<a name='896'>
   rliq(:ncol) = rliq(:ncol) /1000._r8<a name='897'>
<a name='898'>
   return<a name='899'>
end subroutine zm_convr<a name='900'>
<a name='901'>
<font color=#447700>!===============================================================================<a name='902'></font>
<A NAME='ZM_CONV_EVAP'><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONV_EVAP' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='903'>
<font color=#993300>subroutine </font><font color=#cc0000>zm_conv_evap</font>(ncol,lchnk, &amp; <A href='../../call_to/ZM_CONV_EVAP.html' TARGET='index'>1</A>,<A href='../../call_from/ZM_CONV_EVAP.html' TARGET='index'>3</A><a name='904'>
     t,pmid,pdel,q, &amp;<a name='905'>
     tend_s, tend_s_snwprd, tend_s_snwevmlt, tend_q, &amp;<a name='906'>
     prdprec, cldfrc, deltat,  &amp;<a name='907'>
     prec, snow, ntprprd, ntsnprd, flxprec, flxsnow )<a name='908'>
<a name='909'>
<font color=#447700>!-----------------------------------------------------------------------<a name='910'></font>
<font color=#447700>! Compute tendencies due to evaporation of rain from ZM scheme<a name='911'></font>
<font color=#447700>!--<a name='912'></font>
<font color=#447700>! Compute the total precipitation and snow fluxes at the surface.<a name='913'></font>
<font color=#447700>! Add in the latent heat of fusion for snow formation and melt, since it not dealt with<a name='914'></font>
<font color=#447700>! in the Zhang-MacFarlane parameterization.<a name='915'></font>
<font color=#447700>! Evaporate some of the precip directly into the environment using a Sundqvist type algorithm<a name='916'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='917'></font>
<a name='918'>
    use <A href='../../html_code/phys/module_cam_wv_saturation.F.html#WV_SATURATION'>wv_saturation</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONV_EVAP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WV_SATURATION_11">,  only: aqsat<a name='919'>
#ifndef WRF_PORT<a name='920'>
    use phys_grid, only: get_rlat_all_p<a name='921'>
#endif<a name='922'>
<a name='923'>
<font color=#447700>!------------------------------Arguments--------------------------------<a name='924'></font>
    integer,intent(in) :: ncol, lchnk             <font color=#447700>! number of columns and chunk index<a name='925'></font>
    real(r8),intent(in), dimension(pcols,pver) :: t          <font color=#447700>! temperature (K)<a name='926'></font>
    real(r8),intent(in), dimension(pcols,pver) :: pmid       <font color=#447700>! midpoint pressure (Pa) <a name='927'></font>
    real(r8),intent(in), dimension(pcols,pver) :: pdel       <font color=#447700>! layer thickness (Pa)<a name='928'></font>
    real(r8),intent(in), dimension(pcols,pver) :: q          <font color=#447700>! water vapor (kg/kg)<a name='929'></font>
    real(r8),intent(inout), dimension(pcols,pver) :: tend_s     <font color=#447700>! heating rate (J/kg/s)<a name='930'></font>
    real(r8),intent(inout), dimension(pcols,pver) :: tend_q     <font color=#447700>! water vapor tendency (kg/kg/s)<a name='931'></font>
    real(r8),intent(out  ), dimension(pcols,pver) :: tend_s_snwprd <font color=#447700>! Heating rate of snow production<a name='932'></font>
    real(r8),intent(out  ), dimension(pcols,pver) :: tend_s_snwevmlt <font color=#447700>! Heating rate of evap/melting of snow<a name='933'></font>
    <a name='934'>
<a name='935'>
<a name='936'>
    real(r8), intent(in   ) :: prdprec(pcols,pver)<font color=#447700>! precipitation production (kg/ks/s)<a name='937'></font>
    real(r8), intent(in   ) :: cldfrc(pcols,pver) <font color=#447700>! cloud fraction<a name='938'></font>
    real(r8), intent(in   ) :: deltat             <font color=#447700>! time step<a name='939'></font>
<a name='940'>
    real(r8), intent(inout) :: prec(pcols)        <font color=#447700>! Convective-scale preciptn rate<a name='941'></font>
    real(r8), intent(out)   :: snow(pcols)        <font color=#447700>! Convective-scale snowfall rate<a name='942'></font>
<font color=#447700>!<a name='943'></font>
<font color=#447700>!---------------------------Local storage-------------------------------<a name='944'></font>
<a name='945'>
    real(r8) :: est    (pcols,pver)    <font color=#447700>! Saturation vapor pressure<a name='946'></font>
    real(r8) :: fice   (pcols,pver)    <font color=#447700>! ice fraction in precip production<a name='947'></font>
    real(r8) :: fsnow_conv(pcols,pver) <font color=#447700>! snow fraction in precip production<a name='948'></font>
    real(r8) :: qsat   (pcols,pver)    <font color=#447700>! saturation specific humidity<a name='949'></font>
    real(r8),intent(out) :: flxprec(pcols,pverp)   <font color=#447700>! Convective-scale flux of precip at interfaces (kg/m2/s)<a name='950'></font>
    real(r8),intent(out) :: flxsnow(pcols,pverp)   <font color=#447700>! Convective-scale flux of snow   at interfaces (kg/m2/s)<a name='951'></font>
    real(r8),intent(out) :: ntprprd(pcols,pver)    <font color=#447700>! net precip production in layer<a name='952'></font>
    real(r8),intent(out) :: ntsnprd(pcols,pver)    <font color=#447700>! net snow production in layer<a name='953'></font>
    real(r8) :: work1                  <font color=#447700>! temp variable (pjr)<a name='954'></font>
    real(r8) :: work2                  <font color=#447700>! temp variable (pjr)<a name='955'></font>
<a name='956'>
    real(r8) :: evpvint(pcols)         <font color=#447700>! vertical integral of evaporation<a name='957'></font>
    real(r8) :: evpprec(pcols)         <font color=#447700>! evaporation of precipitation (kg/kg/s)<a name='958'></font>
    real(r8) :: evpsnow(pcols)         <font color=#447700>! evaporation of snowfall (kg/kg/s)<a name='959'></font>
    real(r8) :: snowmlt(pcols)         <font color=#447700>! snow melt tendency in layer<a name='960'></font>
    real(r8) :: flxsntm(pcols)         <font color=#447700>! flux of snow into layer, after melting<a name='961'></font>
<a name='962'>
    real(r8) :: evplimit               <font color=#447700>! temp variable for evaporation limits<a name='963'></font>
    real(r8) :: rlat(pcols)<a name='964'>
<a name='965'>
    integer :: i,k                     <font color=#447700>! longitude,level indices<a name='966'></font>
<a name='967'>
<a name='968'>
<font color=#447700>!-----------------------------------------------------------------------<a name='969'></font>
<a name='970'>
<font color=#447700>! convert input precip to kg/m2/s<a name='971'></font>
    prec(:ncol) = prec(:ncol)*1000._r8<a name='972'>
<a name='973'>
<font color=#447700>! determine saturation vapor pressure<a name='974'></font>
    call <A href='../../html_code/phys/module_ra_cam_support.F.html#AQSAT'>aqsat</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONV_EVAP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="AQSAT_3"> (t    ,pmid  ,est    ,qsat    ,pcols   , &amp;<a name='975'>
         ncol ,pver  ,1       ,pver    )<a name='976'>
<a name='977'>
<font color=#447700>! determine ice fraction in rain production (use cloud water parameterization fraction at present)<a name='978'></font>
    call <A href='../../html_code/phys/module_cam_cldwat.F.html#CLDWAT_FICE'>cldwat_fice</A><A href='../../html_code/phys/module_cu_camzm.F.html#ZM_CONV_EVAP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CLDWAT_FICE_1">(ncol, t, fice, fsnow_conv)<a name='979'>
<a name='980'>
<font color=#447700>! zero the flux integrals on the top boundary<a name='981'></font>
    flxprec(:ncol,1) = 0._r8<a name='982'>
    flxsnow(:ncol,1) = 0._r8<a name='983'>
    evpvint(:ncol)   = 0._r8<a name='984'>
<a name='985'>
    do k = 1, pver<a name='986'>
       do i = 1, ncol<a name='987'>
<a name='988'>
<font color=#447700>! Melt snow falling into layer, if necessary. <a name='989'></font>
          if (t(i,k) &gt; tmelt) then<a name='990'>
             flxsntm(i) = 0._r8<a name='991'>
             snowmlt(i) = flxsnow(i,k) * gravit/ pdel(i,k)<a name='992'>
          else<a name='993'>
             flxsntm(i) = flxsnow(i,k)<a name='994'>
             snowmlt(i) = 0._r8<a name='995'>
          end if<a name='996'>
<a name='997'>
<font color=#447700>! relative humidity depression must be &gt; 0 for evaporation<a name='998'></font>
          evplimit = max(1._r8 - q(i,k)/qsat(i,k), 0._r8)<a name='999'>
<a name='1000'>
<font color=#447700>! total evaporation depends on flux in the top of the layer<a name='1001'></font>
<font color=#447700>! flux prec is the net production above layer minus evaporation into environmet<a name='1002'></font>
          evpprec(i) = ke * (1._r8 - cldfrc(i,k)) * evplimit * sqrt(flxprec(i,k))<a name='1003'>
<font color=#447700>!**********************************************************<a name='1004'></font>
<font color=#447700>!!          evpprec(i) = 0.    ! turn off evaporation for now<a name='1005'></font>
<font color=#447700>!**********************************************************<a name='1006'></font>
<a name='1007'>
<font color=#447700>! Don't let evaporation supersaturate layer (approx). Layer may already be saturated.<a name='1008'></font>
<font color=#447700>! Currently does not include heating/cooling change to qsat<a name='1009'></font>
          evplimit   = max(0._r8, (qsat(i,k)-q(i,k)) / deltat)<a name='1010'>
<a name='1011'>
<font color=#447700>! Don't evaporate more than is falling into the layer - do not evaporate rain formed<a name='1012'></font>
<font color=#447700>! in this layer but if precip production is negative, remove from the available precip<a name='1013'></font>
<font color=#447700>! Negative precip production occurs because of evaporation in downdrafts.<a name='1014'></font>
<font color=#447700>!!$          evplimit   = flxprec(i,k) * gravit / pdel(i,k) + min(prdprec(i,k), 0.)<a name='1015'></font>
          evplimit   = min(evplimit, flxprec(i,k) * gravit / pdel(i,k))<a name='1016'>
<a name='1017'>
<font color=#447700>! Total evaporation cannot exceed input precipitation<a name='1018'></font>
          evplimit   = min(evplimit, (prec(i) - evpvint(i)) * gravit / pdel(i,k))<a name='1019'>
<a name='1020'>
          evpprec(i) = min(evplimit, evpprec(i))<a name='1021'>
<a name='1022'>
<font color=#447700>! evaporation of snow depends on snow fraction of total precipitation in the top after melting<a name='1023'></font>
          if (flxprec(i,k) &gt; 0._r8) then<a name='1024'>
<font color=#447700>!            evpsnow(i) = evpprec(i) * flxsntm(i) / flxprec(i,k)<a name='1025'></font>
<font color=#447700>!            prevent roundoff problems<a name='1026'></font>
             work1 = min(max(0._r8,flxsntm(i)/flxprec(i,k)),1._r8)<a name='1027'>
             evpsnow(i) = evpprec(i) * work1<a name='1028'>
          else<a name='1029'>
             evpsnow(i) = 0._r8<a name='1030'>
          end if<a name='1031'>
<a name='1032'>
<font color=#447700>! vertically integrated evaporation<a name='1033'></font>
          evpvint(i) = evpvint(i) + evpprec(i) * pdel(i,k)/gravit<a name='1034'>
<a name='1035'>
<font color=#447700>! net precip production is production - evaporation<a name='1036'></font>
          ntprprd(i,k) = prdprec(i,k) - evpprec(i)<a name='1037'>
<font color=#447700>! net snow production is precip production * ice fraction - evaporation - melting<a name='1038'></font>
<font color=#447700>!pjrworks ntsnprd(i,k) = prdprec(i,k)*fice(i,k) - evpsnow(i) - snowmlt(i)<a name='1039'></font>
<font color=#447700>!pjrwrks2 ntsnprd(i,k) = prdprec(i,k)*fsnow_conv(i,k) - evpsnow(i) - snowmlt(i)<a name='1040'></font>
<font color=#447700>! the small amount added to flxprec in the work1 expression has been increased from <a name='1041'></font>
<font color=#447700>! 1e-36 to 8.64e-11 (1e-5 mm/day).  This causes the temperature based partitioning<a name='1042'></font>
<font color=#447700>! scheme to be used for small flxprec amounts.  This is to address error growth problems.<a name='1043'></font>
#ifdef PERGRO<a name='1044'>
          work1 = min(max(0._r8,flxsnow(i,k)/(flxprec(i,k)+8.64e-11_r8)),1._r8)<a name='1045'>
#else<a name='1046'>
          if (flxprec(i,k).gt.0._r8) then<a name='1047'>
             work1 = min(max(0._r8,flxsnow(i,k)/flxprec(i,k)),1._r8)<a name='1048'>
          else<a name='1049'>
             work1 = 0._r8<a name='1050'>
          endif<a name='1051'>
#endif<a name='1052'>
          work2 = max(fsnow_conv(i,k), work1)<a name='1053'>
          if (snowmlt(i).gt.0._r8) work2 = 0._r8<a name='1054'>
<font color=#447700>!         work2 = fsnow_conv(i,k)<a name='1055'></font>
          ntsnprd(i,k) = prdprec(i,k)*work2 - evpsnow(i) - snowmlt(i)<a name='1056'>
          tend_s_snwprd  (i,k) = prdprec(i,k)*work2*latice<a name='1057'>
          tend_s_snwevmlt(i,k) = - ( evpsnow(i) + snowmlt(i) )*latice<a name='1058'>
<a name='1059'>
<font color=#447700>! precipitation fluxes<a name='1060'></font>
          flxprec(i,k+1) = flxprec(i,k) + ntprprd(i,k) * pdel(i,k)/gravit<a name='1061'>
          flxsnow(i,k+1) = flxsnow(i,k) + ntsnprd(i,k) * pdel(i,k)/gravit<a name='1062'>
<a name='1063'>
<font color=#447700>! protect against rounding error<a name='1064'></font>
          flxprec(i,k+1) = max(flxprec(i,k+1), 0._r8)<a name='1065'>
          flxsnow(i,k+1) = max(flxsnow(i,k+1), 0._r8)<a name='1066'>
<font color=#447700>! more protection (pjr)<a name='1067'></font>
<font color=#447700>!         flxsnow(i,k+1) = min(flxsnow(i,k+1), flxprec(i,k+1))<a name='1068'></font>
<a name='1069'>
<font color=#447700>! heating (cooling) and moistening due to evaporation <a name='1070'></font>
<font color=#447700>! - latent heat of vaporization for precip production has already been accounted for<a name='1071'></font>
<font color=#447700>! - snow is contained in prec<a name='1072'></font>
          tend_s(i,k)   =-evpprec(i)*latvap + ntsnprd(i,k)*latice<a name='1073'>
          tend_q(i,k) = evpprec(i)<a name='1074'>
       end do<a name='1075'>
    end do<a name='1076'>
<a name='1077'>
<font color=#447700>! set output precipitation rates (m/s)<a name='1078'></font>
    prec(:ncol) = flxprec(:ncol,pver+1) / 1000._r8<a name='1079'>
    snow(:ncol) = flxsnow(:ncol,pver+1) / 1000._r8<a name='1080'>
<a name='1081'>
<font color=#447700>!**********************************************************<a name='1082'></font>
<font color=#447700>!!$    tend_s(:ncol,:)   = 0.      ! turn heating off<a name='1083'></font>
<font color=#447700>!**********************************************************<a name='1084'></font>
<a name='1085'>
  end subroutine zm_conv_evap<a name='1086'>
<a name='1087'>
<a name='1088'>
<a name='1089'>
<A NAME='CONVTRAN'><A href='../../html_code/phys/module_cu_camzm.F.html#CONVTRAN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1090'>
<font color=#993300>subroutine </font><font color=#cc0000>convtran</font>(lchnk   , &amp; <A href='../../call_to/CONVTRAN.html' TARGET='index'>2</A>,<A href='../../call_from/CONVTRAN.html' TARGET='index'>2</A><a name='1091'>
                    doconvtran,q       ,ncnst   ,mu      ,md      , &amp;<a name='1092'>
                    du      ,eu      ,ed      ,dp      ,dsubcld , &amp;<a name='1093'>
                    jt      ,mx      ,ideep   ,il1g    ,il2g    , &amp;<a name='1094'>
                    nstep   ,fracis  ,dqdt    ,dpdry   )<a name='1095'>
<font color=#447700>!----------------------------------------------------------------------- <a name='1096'></font>
<font color=#447700>! <a name='1097'></font>
<font color=#447700>! Purpose: <a name='1098'></font>
<font color=#447700>! Convective transport of trace species<a name='1099'></font>
<font color=#447700>!<a name='1100'></font>
<font color=#447700>! Mixing ratios may be with respect to either dry or moist air<a name='1101'></font>
<font color=#447700>! <a name='1102'></font>
<font color=#447700>! Method: <a name='1103'></font>
<font color=#447700>! &lt;Describe the algorithm(s) used in the routine.&gt; <a name='1104'></font>
<font color=#447700>! &lt;Also include any applicable external references.&gt; <a name='1105'></font>
<font color=#447700>! <a name='1106'></font>
<font color=#447700>! Author: P. Rasch<a name='1107'></font>
<font color=#447700>! <a name='1108'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='1109'></font>
   use <A href='../../html_code/phys/module_cam_shr_kind_mod.F.html#SHR_KIND_MOD'>shr_kind_mod</A><A href='../../html_code/phys/module_cu_camzm.F.html#CONVTRAN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SHR_KIND_MOD_23">, only: r8 =&gt; shr_kind_r8<a name='1110'>
   use <A href='../../html_code/phys/module_cam_constituents.F.html#CONSTITUENTS'>constituents</A><A href='../../html_code/phys/module_cu_camzm.F.html#CONVTRAN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CONSTITUENTS_15">,    only: cnst_get_type_byind<a name='1111'>
#ifndef WRF_PORT<a name='1112'>
   use ppgrid<a name='1113'>
   use abortutils, only: endrun<a name='1114'>
#endif<a name='1115'>
<a name='1116'>
   implicit none<a name='1117'>
<font color=#447700>!-----------------------------------------------------------------------<a name='1118'></font>
<font color=#447700>!<a name='1119'></font>
<font color=#447700>! Input arguments<a name='1120'></font>
<font color=#447700>!<a name='1121'></font>
   integer, intent(in) :: lchnk                 <font color=#447700>! chunk identifier<a name='1122'></font>
   integer, intent(in) :: ncnst                 <font color=#447700>! number of tracers to transport<a name='1123'></font>
   logical, intent(in) :: doconvtran(ncnst)     <font color=#447700>! flag for doing convective transport<a name='1124'></font>
   real(r8), intent(in) :: q(pcols,pver,ncnst)  <font color=#447700>! Tracer array including moisture<a name='1125'></font>
   real(r8), intent(in) :: mu(pcols,pver)       <font color=#447700>! Mass flux up<a name='1126'></font>
   real(r8), intent(in) :: md(pcols,pver)       <font color=#447700>! Mass flux down<a name='1127'></font>
   real(r8), intent(in) :: du(pcols,pver)       <font color=#447700>! Mass detraining from updraft<a name='1128'></font>
   real(r8), intent(in) :: eu(pcols,pver)       <font color=#447700>! Mass entraining from updraft<a name='1129'></font>
   real(r8), intent(in) :: ed(pcols,pver)       <font color=#447700>! Mass entraining from downdraft<a name='1130'></font>
   real(r8), intent(in) :: dp(pcols,pver)       <font color=#447700>! Delta pressure between interfaces<a name='1131'></font>
   real(r8), intent(in) :: dsubcld(pcols)       <font color=#447700>! Delta pressure from cloud base to sfc<a name='1132'></font>
   real(r8), intent(in) :: fracis(pcols,pver,ncnst) <font color=#447700>! fraction of tracer that is insoluble<a name='1133'></font>
<a name='1134'>
   integer, intent(in) :: jt(pcols)         <font color=#447700>! Index of cloud top for each column<a name='1135'></font>
   integer, intent(in) :: mx(pcols)         <font color=#447700>! Index of cloud top for each column<a name='1136'></font>
   integer, intent(in) :: ideep(pcols)      <font color=#447700>! Gathering array<a name='1137'></font>
   integer, intent(in) :: il1g              <font color=#447700>! Gathered min lon indices over which to operate<a name='1138'></font>
   integer, intent(in) :: il2g              <font color=#447700>! Gathered max lon indices over which to operate<a name='1139'></font>
   integer, intent(in) :: nstep             <font color=#447700>! Time step index<a name='1140'></font>
<a name='1141'>
   real(r8), intent(in) :: dpdry(pcols,pver)       <font color=#447700>! Delta pressure between interfaces<a name='1142'></font>
<a name='1143'>
<a name='1144'>
<font color=#447700>! input/output<a name='1145'></font>
<a name='1146'>
   real(r8), intent(out) :: dqdt(pcols,pver,ncnst)  <font color=#447700>! Tracer tendency array<a name='1147'></font>
<a name='1148'>
<font color=#447700>!--------------------------Local Variables------------------------------<a name='1149'></font>
<a name='1150'>
   integer i                 <font color=#447700>! Work index<a name='1151'></font>
   integer k                 <font color=#447700>! Work index<a name='1152'></font>
   integer kbm               <font color=#447700>! Highest altitude index of cloud base<a name='1153'></font>
   integer kk                <font color=#447700>! Work index<a name='1154'></font>
   integer kkp1              <font color=#447700>! Work index<a name='1155'></font>
   integer km1               <font color=#447700>! Work index<a name='1156'></font>
   integer kp1               <font color=#447700>! Work index<a name='1157'></font>
   integer ktm               <font color=#447700>! Highest altitude index of cloud top<a name='1158'></font>
   integer m                 <font color=#447700>! Work index<a name='1159'></font>
<a name='1160'>
   real(r8) cabv                 <font color=#447700>! Mix ratio of constituent above<a name='1161'></font>
   real(r8) cbel                 <font color=#447700>! Mix ratio of constituent below<a name='1162'></font>
   real(r8) cdifr                <font color=#447700>! Normalized diff between cabv and cbel<a name='1163'></font>
   real(r8) chat(pcols,pver)     <font color=#447700>! Mix ratio in env at interfaces<a name='1164'></font>
   real(r8) cond(pcols,pver)     <font color=#447700>! Mix ratio in downdraft at interfaces<a name='1165'></font>
   real(r8) const(pcols,pver)    <font color=#447700>! Gathered tracer array<a name='1166'></font>
   real(r8) fisg(pcols,pver)     <font color=#447700>! gathered insoluble fraction of tracer<a name='1167'></font>
   real(r8) conu(pcols,pver)     <font color=#447700>! Mix ratio in updraft at interfaces<a name='1168'></font>
   real(r8) dcondt(pcols,pver)   <font color=#447700>! Gathered tend array<a name='1169'></font>
   real(r8) small                <font color=#447700>! A small number<a name='1170'></font>
   real(r8) mbsth                <font color=#447700>! Threshold for mass fluxes<a name='1171'></font>
   real(r8) mupdudp              <font color=#447700>! A work variable<a name='1172'></font>
   real(r8) minc                 <font color=#447700>! A work variable<a name='1173'></font>
   real(r8) maxc                 <font color=#447700>! A work variable<a name='1174'></font>
   real(r8) fluxin               <font color=#447700>! A work variable<a name='1175'></font>
   real(r8) fluxout              <font color=#447700>! A work variable<a name='1176'></font>
   real(r8) netflux              <font color=#447700>! A work variable<a name='1177'></font>
<a name='1178'>
   real(r8) dutmp(pcols,pver)       <font color=#447700>! Mass detraining from updraft<a name='1179'></font>
   real(r8) eutmp(pcols,pver)       <font color=#447700>! Mass entraining from updraft<a name='1180'></font>
   real(r8) edtmp(pcols,pver)       <font color=#447700>! Mass entraining from downdraft<a name='1181'></font>
   real(r8) dptmp(pcols,pver)    <font color=#447700>! Delta pressure between interfaces<a name='1182'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='1183'></font>
<font color=#447700>!<a name='1184'></font>
   small = 1.e-36_r8<a name='1185'>
<font color=#447700>! mbsth is the threshold below which we treat the mass fluxes as zero (in mb/s)<a name='1186'></font>
   mbsth = 1.e-15_r8<a name='1187'>
<a name='1188'>
<font color=#447700>! Find the highest level top and bottom levels of convection<a name='1189'></font>
   ktm = pver<a name='1190'>
   kbm = pver<a name='1191'>
   do i = il1g, il2g<a name='1192'>
      ktm = min(ktm,jt(i))<a name='1193'>
      kbm = min(kbm,mx(i))<a name='1194'>
   end do<a name='1195'>
<a name='1196'>
<font color=#447700>! Loop ever each constituent<a name='1197'></font>
   do m = 2, ncnst<a name='1198'>
      if (doconvtran(m)) then<a name='1199'>
<a name='1200'>
         if (cnst_get_type_byind(m).eq.'dry') then<a name='1201'>
            do k = 1,pver<a name='1202'>
               do i =il1g,il2g<a name='1203'>
                  dptmp(i,k) = dpdry(i,k)<a name='1204'>
                  dutmp(i,k) = du(i,k)*dp(i,k)/dpdry(i,k)<a name='1205'>
                  eutmp(i,k) = eu(i,k)*dp(i,k)/dpdry(i,k)<a name='1206'>
                  edtmp(i,k) = ed(i,k)*dp(i,k)/dpdry(i,k)<a name='1207'>
               end do<a name='1208'>
            end do<a name='1209'>
         else<a name='1210'>
            do k = 1,pver<a name='1211'>
               do i =il1g,il2g<a name='1212'>
                  dptmp(i,k) = dp(i,k)<a name='1213'>
                  dutmp(i,k) = du(i,k)<a name='1214'>
                  eutmp(i,k) = eu(i,k)<a name='1215'>
                  edtmp(i,k) = ed(i,k)<a name='1216'>
               end do<a name='1217'>
            end do<a name='1218'>
         endif<a name='1219'>
<font color=#447700>!        dptmp = dp<a name='1220'></font>
<a name='1221'>
<font color=#447700>! Gather up the constituent and set tend to zero<a name='1222'></font>
         do k = 1,pver<a name='1223'>
            do i =il1g,il2g<a name='1224'>
               const(i,k) = q(ideep(i),k,m)<a name='1225'>
               fisg(i,k) = fracis(ideep(i),k,m)<a name='1226'>
            end do<a name='1227'>
         end do<a name='1228'>
<a name='1229'>
<font color=#447700>! From now on work only with gathered data<a name='1230'></font>
<a name='1231'>
<font color=#447700>! Interpolate environment tracer values to interfaces<a name='1232'></font>
         do k = 1,pver<a name='1233'>
            km1 = max(1,k-1)<a name='1234'>
            do i = il1g, il2g<a name='1235'>
               minc = min(const(i,km1),const(i,k))<a name='1236'>
               maxc = max(const(i,km1),const(i,k))<a name='1237'>
               if (minc &lt; 0) then<a name='1238'>
                  cdifr = 0._r8<a name='1239'>
               else<a name='1240'>
                  cdifr = abs(const(i,k)-const(i,km1))/max(maxc,small)<a name='1241'>
               endif<a name='1242'>
<a name='1243'>
<font color=#447700>! If the two layers differ significantly use a geometric averaging<a name='1244'></font>
<font color=#447700>! procedure<a name='1245'></font>
               if (cdifr &gt; 1.E-6_r8) then<a name='1246'>
                  cabv = max(const(i,km1),maxc*1.e-12_r8)<a name='1247'>
                  cbel = max(const(i,k),maxc*1.e-12_r8)<a name='1248'>
                  chat(i,k) = log(cabv/cbel)/(cabv-cbel)*cabv*cbel<a name='1249'>
<a name='1250'>
               else             <font color=#447700>! Small diff, so just arithmetic mean<a name='1251'></font>
                  chat(i,k) = 0.5_r8* (const(i,k)+const(i,km1))<a name='1252'>
               end if<a name='1253'>
<a name='1254'>
<font color=#447700>! Provisional up and down draft values<a name='1255'></font>
               conu(i,k) = chat(i,k)<a name='1256'>
               cond(i,k) = chat(i,k)<a name='1257'>
<a name='1258'>
<font color=#447700>!              provisional tends<a name='1259'></font>
               dcondt(i,k) = 0._r8<a name='1260'>
<a name='1261'>
            end do<a name='1262'>
         end do<a name='1263'>
<a name='1264'>
<font color=#447700>! Do levels adjacent to top and bottom<a name='1265'></font>
         k = 2<a name='1266'>
         km1 = 1<a name='1267'>
         kk = pver<a name='1268'>
         do i = il1g,il2g<a name='1269'>
            mupdudp = mu(i,kk) + dutmp(i,kk)*dptmp(i,kk)<a name='1270'>
            if (mupdudp &gt; mbsth) then<a name='1271'>
               conu(i,kk) = (+eutmp(i,kk)*fisg(i,kk)*const(i,kk)*dptmp(i,kk))/mupdudp<a name='1272'>
            endif<a name='1273'>
            if (md(i,k) &lt; -mbsth) then<a name='1274'>
               cond(i,k) =  (-edtmp(i,km1)*fisg(i,km1)*const(i,km1)*dptmp(i,km1))/md(i,k)<a name='1275'>
            endif<a name='1276'>
         end do<a name='1277'>
<a name='1278'>
<font color=#447700>! Updraft from bottom to top<a name='1279'></font>
         do kk = pver-1,1,-1<a name='1280'>
            kkp1 = min(pver,kk+1)<a name='1281'>
            do i = il1g,il2g<a name='1282'>
               mupdudp = mu(i,kk) + dutmp(i,kk)*dptmp(i,kk)<a name='1283'>
               if (mupdudp &gt; mbsth) then<a name='1284'>
                  conu(i,kk) = (  mu(i,kkp1)*conu(i,kkp1)+eutmp(i,kk)*fisg(i,kk)* &amp;<a name='1285'>
                                  const(i,kk)*dptmp(i,kk) )/mupdudp<a name='1286'>
               endif<a name='1287'>
            end do<a name='1288'>
         end do<a name='1289'>
<a name='1290'>
<font color=#447700>! Downdraft from top to bottom<a name='1291'></font>
         do k = 3,pver<a name='1292'>
            km1 = max(1,k-1)<a name='1293'>
            do i = il1g,il2g<a name='1294'>
               if (md(i,k) &lt; -mbsth) then<a name='1295'>
                  cond(i,k) =  (  md(i,km1)*cond(i,km1)-edtmp(i,km1)*fisg(i,km1)*const(i,km1) &amp;<a name='1296'>
                                  *dptmp(i,km1) )/md(i,k)<a name='1297'>
               endif<a name='1298'>
            end do<a name='1299'>
         end do<a name='1300'>
<a name='1301'>
<a name='1302'>
         do k = ktm,pver<a name='1303'>
            km1 = max(1,k-1)<a name='1304'>
            kp1 = min(pver,k+1)<a name='1305'>
            do i = il1g,il2g<a name='1306'>
<a name='1307'>
<font color=#447700>! version 1 hard to check for roundoff errors<a name='1308'></font>
<font color=#447700>!               dcondt(i,k) =<a name='1309'></font>
<font color=#447700>!     $                  +(+mu(i,kp1)* (conu(i,kp1)-chat(i,kp1))<a name='1310'></font>
<font color=#447700>!     $                    -mu(i,k)*   (conu(i,k)-chat(i,k))<a name='1311'></font>
<font color=#447700>!     $                    +md(i,kp1)* (cond(i,kp1)-chat(i,kp1))<a name='1312'></font>
<font color=#447700>!     $                    -md(i,k)*   (cond(i,k)-chat(i,k))<a name='1313'></font>
<font color=#447700>!     $                   )/dp(i,k)<a name='1314'></font>
<a name='1315'>
<font color=#447700>! version 2 hard to limit fluxes<a name='1316'></font>
<font color=#447700>!               fluxin =  mu(i,kp1)*conu(i,kp1) + mu(i,k)*chat(i,k)<a name='1317'></font>
<font color=#447700>!     $                 -(md(i,k)  *cond(i,k)   + md(i,kp1)*chat(i,kp1))<a name='1318'></font>
<font color=#447700>!               fluxout = mu(i,k)*conu(i,k)     + mu(i,kp1)*chat(i,kp1)<a name='1319'></font>
<font color=#447700>!     $                 -(md(i,kp1)*cond(i,kp1) + md(i,k)*chat(i,k))<a name='1320'></font>
<a name='1321'>
<font color=#447700>! version 3 limit fluxes outside convection to mass in appropriate layer<a name='1322'></font>
<font color=#447700>! these limiters are probably only safe for positive definite quantitities<a name='1323'></font>
<font color=#447700>! it assumes that mu and md already satify a courant number limit of 1<a name='1324'></font>
               fluxin =  mu(i,kp1)*conu(i,kp1)+ mu(i,k)*min(chat(i,k),const(i,km1)) &amp;<a name='1325'>
                         -(md(i,k)  *cond(i,k) + md(i,kp1)*min(chat(i,kp1),const(i,kp1)))<a name='1326'>
               fluxout = mu(i,k)*conu(i,k) + mu(i,kp1)*min(chat(i,kp1),const(i,k)) &amp;<a name='1327'>
                         -(md(i,kp1)*cond(i,kp1) + md(i,k)*min(chat(i,k),const(i,k)))<a name='1328'>
<a name='1329'>
               netflux = fluxin - fluxout<a name='1330'>
               if (abs(netflux) &lt; max(fluxin,fluxout)*1.e-12_r8) then<a name='1331'>
                  netflux = 0._r8<a name='1332'>
               endif<a name='1333'>
               dcondt(i,k) = netflux/dptmp(i,k)<a name='1334'>
            end do<a name='1335'>
         end do<a name='1336'>
<font color=#447700>! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%<a name='1337'></font>
<font color=#447700>!<a name='1338'></font>
<font color=#447700>!DIR$ NOINTERCHANGE<a name='1339'></font>
         do k = kbm,pver<a name='1340'>
            km1 = max(1,k-1)<a name='1341'>
            do i = il1g,il2g<a name='1342'>
               if (k == mx(i)) then<a name='1343'>
<a name='1344'>
<font color=#447700>! version 1<a name='1345'></font>
<font color=#447700>!                  dcondt(i,k) = (1./dsubcld(i))*<a name='1346'></font>
<font color=#447700>!     $              (-mu(i,k)*(conu(i,k)-chat(i,k))<a name='1347'></font>
<font color=#447700>!     $               -md(i,k)*(cond(i,k)-chat(i,k))<a name='1348'></font>
<font color=#447700>!     $              )<a name='1349'></font>
<a name='1350'>
<font color=#447700>! version 2<a name='1351'></font>
<font color=#447700>!                  fluxin =  mu(i,k)*chat(i,k) - md(i,k)*cond(i,k)<a name='1352'></font>
<font color=#447700>!                  fluxout = mu(i,k)*conu(i,k) - md(i,k)*chat(i,k)<a name='1353'></font>
<font color=#447700>! version 3<a name='1354'></font>
                  fluxin =  mu(i,k)*min(chat(i,k),const(i,km1)) - md(i,k)*cond(i,k)<a name='1355'>
                  fluxout = mu(i,k)*conu(i,k) - md(i,k)*min(chat(i,k),const(i,k))<a name='1356'>
<a name='1357'>
                  netflux = fluxin - fluxout<a name='1358'>
                  if (abs(netflux) &lt; max(fluxin,fluxout)*1.e-12_r8) then<a name='1359'>
                     netflux = 0._r8<a name='1360'>
                  endif<a name='1361'>
<font color=#447700>!                  dcondt(i,k) = netflux/dsubcld(i)<a name='1362'></font>
                  dcondt(i,k) = netflux/dptmp(i,k)<a name='1363'>
               else if (k &gt; mx(i)) then<a name='1364'>
<font color=#447700>!                  dcondt(i,k) = dcondt(i,k-1)<a name='1365'></font>
                  dcondt(i,k) = 0._r8<a name='1366'>
               end if<a name='1367'>
            end do<a name='1368'>
         end do<a name='1369'>
<a name='1370'>
<font color=#447700>! Initialize to zero everywhere, then scatter tendency back to full array<a name='1371'></font>
         dqdt(:,:,m) = 0._r8<a name='1372'>
         do k = 1,pver<a name='1373'>
            kp1 = min(pver,k+1)<a name='1374'>
<font color=#447700>!DIR$ CONCURRENT<a name='1375'></font>
            do i = il1g,il2g<a name='1376'>
               dqdt(ideep(i),k,m) = dcondt(i,k)<a name='1377'>
            end do<a name='1378'>
         end do<a name='1379'>
<a name='1380'>
      end if      <font color=#447700>! for doconvtran<a name='1381'></font>
<a name='1382'>
   end do<a name='1383'>
<a name='1384'>
   return<a name='1385'>
end subroutine convtran<a name='1386'>
<a name='1387'>
<font color=#447700>!=========================================================================================<a name='1388'></font>
<a name='1389'>
<A NAME='MOMTRAN'><A href='../../html_code/phys/module_cu_camzm.F.html#MOMTRAN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1390'>
<font color=#993300>subroutine </font><font color=#cc0000>momtran</font>(lchnk, ncol, &amp; <A href='../../call_to/MOMTRAN.html' TARGET='index'>1</A>,<A href='../../call_from/MOMTRAN.html' TARGET='index'>2</A><a name='1391'>
                    domomtran,q       ,ncnst   ,mu      ,md    , &amp;<a name='1392'>
                    du      ,eu      ,ed      ,dp      ,dsubcld , &amp;<a name='1393'>
                    jt      ,mx      ,ideep   ,il1g    ,il2g    , &amp;<a name='1394'>
                    nstep   ,dqdt    ,pguall     ,pgdall, icwu, icwd, dt, seten    )<a name='1395'>
<font color=#447700>!----------------------------------------------------------------------- <a name='1396'></font>
<font color=#447700>! <a name='1397'></font>
<font color=#447700>! Purpose: <a name='1398'></font>
<font color=#447700>! Convective transport of momentum<a name='1399'></font>
<font color=#447700>!<a name='1400'></font>
<font color=#447700>! Mixing ratios may be with respect to either dry or moist air<a name='1401'></font>
<font color=#447700>! <a name='1402'></font>
<font color=#447700>! Method: <a name='1403'></font>
<font color=#447700>! Based on the convtran subroutine by P. Rasch<a name='1404'></font>
<font color=#447700>! &lt;Also include any applicable external references.&gt; <a name='1405'></font>
<font color=#447700>! <a name='1406'></font>
<font color=#447700>! Author: J. Richter and P. Rasch<a name='1407'></font>
<font color=#447700>! <a name='1408'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='1409'></font>
   use <A href='../../html_code/phys/module_cam_shr_kind_mod.F.html#SHR_KIND_MOD'>shr_kind_mod</A><A href='../../html_code/phys/module_cu_camzm.F.html#MOMTRAN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SHR_KIND_MOD_24">, only: r8 =&gt; shr_kind_r8<a name='1410'>
#ifndef WRF_PORT<a name='1411'>
   use <A href='../../html_code/phys/module_cam_constituents.F.html#CONSTITUENTS'>constituents</A><A href='../../html_code/phys/module_cu_camzm.F.html#MOMTRAN' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CONSTITUENTS_16">,    only: cnst_get_type_byind<a name='1412'>
   use ppgrid<a name='1413'>
   use abortutils, only: endrun<a name='1414'>
#endif<a name='1415'>
<a name='1416'>
   implicit none<a name='1417'>
<font color=#447700>!-----------------------------------------------------------------------<a name='1418'></font>
<font color=#447700>!<a name='1419'></font>
<font color=#447700>! Input arguments<a name='1420'></font>
<font color=#447700>!<a name='1421'></font>
   integer, intent(in) :: lchnk                 <font color=#447700>! chunk identifier<a name='1422'></font>
   integer, intent(in) :: ncol                  <font color=#447700>! number of atmospheric columns<a name='1423'></font>
   integer, intent(in) :: ncnst                 <font color=#447700>! number of tracers to transport<a name='1424'></font>
   logical, intent(in) :: domomtran(ncnst)      <font color=#447700>! flag for doing convective transport<a name='1425'></font>
   real(r8), intent(in) :: q(pcols,pver,ncnst)  <font color=#447700>! Wind array<a name='1426'></font>
   real(r8), intent(in) :: mu(pcols,pver)       <font color=#447700>! Mass flux up<a name='1427'></font>
   real(r8), intent(in) :: md(pcols,pver)       <font color=#447700>! Mass flux down<a name='1428'></font>
   real(r8), intent(in) :: du(pcols,pver)       <font color=#447700>! Mass detraining from updraft<a name='1429'></font>
   real(r8), intent(in) :: eu(pcols,pver)       <font color=#447700>! Mass entraining from updraft<a name='1430'></font>
   real(r8), intent(in) :: ed(pcols,pver)       <font color=#447700>! Mass entraining from downdraft<a name='1431'></font>
   real(r8), intent(in) :: dp(pcols,pver)       <font color=#447700>! Delta pressure between interfaces<a name='1432'></font>
   real(r8), intent(in) :: dsubcld(pcols)       <font color=#447700>! Delta pressure from cloud base to sfc<a name='1433'></font>
   real(r8), intent(in)    :: dt                       <font color=#447700>!  time step in seconds : 2*delta_t<a name='1434'></font>
<a name='1435'>
   integer, intent(in) :: jt(pcols)         <font color=#447700>! Index of cloud top for each column<a name='1436'></font>
   integer, intent(in) :: mx(pcols)         <font color=#447700>! Index of cloud top for each column<a name='1437'></font>
   integer, intent(in) :: ideep(pcols)      <font color=#447700>! Gathering array<a name='1438'></font>
   integer, intent(in) :: il1g              <font color=#447700>! Gathered min lon indices over which to operate<a name='1439'></font>
   integer, intent(in) :: il2g              <font color=#447700>! Gathered max lon indices over which to operate<a name='1440'></font>
   integer, intent(in) :: nstep             <font color=#447700>! Time step index<a name='1441'></font>
<a name='1442'>
<a name='1443'>
<a name='1444'>
<font color=#447700>! input/output<a name='1445'></font>
<a name='1446'>
   real(r8), intent(out) :: dqdt(pcols,pver,ncnst)  <font color=#447700>! Tracer tendency array<a name='1447'></font>
<a name='1448'>
<font color=#447700>!--------------------------Local Variables------------------------------<a name='1449'></font>
<a name='1450'>
   integer i                 <font color=#447700>! Work index<a name='1451'></font>
   integer k                 <font color=#447700>! Work index<a name='1452'></font>
   integer kbm               <font color=#447700>! Highest altitude index of cloud base<a name='1453'></font>
   integer kk                <font color=#447700>! Work index<a name='1454'></font>
   integer kkp1              <font color=#447700>! Work index<a name='1455'></font>
   integer kkm1              <font color=#447700>! Work index<a name='1456'></font>
   integer km1               <font color=#447700>! Work index<a name='1457'></font>
   integer kp1               <font color=#447700>! Work index<a name='1458'></font>
   integer ktm               <font color=#447700>! Highest altitude index of cloud top<a name='1459'></font>
   integer m                 <font color=#447700>! Work index<a name='1460'></font>
   integer ii                 <font color=#447700>! Work index<a name='1461'></font>
<a name='1462'>
   real(r8) cabv                 <font color=#447700>! Mix ratio of constituent above<a name='1463'></font>
   real(r8) cbel                 <font color=#447700>! Mix ratio of constituent below<a name='1464'></font>
   real(r8) cdifr                <font color=#447700>! Normalized diff between cabv and cbel<a name='1465'></font>
   real(r8) chat(pcols,pver)     <font color=#447700>! Mix ratio in env at interfaces<a name='1466'></font>
   real(r8) cond(pcols,pver)     <font color=#447700>! Mix ratio in downdraft at interfaces<a name='1467'></font>
   real(r8) const(pcols,pver)    <font color=#447700>! Gathered wind array<a name='1468'></font>
   real(r8) conu(pcols,pver)     <font color=#447700>! Mix ratio in updraft at interfaces<a name='1469'></font>
   real(r8) dcondt(pcols,pver)   <font color=#447700>! Gathered tend array<a name='1470'></font>
   real(r8) small                <font color=#447700>! A small number<a name='1471'></font>
   real(r8) mbsth                <font color=#447700>! Threshold for mass fluxes<a name='1472'></font>
   real(r8) mupdudp              <font color=#447700>! A work variable<a name='1473'></font>
   real(r8) minc                 <font color=#447700>! A work variable<a name='1474'></font>
   real(r8) maxc                 <font color=#447700>! A work variable<a name='1475'></font>
   real(r8) fluxin               <font color=#447700>! A work variable<a name='1476'></font>
   real(r8) fluxout              <font color=#447700>! A work variable<a name='1477'></font>
   real(r8) netflux              <font color=#447700>! A work variable<a name='1478'></font>
<a name='1479'>
   real(r8) momcu                <font color=#447700>! constant for updraft pressure gradient term<a name='1480'></font>
   real(r8) momcd                <font color=#447700>! constant for downdraft pressure gradient term<a name='1481'></font>
   real(r8) sum                  <font color=#447700>! sum<a name='1482'></font>
   real(r8) sum2                  <font color=#447700>! sum2<a name='1483'></font>
 <a name='1484'>
   real(r8) mududp(pcols,pver) <font color=#447700>! working variable<a name='1485'></font>
   real(r8) mddudp(pcols,pver)     <font color=#447700>! working variable<a name='1486'></font>
<a name='1487'>
   real(r8) pgu(pcols,pver)      <font color=#447700>! Pressure gradient term for updraft<a name='1488'></font>
   real(r8) pgd(pcols,pver)      <font color=#447700>! Pressure gradient term for downdraft<a name='1489'></font>
<a name='1490'>
   real(r8),intent(out) ::  pguall(pcols,pver,ncnst)      <font color=#447700>! Apparent force from  updraft PG<a name='1491'></font>
   real(r8),intent(out) ::  pgdall(pcols,pver,ncnst)      <font color=#447700>! Apparent force from  downdraft PG<a name='1492'></font>
<a name='1493'>
   real(r8),intent(out) ::  icwu(pcols,pver,ncnst)      <font color=#447700>! In-cloud winds in updraft<a name='1494'></font>
   real(r8),intent(out) ::  icwd(pcols,pver,ncnst)      <font color=#447700>! In-cloud winds in downdraft<a name='1495'></font>
<a name='1496'>
   real(r8),intent(out) ::  seten(pcols,pver) <font color=#447700>! Dry static energy tendency<a name='1497'></font>
   real(r8)                 gseten(pcols,pver) <font color=#447700>! Gathered dry static energy tendency<a name='1498'></font>
<a name='1499'>
   real(r8)  mflux(pcols,pverp,ncnst)   <font color=#447700>! Gathered momentum flux<a name='1500'></font>
<a name='1501'>
   real(r8)  wind0(pcols,pver,ncnst)       <font color=#447700>!  gathered  wind before time step<a name='1502'></font>
   real(r8)  windf(pcols,pver,ncnst)       <font color=#447700>!  gathered  wind after time step<a name='1503'></font>
   real(r8) fkeb, fket, ketend_cons, ketend, utop, ubot, vtop, vbot, gset2<a name='1504'>
   <a name='1505'>
<a name='1506'>
<font color=#447700>!-----------------------------------------------------------------------<a name='1507'></font>
<font color=#447700>!<a name='1508'></font>
<a name='1509'>
<font color=#447700>! Initialize outgoing fields<a name='1510'></font>
   pguall(:,:,:)     = 0.0_r8<a name='1511'>
   pgdall(:,:,:)     = 0.0_r8<a name='1512'>
<font color=#447700>! Initialize in-cloud winds to environmental wind<a name='1513'></font>
   icwu(:ncol,:,:)       = q(:ncol,:,:)<a name='1514'>
   icwd(:ncol,:,:)       = q(:ncol,:,:)<a name='1515'>
<a name='1516'>
<font color=#447700>! Initialize momentum flux and  final winds<a name='1517'></font>
   mflux(:,:,:)       = 0.0_r8<a name='1518'>
   wind0(:,:,:)         = 0.0_r8<a name='1519'>
   windf(:,:,:)         = 0.0_r8<a name='1520'>
<a name='1521'>
<font color=#447700>! Initialize dry static energy<a name='1522'></font>
<a name='1523'>
   seten(:,:)         = 0.0_r8<a name='1524'>
   gseten(:,:)         = 0.0_r8<a name='1525'>
<a name='1526'>
<font color=#447700>! Define constants for parameterization<a name='1527'></font>
<a name='1528'>
   momcu = 0.4_r8<a name='1529'>
   momcd = 0.4_r8<a name='1530'>
<a name='1531'>
   small = 1.e-36_r8<a name='1532'>
<font color=#447700>! mbsth is the threshold below which we treat the mass fluxes as zero (in mb/s)<a name='1533'></font>
   mbsth = 1.e-15_r8<a name='1534'>
<a name='1535'>
<font color=#447700>! Find the highest level top and bottom levels of convection<a name='1536'></font>
   ktm = pver<a name='1537'>
   kbm = pver<a name='1538'>
   do i = il1g, il2g<a name='1539'>
      ktm = min(ktm,jt(i))<a name='1540'>
      kbm = min(kbm,mx(i))<a name='1541'>
   end do<a name='1542'>
<a name='1543'>
<font color=#447700>! Loop ever each wind component<a name='1544'></font>
   do m = 1, ncnst                    <font color=#447700>!start at m = 1 to transport momentum<a name='1545'></font>
      if (domomtran(m)) then<a name='1546'>
<a name='1547'>
<font color=#447700>! Gather up the winds and set tend to zero<a name='1548'></font>
         do k = 1,pver<a name='1549'>
            do i =il1g,il2g<a name='1550'>
               const(i,k) = q(ideep(i),k,m)<a name='1551'>
                wind0(i,k,m) = const(i,k)<a name='1552'>
            end do<a name='1553'>
         end do<a name='1554'>
<a name='1555'>
<a name='1556'>
<font color=#447700>! From now on work only with gathered data<a name='1557'></font>
<a name='1558'>
<font color=#447700>! Interpolate winds to interfaces<a name='1559'></font>
<a name='1560'>
         do k = 1,pver<a name='1561'>
            km1 = max(1,k-1)<a name='1562'>
            do i = il1g, il2g<a name='1563'>
<a name='1564'>
               <font color=#447700>! use arithmetic mean<a name='1565'></font>
               chat(i,k) = 0.5_r8* (const(i,k)+const(i,km1))<a name='1566'>
<a name='1567'>
<font color=#447700>! Provisional up and down draft values<a name='1568'></font>
               conu(i,k) = chat(i,k)<a name='1569'>
               cond(i,k) = chat(i,k)<a name='1570'>
<a name='1571'>
<font color=#447700>!              provisional tends<a name='1572'></font>
               dcondt(i,k) = 0._r8<a name='1573'>
<a name='1574'>
            end do<a name='1575'>
         end do<a name='1576'>
<a name='1577'>
<a name='1578'>
<font color=#447700>!<a name='1579'></font>
<font color=#447700>! Pressure Perturbation Term<a name='1580'></font>
<font color=#447700>! <a name='1581'></font>
<a name='1582'>
      <font color=#447700>!Top boundary:  assume mu is zero <a name='1583'></font>
<a name='1584'>
         k=1<a name='1585'>
         pgu(:il2g,k) = 0.0_r8<a name='1586'>
         pgd(:il2g,k) = 0.0_r8<a name='1587'>
<a name='1588'>
         do k=2,pver-1<a name='1589'>
            km1 = max(1,k-1)<a name='1590'>
            kp1 = min(pver,k+1)<a name='1591'>
            do i = il1g,il2g<a name='1592'>
            <a name='1593'>
               <font color=#447700>!interior points<a name='1594'></font>
<a name='1595'>
               mududp(i,k) =  ( mu(i,k) * (const(i,k)- const(i,km1))/dp(i,km1) &amp;<a name='1596'>
                           +  mu(i,kp1) * (const(i,kp1) - const(i,k))/dp(i,k))<a name='1597'>
<a name='1598'>
               pgu(i,k) = - momcu * 0.5_r8 * mududp(i,k)<a name='1599'>
                           <a name='1600'>
<a name='1601'>
               mddudp(i,k) =  ( md(i,k) * (const(i,k)- const(i,km1))/dp(i,km1) &amp;<a name='1602'>
                           +  md(i,kp1) * (const(i,kp1) - const(i,k))/dp(i,k))<a name='1603'>
<a name='1604'>
               pgd(i,k) = - momcd * 0.5_r8 * mddudp(i,k)<a name='1605'>
<a name='1606'>
<a name='1607'>
            end do<a name='1608'>
         end do<a name='1609'>
<a name='1610'>
       <font color=#447700>! bottom boundary <a name='1611'></font>
       k = pver<a name='1612'>
       km1 = max(1,k-1)<a name='1613'>
       do i=il1g,il2g<a name='1614'>
<a name='1615'>
          mududp(i,k) =   mu(i,k) * (const(i,k)- const(i,km1))/dp(i,km1)<a name='1616'>
          pgu(i,k) = - momcu *  mududp(i,k)<a name='1617'>
          <a name='1618'>
          mddudp(i,k) =   md(i,k) * (const(i,k)- const(i,km1))/dp(i,km1) <a name='1619'>
<a name='1620'>
          pgd(i,k) = - momcd * mddudp(i,k)<a name='1621'>
          <a name='1622'>
       end do<a name='1623'>
       <a name='1624'>
<a name='1625'>
<font color=#447700>!<a name='1626'></font>
<font color=#447700>! In-cloud velocity calculations<a name='1627'></font>
<font color=#447700>!<a name='1628'></font>
<a name='1629'>
<font color=#447700>! Do levels adjacent to top and bottom<a name='1630'></font>
         k = 2<a name='1631'>
         km1 = 1<a name='1632'>
         kk = pver<a name='1633'>
         kkm1 = max(1,kk-1)<a name='1634'>
         do i = il1g,il2g<a name='1635'>
            mupdudp = mu(i,kk) + du(i,kk)*dp(i,kk)<a name='1636'>
            if (mupdudp &gt; mbsth) then<a name='1637'>
                 <a name='1638'>
               conu(i,kk) = (+eu(i,kk)*const(i,kk)*dp(i,kk)+pgu(i,kk)*dp(i,kk))/mupdudp<a name='1639'>
            endif<a name='1640'>
            if (md(i,k) &lt; -mbsth) then<a name='1641'>
               cond(i,k) =  (-ed(i,km1)*const(i,km1)*dp(i,km1))-pgd(i,km1)*dp(i,km1)/md(i,k)<a name='1642'>
            endif<a name='1643'>
<a name='1644'>
                        <a name='1645'>
         end do<a name='1646'>
<a name='1647'>
<a name='1648'>
<a name='1649'>
<font color=#447700>! Updraft from bottom to top<a name='1650'></font>
         do kk = pver-1,1,-1<a name='1651'>
            kkm1 = max(1,kk-1)<a name='1652'>
            kkp1 = min(pver,kk+1)<a name='1653'>
            do i = il1g,il2g<a name='1654'>
               mupdudp = mu(i,kk) + du(i,kk)*dp(i,kk)<a name='1655'>
               if (mupdudp &gt; mbsth) then<a name='1656'>
            <a name='1657'>
                  conu(i,kk) = (  mu(i,kkp1)*conu(i,kkp1)+eu(i,kk)* &amp;<a name='1658'>
                                  const(i,kk)*dp(i,kk)+pgu(i,kk)*dp(i,kk))/mupdudp<a name='1659'>
               endif<a name='1660'>
            end do<a name='1661'>
<a name='1662'>
         end do<a name='1663'>
<a name='1664'>
<a name='1665'>
<font color=#447700>! Downdraft from top to bottom<a name='1666'></font>
         do k = 3,pver<a name='1667'>
            km1 = max(1,k-1)<a name='1668'>
            do i = il1g,il2g<a name='1669'>
               if (md(i,k) &lt; -mbsth) then<a name='1670'>
                            <a name='1671'>
                  cond(i,k) =  (  md(i,km1)*cond(i,km1)-ed(i,km1)*const(i,km1) &amp;<a name='1672'>
                                  *dp(i,km1)-pgd(i,km1)*dp(i,km1) )/md(i,k)<a name='1673'>
<a name='1674'>
               endif<a name='1675'>
            end do<a name='1676'>
         end do<a name='1677'>
<a name='1678'>
<a name='1679'>
         sum = 0._r8<a name='1680'>
         sum2 = 0._r8<a name='1681'>
<a name='1682'>
<a name='1683'>
         do k = ktm,pver<a name='1684'>
            km1 = max(1,k-1)<a name='1685'>
            kp1 = min(pver,k+1)<a name='1686'>
            do i = il1g,il2g<a name='1687'>
               ii = ideep(i)<a name='1688'>
	<a name='1689'>
<font color=#447700>! version 1 hard to check for roundoff errors<a name='1690'></font>
               dcondt(i,k) =  &amp;<a name='1691'>
                           +(mu(i,kp1)* (conu(i,kp1)-chat(i,kp1)) &amp;<a name='1692'>
                           -mu(i,k)*   (conu(i,k)-chat(i,k))      &amp;<a name='1693'>
                           +md(i,kp1)* (cond(i,kp1)-chat(i,kp1)) &amp;<a name='1694'>
                           -md(i,k)*   (cond(i,k)-chat(i,k)) &amp;<a name='1695'>
                          )/dp(i,k)<a name='1696'>
<a name='1697'>
            end do<a name='1698'>
         end do<a name='1699'>
<a name='1700'>
  <font color=#447700>! dcont for bottom layer<a name='1701'></font>
          <font color=#447700>!<a name='1702'></font>
          <font color=#447700>!DIR$ NOINTERCHANGE<a name='1703'></font>
          do k = kbm,pver<a name='1704'>
             km1 = max(1,k-1)<a name='1705'>
             do i = il1g,il2g<a name='1706'>
                if (k == mx(i)) then<a name='1707'>
<a name='1708'>
                   <font color=#447700>! version 1<a name='1709'></font>
                   dcondt(i,k) = (1./dp(i,k))*   &amp;  <a name='1710'>
                        (-mu(i,k)*(conu(i,k)-chat(i,k)) &amp;<a name='1711'>
                        -md(i,k)*(cond(i,k)-chat(i,k)) &amp;<a name='1712'>
                        )<a name='1713'>
                end if<a name='1714'>
             end do<a name='1715'>
          end do<a name='1716'>
<a name='1717'>
<font color=#447700>! Initialize to zero everywhere, then scatter tendency back to full array<a name='1718'></font>
         dqdt(:,:,m) = 0._r8<a name='1719'>
<a name='1720'>
         do k = 1,pver<a name='1721'>
            do i = il1g,il2g<a name='1722'>
               ii = ideep(i)<a name='1723'>
               dqdt(ii,k,m) = dcondt(i,k)<a name='1724'>
    <font color=#447700>! Output apparent force on the mean flow from pressure gradient<a name='1725'></font>
               pguall(ii,k,m) = -pgu(i,k)<a name='1726'>
               pgdall(ii,k,m) = -pgd(i,k)<a name='1727'>
               icwu(ii,k,m)   =  conu(i,k)<a name='1728'>
               icwd(ii,k,m)   =  cond(i,k)<a name='1729'>
            end do<a name='1730'>
         end do<a name='1731'>
<a name='1732'>
          <font color=#447700>! Calculate momentum flux in units of mb*m/s2 <a name='1733'></font>
<a name='1734'>
          do k = ktm,pver<a name='1735'>
             do i = il1g,il2g<a name='1736'>
                ii = ideep(i)<a name='1737'>
                mflux(i,k,m) = &amp;<a name='1738'>
                     -mu(i,k)*   (conu(i,k)-chat(i,k))      &amp;<a name='1739'>
                     -md(i,k)*   (cond(i,k)-chat(i,k))<a name='1740'>
             end do<a name='1741'>
          end do<a name='1742'>
<a name='1743'>
<a name='1744'>
          <font color=#447700>! Calculate winds at the end of the time step <a name='1745'></font>
<a name='1746'>
          do k = ktm,pver<a name='1747'>
             do i = il1g,il2g<a name='1748'>
                ii = ideep(i)<a name='1749'>
                km1 = max(1,k-1)<a name='1750'>
                kp1 = k+1<a name='1751'>
                windf(i,k,m) = const(i,k)    -   (mflux(i,kp1,m) - mflux(i,k,m)) * dt /dp(i,k)<a name='1752'>
<a name='1753'>
             end do<a name='1754'>
          end do<a name='1755'>
<a name='1756'>
       end if      <font color=#447700>! for domomtran<a name='1757'></font>
   end do<a name='1758'>
<a name='1759'>
 <font color=#447700>! Need to add an energy fix to account for the dissipation of kinetic energy<a name='1760'></font>
    <font color=#447700>! Formulation follows from Boville and Bretherton (2003)<a name='1761'></font>
    <font color=#447700>! formulation by PJR<a name='1762'></font>
<a name='1763'>
    do k = ktm,pver<a name='1764'>
       km1 = max(1,k-1)<a name='1765'>
       kp1 = min(pver,k+1)<a name='1766'>
       do i = il1g,il2g<a name='1767'>
<a name='1768'>
          ii = ideep(i)<a name='1769'>
<a name='1770'>
          <font color=#447700>! calculate the KE fluxes at top and bot of layer <a name='1771'></font>
          <font color=#447700>! based on a discrete approximation to b&amp;b eq(35) F_KE = u*F_u + v*F_v at interface<a name='1772'></font>
          utop = (wind0(i,k,1)+wind0(i,km1,1))/2.<a name='1773'>
          vtop = (wind0(i,k,2)+wind0(i,km1,2))/2.<a name='1774'>
          ubot = (wind0(i,kp1,1)+wind0(i,k,1))/2.<a name='1775'>
          vbot = (wind0(i,kp1,2)+wind0(i,k,2))/2.<a name='1776'>
          fket = utop*mflux(i,k,1)   + vtop*mflux(i,k,2)    <font color=#447700>! top of layer<a name='1777'></font>
          fkeb = ubot*mflux(i,k+1,1) + vbot*mflux(i,k+1,2)  <font color=#447700>! bot of layer<a name='1778'></font>
<a name='1779'>
          <font color=#447700>! divergence of these fluxes should give a conservative redistribution of KE<a name='1780'></font>
          ketend_cons = (fket-fkeb)/dp(i,k)<a name='1781'>
<a name='1782'>
          <font color=#447700>! tendency in kinetic energy resulting from the momentum transport<a name='1783'></font>
          ketend = ((windf(i,k,1)**2 + windf(i,k,2)**2) - (wind0(i,k,1)**2 + wind0(i,k,2)**2))*0.5/dt<a name='1784'>
<a name='1785'>
          <font color=#447700>! the difference should be the dissipation<a name='1786'></font>
          gset2 = ketend_cons - ketend<a name='1787'>
          gseten(i,k) = gset2<a name='1788'>
<a name='1789'>
       end do<a name='1790'>
<a name='1791'>
    end do<a name='1792'>
<a name='1793'>
    <font color=#447700>! Scatter dry static energy to full array<a name='1794'></font>
    do k = 1,pver<a name='1795'>
       do i = il1g,il2g<a name='1796'>
          ii = ideep(i)<a name='1797'>
          seten(ii,k) = gseten(i,k)<a name='1798'>
<a name='1799'>
       end do<a name='1800'>
    end do<a name='1801'>
<a name='1802'>
   return<a name='1803'>
end subroutine momtran<a name='1804'>
<a name='1805'>
<font color=#447700>!=========================================================================================<a name='1806'></font>
<a name='1807'>
<A NAME='BUOYAN'><A href='../../html_code/phys/module_cu_camzm.F.html#BUOYAN' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1808'>
<font color=#993300>subroutine </font><font color=#cc0000>buoyan</font>(lchnk   ,ncol    , &amp; <A href='../../call_to/BUOYAN.html' TARGET='index'>1</A><a name='1809'>
                  q       ,t       ,p       ,z       ,pf      , &amp;<a name='1810'>
                  tp      ,qstp    ,tl      ,rl      ,cape    , &amp;<a name='1811'>
                  pblt    ,lcl     ,lel     ,lon     ,mx      , &amp;<a name='1812'>
                  rd      ,grav    ,cp      ,msg     , &amp;<a name='1813'>
                  tpert   )<a name='1814'>
<font color=#447700>!----------------------------------------------------------------------- <a name='1815'></font>
<font color=#447700>! <a name='1816'></font>
<font color=#447700>! Purpose: <a name='1817'></font>
<font color=#447700>! &lt;Say what the routine does&gt; <a name='1818'></font>
<font color=#447700>! <a name='1819'></font>
<font color=#447700>! Method: <a name='1820'></font>
<font color=#447700>! &lt;Describe the algorithm(s) used in the routine.&gt; <a name='1821'></font>
<font color=#447700>! &lt;Also include any applicable external references.&gt; <a name='1822'></font>
<font color=#447700>! <a name='1823'></font>
<font color=#447700>! Author:<a name='1824'></font>
<font color=#447700>! This is contributed code not fully standardized by the CCM core group.<a name='1825'></font>
<font color=#447700>! The documentation has been enhanced to the degree that we are able.<a name='1826'></font>
<font color=#447700>! Reviewed:          P. Rasch, April 1996<a name='1827'></font>
<font color=#447700>! <a name='1828'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='1829'></font>
   implicit none<a name='1830'>
<font color=#447700>!-----------------------------------------------------------------------<a name='1831'></font>
<font color=#447700>!<a name='1832'></font>
<font color=#447700>! input arguments<a name='1833'></font>
<font color=#447700>!<a name='1834'></font>
   integer, intent(in) :: lchnk                 <font color=#447700>! chunk identifier<a name='1835'></font>
   integer, intent(in) :: ncol                  <font color=#447700>! number of atmospheric columns<a name='1836'></font>
<a name='1837'>
   real(r8), intent(in) :: q(pcols,pver)        <font color=#447700>! spec. humidity<a name='1838'></font>
   real(r8), intent(in) :: t(pcols,pver)        <font color=#447700>! temperature<a name='1839'></font>
   real(r8), intent(in) :: p(pcols,pver)        <font color=#447700>! pressure<a name='1840'></font>
   real(r8), intent(in) :: z(pcols,pver)        <font color=#447700>! height<a name='1841'></font>
   real(r8), intent(in) :: pf(pcols,pver+1)     <font color=#447700>! pressure at interfaces<a name='1842'></font>
   real(r8), intent(in) :: pblt(pcols)          <font color=#447700>! index of pbl depth<a name='1843'></font>
   real(r8), intent(in) :: tpert(pcols)         <font color=#447700>! perturbation temperature by pbl processes<a name='1844'></font>
<a name='1845'>
<font color=#447700>!<a name='1846'></font>
<font color=#447700>! output arguments<a name='1847'></font>
<font color=#447700>!<a name='1848'></font>
   real(r8), intent(out) :: tp(pcols,pver)       <font color=#447700>! parcel temperature<a name='1849'></font>
   real(r8), intent(out) :: qstp(pcols,pver)     <font color=#447700>! saturation mixing ratio of parcel<a name='1850'></font>
   real(r8), intent(out) :: tl(pcols)            <font color=#447700>! parcel temperature at lcl<a name='1851'></font>
   real(r8), intent(out) :: cape(pcols)          <font color=#447700>! convective aval. pot. energy.<a name='1852'></font>
   integer lcl(pcols)        <font color=#447700>!<a name='1853'></font>
   integer lel(pcols)        <font color=#447700>!<a name='1854'></font>
   integer lon(pcols)        <font color=#447700>! level of onset of deep convection<a name='1855'></font>
   integer mx(pcols)         <font color=#447700>! level of max moist static energy<a name='1856'></font>
<font color=#447700>!<a name='1857'></font>
<font color=#447700>!--------------------------Local Variables------------------------------<a name='1858'></font>
<font color=#447700>!<a name='1859'></font>
   real(r8) capeten(pcols,5)     <font color=#447700>! provisional value of cape<a name='1860'></font>
   real(r8) tv(pcols,pver)       <font color=#447700>!<a name='1861'></font>
   real(r8) tpv(pcols,pver)      <font color=#447700>!<a name='1862'></font>
   real(r8) buoy(pcols,pver)<a name='1863'>
<a name='1864'>
   real(r8) a1(pcols)<a name='1865'>
   real(r8) a2(pcols)<a name='1866'>
   real(r8) estp(pcols)<a name='1867'>
   real(r8) pl(pcols)<a name='1868'>
   real(r8) plexp(pcols)<a name='1869'>
   real(r8) hmax(pcols)<a name='1870'>
   real(r8) hmn(pcols)<a name='1871'>
   real(r8) y(pcols)<a name='1872'>
<a name='1873'>
   logical plge600(pcols)<a name='1874'>
   integer knt(pcols)<a name='1875'>
   integer lelten(pcols,5)<a name='1876'>
<a name='1877'>
   real(r8) cp<a name='1878'>
   real(r8) e<a name='1879'>
   real(r8) grav<a name='1880'>
<a name='1881'>
   integer i<a name='1882'>
   integer k<a name='1883'>
   integer msg<a name='1884'>
   integer n<a name='1885'>
<a name='1886'>
   real(r8) rd<a name='1887'>
   real(r8) rl<a name='1888'>
#ifdef PERGRO<a name='1889'>
   real(r8) rhd<a name='1890'>
#endif<a name='1891'>
<font color=#447700>!<a name='1892'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='1893'></font>
<font color=#447700>!<a name='1894'></font>
   do n = 1,5<a name='1895'>
      do i = 1,ncol<a name='1896'>
         lelten(i,n) = pver<a name='1897'>
         capeten(i,n) = 0._r8<a name='1898'>
      end do<a name='1899'>
   end do<a name='1900'>
<font color=#447700>!<a name='1901'></font>
   do i = 1,ncol<a name='1902'>
      lon(i) = pver<a name='1903'>
      knt(i) = 0<a name='1904'>
      lel(i) = pver<a name='1905'>
      mx(i) = lon(i)<a name='1906'>
      cape(i) = 0._r8<a name='1907'>
      hmax(i) = 0._r8<a name='1908'>
   end do<a name='1909'>
<a name='1910'>
   tp(:ncol,:) = t(:ncol,:)<a name='1911'>
   qstp(:ncol,:) = q(:ncol,:)<a name='1912'>
<a name='1913'>
<font color=#447700>!!! RBN - Initialize tv and buoy for output.<a name='1914'></font>
<font color=#447700>!!! tv=tv : tpv=tpv : qstp=q : buoy=0.<a name='1915'></font>
   tv(:ncol,:) = t(:ncol,:) *(1._r8+1.608*q(:ncol,:))/ (1._r8+q(:ncol,:))<a name='1916'>
   tpv(:ncol,:) = tv(:ncol,:)<a name='1917'>
   buoy(:ncol,:) = 0._r8<a name='1918'>
<a name='1919'>
<font color=#447700>!<a name='1920'></font>
<font color=#447700>! set "launching" level(mx) to be at maximum moist static energy.<a name='1921'></font>
<font color=#447700>! search for this level stops at planetary boundary layer top.<a name='1922'></font>
<font color=#447700>!<a name='1923'></font>
#ifdef PERGRO<a name='1924'>
   do k = pver,msg + 1,-1<a name='1925'>
      do i = 1,ncol<a name='1926'>
         hmn(i) = cp*t(i,k) + grav*z(i,k) + rl*q(i,k)<a name='1927'>
<font color=#447700>!<a name='1928'></font>
<font color=#447700>! Reset max moist static energy level when relative difference exceeds 1.e-4<a name='1929'></font>
<font color=#447700>!<a name='1930'></font>
         rhd = (hmn(i) - hmax(i))/(hmn(i) + hmax(i))<a name='1931'>
         if (k &gt;= nint(pblt(i)) .and. k &lt;= lon(i) .and. rhd &gt; -1.e-4_r8) then<a name='1932'>
            hmax(i) = hmn(i)<a name='1933'>
            mx(i) = k<a name='1934'>
         end if<a name='1935'>
      end do<a name='1936'>
   end do<a name='1937'>
#else<a name='1938'>
   do k = pver,msg + 1,-1<a name='1939'>
      do i = 1,ncol<a name='1940'>
         hmn(i) = cp*t(i,k) + grav*z(i,k) + rl*q(i,k)<a name='1941'>
         if (k &gt;= nint(pblt(i)) .and. k &lt;= lon(i) .and. hmn(i) &gt; hmax(i)) then<a name='1942'>
            hmax(i) = hmn(i)<a name='1943'>
            mx(i) = k<a name='1944'>
         end if<a name='1945'>
      end do<a name='1946'>
   end do<a name='1947'>
#endif<a name='1948'>
<font color=#447700>!<a name='1949'></font>
   do i = 1,ncol<a name='1950'>
      lcl(i) = mx(i)<a name='1951'>
      e = p(i,mx(i))*q(i,mx(i))/ (eps1+q(i,mx(i)))<a name='1952'>
      tl(i) = 2840._r8/ (3.5_r8*log(t(i,mx(i)))-log(e)-4.805_r8) + 55._r8<a name='1953'>
      if (tl(i) &lt; t(i,mx(i))) then<a name='1954'>
         plexp(i) = (1._r8/ (0.2854_r8* (1._r8-0.28_r8*q(i,mx(i)))))<a name='1955'>
         pl(i) = p(i,mx(i))* (tl(i)/t(i,mx(i)))**plexp(i)<a name='1956'>
      else<a name='1957'>
         tl(i) = t(i,mx(i))<a name='1958'>
         pl(i) = p(i,mx(i))<a name='1959'>
      end if<a name='1960'>
   end do<a name='1961'>
<a name='1962'>
<font color=#447700>!<a name='1963'></font>
<font color=#447700>! calculate lifting condensation level (lcl).<a name='1964'></font>
<font color=#447700>!<a name='1965'></font>
   do k = pver,msg + 2,-1<a name='1966'>
      do i = 1,ncol<a name='1967'>
         if (k &lt;= mx(i) .and. (p(i,k) &gt; pl(i) .and. p(i,k-1) &lt;= pl(i))) then<a name='1968'>
            lcl(i) = k - 1<a name='1969'>
         end if<a name='1970'>
      end do<a name='1971'>
   end do<a name='1972'>
<font color=#447700>!<a name='1973'></font>
<font color=#447700>! if lcl is above the nominal level of non-divergence (600 mbs),<a name='1974'></font>
<font color=#447700>! no deep convection is permitted (ensuing calculations<a name='1975'></font>
<font color=#447700>! skipped and cape retains initialized value of zero).<a name='1976'></font>
<font color=#447700>!<a name='1977'></font>
   do i = 1,ncol<a name='1978'>
      plge600(i) = pl(i).ge.600._r8<a name='1979'>
   end do<a name='1980'>
<font color=#447700>!<a name='1981'></font>
<font color=#447700>! initialize parcel properties in sub-cloud layer below lcl.<a name='1982'></font>
<font color=#447700>!<a name='1983'></font>
   do k = pver,msg + 1,-1<a name='1984'>
      do i=1,ncol<a name='1985'>
         if (k &gt; lcl(i) .and. k &lt;= mx(i) .and. plge600(i)) then<a name='1986'>
            tv(i,k) = t(i,k)* (1._r8+1.608_r8*q(i,k))/ (1._r8+q(i,k))<a name='1987'>
            qstp(i,k) = q(i,mx(i))<a name='1988'>
            tp(i,k) = t(i,mx(i))* (p(i,k)/p(i,mx(i)))**(0.2854_r8* (1._r8-0.28_r8*q(i,mx(i))))<a name='1989'>
<font color=#447700>!<a name='1990'></font>
<font color=#447700>! buoyancy is increased by 0.5 k as in tiedtke<a name='1991'></font>
<font color=#447700>!<a name='1992'></font>
<font color=#447700>!-jjh          tpv (i,k)=tp(i,k)*(1.+1.608*q(i,mx(i)))/<a name='1993'></font>
<font color=#447700>!-jjh     1                     (1.+q(i,mx(i)))<a name='1994'></font>
            tpv(i,k) = (tp(i,k)+tpert(i))*(1._r8+1.608_r8*q(i,mx(i)))/ (1._r8+q(i,mx(i)))<a name='1995'>
            buoy(i,k) = tpv(i,k) - tv(i,k) + tiedke_add<a name='1996'>
         end if<a name='1997'>
      end do<a name='1998'>
   end do<a name='1999'>
<a name='2000'>
<font color=#447700>!<a name='2001'></font>
<font color=#447700>! define parcel properties at lcl (i.e. level immediately above pl).<a name='2002'></font>
<font color=#447700>!<a name='2003'></font>
   do k = pver,msg + 1,-1<a name='2004'>
      do i=1,ncol<a name='2005'>
         if (k == lcl(i) .and. plge600(i)) then<a name='2006'>
            tv(i,k) = t(i,k)* (1._r8+1.608_r8*q(i,k))/ (1._r8+q(i,k))<a name='2007'>
            qstp(i,k) = q(i,mx(i))<a name='2008'>
            tp(i,k) = tl(i)* (p(i,k)/pl(i))**(0.2854_r8* (1._r8-0.28_r8*qstp(i,k)))<a name='2009'>
<font color=#447700>!              estp(i)  =exp(a-b/tp(i,k))<a name='2010'></font>
<font color=#447700>! use of different formulas for est has about 1 g/kg difference<a name='2011'></font>
<font color=#447700>! in qs at t= 300k, and 0.02 g/kg at t=263k, with the formula<a name='2012'></font>
<font color=#447700>! above giving larger qs.<a name='2013'></font>
<font color=#447700>!<a name='2014'></font>
            estp(i) = c1*exp((c2* (tp(i,k)-tfreez))/((tp(i,k)-tfreez)+c3))<a name='2015'>
<a name='2016'>
            qstp(i,k) = eps1*estp(i)/ (p(i,k)-estp(i))<a name='2017'>
            a1(i) = cp / rl + qstp(i,k) * (1._r8+ qstp(i,k) / eps1) * rl * eps1 / &amp;<a name='2018'>
                    (rd * tp(i,k) ** 2)<a name='2019'>
            a2(i) = .5_r8* (qstp(i,k)* (1._r8+2._r8/eps1*qstp(i,k))* &amp;<a name='2020'>
                    (1._r8+qstp(i,k)/eps1)*eps1**2*rl*rl/ &amp;<a name='2021'>
                    (rd**2*tp(i,k)**4)-qstp(i,k)* &amp;<a name='2022'>
                    (1._r8+qstp(i,k)/eps1)*2._r8*eps1*rl/ &amp;<a name='2023'>
                    (rd*tp(i,k)**3))<a name='2024'>
            a1(i) = 1._r8/a1(i)<a name='2025'>
            a2(i) = -a2(i)*a1(i)**3<a name='2026'>
            y(i) = q(i,mx(i)) - qstp(i,k)<a name='2027'>
            tp(i,k) = tp(i,k) + a1(i)*y(i) + a2(i)*y(i)**2<a name='2028'>
<font color=#447700>!          estp(i)  =exp(a-b/tp(i,k))<a name='2029'></font>
            estp(i) = c1*exp((c2* (tp(i,k)-tfreez))/ ((tp(i,k)-tfreez)+c3))<a name='2030'>
<a name='2031'>
            qstp(i,k) = eps1*estp(i) / (p(i,k)-estp(i))<a name='2032'>
<font color=#447700>!<a name='2033'></font>
<font color=#447700>! buoyancy is increased by 0.5 k in cape calculation.<a name='2034'></font>
<font color=#447700>! dec. 9, 1994<a name='2035'></font>
<font color=#447700>!-jjh          tpv(i,k) =tp(i,k)*(1.+1.608*qstp(i,k))/(1.+q(i,mx(i)))<a name='2036'></font>
<font color=#447700>!<a name='2037'></font>
            tpv(i,k) = (tp(i,k)+tpert(i))* (1._r8+1.608_r8*qstp(i,k)) / (1._r8+q(i,mx(i)))<a name='2038'>
            buoy(i,k) = tpv(i,k) - tv(i,k) + tiedke_add<a name='2039'>
         end if<a name='2040'>
      end do<a name='2041'>
   end do<a name='2042'>
<font color=#447700>!<a name='2043'></font>
<font color=#447700>! main buoyancy calculation.<a name='2044'></font>
<font color=#447700>!<a name='2045'></font>
   do k = pver - 1,msg + 1,-1<a name='2046'>
      do i=1,ncol<a name='2047'>
         if (k &lt; lcl(i) .and. plge600(i)) then<a name='2048'>
            tv(i,k) = t(i,k)* (1._r8+1.608_r8*q(i,k))/ (1._r8+q(i,k))<a name='2049'>
            qstp(i,k) = qstp(i,k+1)<a name='2050'>
            tp(i,k) = tp(i,k+1)* (p(i,k)/p(i,k+1))**(0.2854_r8* (1._r8-0.28_r8*qstp(i,k)))<a name='2051'>
<font color=#447700>!          estp(i) = exp(a-b/tp(i,k))<a name='2052'></font>
            estp(i) = c1*exp((c2* (tp(i,k)-tfreez))/((tp(i,k)-tfreez)+c3))<a name='2053'>
<a name='2054'>
            qstp(i,k) = eps1*estp(i)/ (p(i,k)-estp(i))<a name='2055'>
            a1(i) = cp/rl + qstp(i,k)* (1._r8+qstp(i,k)/eps1)*rl*eps1/ (rd*tp(i,k)**2)<a name='2056'>
            a2(i) = .5_r8* (qstp(i,k)* (1._r8+2._r8/eps1*qstp(i,k))* &amp;<a name='2057'>
                    (1._r8+qstp(i,k)/eps1)*eps1**2*rl*rl/ &amp;<a name='2058'>
                    (rd**2*tp(i,k)**4)-qstp(i,k)* &amp;<a name='2059'>
                    (1._r8+qstp(i,k)/eps1)*2._r8*eps1*rl/ &amp;<a name='2060'>
                    (rd*tp(i,k)**3))<a name='2061'>
            a1(i) = 1._r8/a1(i)<a name='2062'>
            a2(i) = -a2(i)*a1(i)**3<a name='2063'>
            y(i) = qstp(i,k+1) - qstp(i,k)<a name='2064'>
            tp(i,k) = tp(i,k) + a1(i)*y(i) + a2(i)*y(i)**2<a name='2065'>
<font color=#447700>!          estp(i)  =exp(a-b/tp(i,k))<a name='2066'></font>
            estp(i) = c1*exp((c2* (tp(i,k)-tfreez))/ ((tp(i,k)-tfreez)+c3))<a name='2067'>
<a name='2068'>
            qstp(i,k) = eps1*estp(i)/ (p(i,k)-estp(i))<a name='2069'>
<font color=#447700>!-jjh          tpv(i,k) =tp(i,k)*(1.+1.608*qstp(i,k))/<a name='2070'></font>
<font color=#447700>!jt            (1.+q(i,mx(i)))<a name='2071'></font>
            tpv(i,k) = (tp(i,k)+tpert(i))* (1._r8+1.608_r8*qstp(i,k))/(1._r8+q(i,mx(i)))<a name='2072'>
            buoy(i,k) = tpv(i,k) - tv(i,k) + tiedke_add<a name='2073'>
         end if<a name='2074'>
      end do<a name='2075'>
   end do<a name='2076'>
<a name='2077'>
<font color=#447700>!<a name='2078'></font>
   do k = msg + 2,pver<a name='2079'>
      do i = 1,ncol<a name='2080'>
         if (k &lt; lcl(i) .and. plge600(i)) then<a name='2081'>
            if (buoy(i,k+1) &gt; 0._r8 .and. buoy(i,k) &lt;= 0._r8) then<a name='2082'>
               knt(i) = min(5,knt(i) + 1)<a name='2083'>
               lelten(i,knt(i)) = k<a name='2084'>
            end if<a name='2085'>
         end if<a name='2086'>
      end do<a name='2087'>
   end do<a name='2088'>
<font color=#447700>!<a name='2089'></font>
<font color=#447700>! calculate convective available potential energy (cape).<a name='2090'></font>
<font color=#447700>!<a name='2091'></font>
   do n = 1,5<a name='2092'>
      do k = msg + 1,pver<a name='2093'>
         do i = 1,ncol<a name='2094'>
            if (plge600(i) .and. k &lt;= mx(i) .and. k &gt; lelten(i,n)) then<a name='2095'>
               capeten(i,n) = capeten(i,n) + rd*buoy(i,k)*log(pf(i,k+1)/pf(i,k))<a name='2096'>
            end if<a name='2097'>
         end do<a name='2098'>
      end do<a name='2099'>
   end do<a name='2100'>
<font color=#447700>!<a name='2101'></font>
<font color=#447700>! find maximum cape from all possible tentative capes from<a name='2102'></font>
<font color=#447700>! one sounding,<a name='2103'></font>
<font color=#447700>! and use it as the final cape, april 26, 1995<a name='2104'></font>
<font color=#447700>!<a name='2105'></font>
   do n = 1,5<a name='2106'>
      do i = 1,ncol<a name='2107'>
         if (capeten(i,n) &gt; cape(i)) then<a name='2108'>
            cape(i) = capeten(i,n)<a name='2109'>
            lel(i) = lelten(i,n)<a name='2110'>
         end if<a name='2111'>
      end do<a name='2112'>
   end do<a name='2113'>
<font color=#447700>!<a name='2114'></font>
<font color=#447700>! put lower bound on cape for diagnostic purposes.<a name='2115'></font>
<font color=#447700>!<a name='2116'></font>
   do i = 1,ncol<a name='2117'>
      cape(i) = max(cape(i), 0._r8)<a name='2118'>
   end do<a name='2119'>
<font color=#447700>!<a name='2120'></font>
   return<a name='2121'>
end subroutine buoyan<a name='2122'>
<a name='2123'>
<A NAME='CLDPRP'><A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='2124'>
<font color=#993300>subroutine </font><font color=#cc0000>cldprp</font>(lchnk   , &amp; <A href='../../call_to/CLDPRP.html' TARGET='index'>1</A>,<A href='../../call_from/CLDPRP.html' TARGET='index'>5</A><a name='2125'>
                  q       ,t       ,u       ,v       ,p       , &amp;<a name='2126'>
                  z       ,s       ,mu      ,eu      ,du      , &amp;<a name='2127'>
                  md      ,ed      ,sd      ,qd      ,mc      , &amp;<a name='2128'>
                  qu      ,su      ,zf      ,qst     ,hmn     , &amp;<a name='2129'>
                  hsat    ,shat    ,ql      , &amp;<a name='2130'>
                  cmeg    ,jb      ,lel     ,jt      ,jlcl    , &amp;<a name='2131'>
                  mx      ,j0      ,jd      ,rl      ,il2g    , &amp;<a name='2132'>
                  rd      ,grav    ,cp      ,msg     , &amp;<a name='2133'>
                  pflx    ,evp     ,cu      ,rprd    ,limcnv  ,landfrac)<a name='2134'>
<font color=#447700>!----------------------------------------------------------------------- <a name='2135'></font>
<font color=#447700>! <a name='2136'></font>
<font color=#447700>! Purpose: <a name='2137'></font>
<font color=#447700>! &lt;Say what the routine does&gt; <a name='2138'></font>
<font color=#447700>! <a name='2139'></font>
<font color=#447700>! Method: <a name='2140'></font>
<font color=#447700>! may 09/91 - guang jun zhang, m.lazare, n.mcfarlane.<a name='2141'></font>
<font color=#447700>!             original version cldprop.<a name='2142'></font>
<font color=#447700>! <a name='2143'></font>
<font color=#447700>! Author: See above, modified by P. Rasch<a name='2144'></font>
<font color=#447700>! This is contributed code not fully standardized by the CCM core group.<a name='2145'></font>
<font color=#447700>!<a name='2146'></font>
<font color=#447700>! this code is very much rougher than virtually anything else in the CCM<a name='2147'></font>
<font color=#447700>! there are debug statements left strewn about and code segments disabled<a name='2148'></font>
<font color=#447700>! these are to facilitate future development. We expect to release a<a name='2149'></font>
<font color=#447700>! cleaner code in a future release<a name='2150'></font>
<font color=#447700>!<a name='2151'></font>
<font color=#447700>! the documentation has been enhanced to the degree that we are able<a name='2152'></font>
<font color=#447700>!<a name='2153'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='2154'></font>
<a name='2155'>
   implicit none<a name='2156'>
<a name='2157'>
<font color=#447700>!------------------------------------------------------------------------------<a name='2158'></font>
<font color=#447700>!<a name='2159'></font>
<font color=#447700>! Input arguments<a name='2160'></font>
<font color=#447700>!<a name='2161'></font>
   integer, intent(in) :: lchnk                  <font color=#447700>! chunk identifier<a name='2162'></font>
<a name='2163'>
   real(r8), intent(in) :: q(pcols,pver)         <font color=#447700>! spec. humidity of env<a name='2164'></font>
   real(r8), intent(in) :: t(pcols,pver)         <font color=#447700>! temp of env<a name='2165'></font>
   real(r8), intent(in) :: p(pcols,pver)         <font color=#447700>! pressure of env<a name='2166'></font>
   real(r8), intent(in) :: z(pcols,pver)         <font color=#447700>! height of env<a name='2167'></font>
   real(r8), intent(in) :: s(pcols,pver)         <font color=#447700>! normalized dry static energy of env<a name='2168'></font>
   real(r8), intent(in) :: zf(pcols,pverp)       <font color=#447700>! height of interfaces<a name='2169'></font>
   real(r8), intent(in) :: u(pcols,pver)         <font color=#447700>! zonal velocity of env<a name='2170'></font>
   real(r8), intent(in) :: v(pcols,pver)         <font color=#447700>! merid. velocity of env<a name='2171'></font>
<a name='2172'>
   real(r8), intent(in) :: landfrac(pcols) <font color=#447700>! RBN Landfrac<a name='2173'></font>
<a name='2174'>
   integer, intent(in) :: jb(pcols)              <font color=#447700>! updraft base level<a name='2175'></font>
   integer, intent(in) :: lel(pcols)             <font color=#447700>! updraft launch level<a name='2176'></font>
   integer, intent(out) :: jt(pcols)              <font color=#447700>! updraft plume top<a name='2177'></font>
   integer, intent(out) :: jlcl(pcols)            <font color=#447700>! updraft lifting cond level<a name='2178'></font>
   integer, intent(in) :: mx(pcols)              <font color=#447700>! updraft base level (same is jb)<a name='2179'></font>
   integer, intent(out) :: j0(pcols)              <font color=#447700>! level where updraft begins detraining<a name='2180'></font>
   integer, intent(out) :: jd(pcols)              <font color=#447700>! level of downdraft<a name='2181'></font>
   integer, intent(in) :: limcnv                 <font color=#447700>! convection limiting level<a name='2182'></font>
   integer, intent(in) :: il2g                   <font color=#447700>!CORE GROUP REMOVE<a name='2183'></font>
   integer, intent(in) :: msg                    <font color=#447700>! missing moisture vals (always 0)<a name='2184'></font>
   real(r8), intent(in) :: rl                    <font color=#447700>! latent heat of vap<a name='2185'></font>
   real(r8), intent(in) :: shat(pcols,pver)      <font color=#447700>! interface values of dry stat energy<a name='2186'></font>
<font color=#447700>!<a name='2187'></font>
<font color=#447700>! output<a name='2188'></font>
<font color=#447700>!<a name='2189'></font>
   real(r8), intent(out) :: rprd(pcols,pver)     <font color=#447700>! rate of production of precip at that layer<a name='2190'></font>
   real(r8), intent(out) :: du(pcols,pver)       <font color=#447700>! detrainement rate of updraft<a name='2191'></font>
   real(r8), intent(out) :: ed(pcols,pver)       <font color=#447700>! entrainment rate of downdraft<a name='2192'></font>
   real(r8), intent(out) :: eu(pcols,pver)       <font color=#447700>! entrainment rate of updraft<a name='2193'></font>
   real(r8), intent(out) :: hmn(pcols,pver)      <font color=#447700>! moist stat energy of env<a name='2194'></font>
   real(r8), intent(out) :: hsat(pcols,pver)     <font color=#447700>! sat moist stat energy of env<a name='2195'></font>
   real(r8), intent(out) :: mc(pcols,pver)       <font color=#447700>! net mass flux<a name='2196'></font>
   real(r8), intent(out) :: md(pcols,pver)       <font color=#447700>! downdraft mass flux<a name='2197'></font>
   real(r8), intent(out) :: mu(pcols,pver)       <font color=#447700>! updraft mass flux<a name='2198'></font>
   real(r8), intent(out) :: pflx(pcols,pverp)    <font color=#447700>! precipitation flux thru layer<a name='2199'></font>
   real(r8), intent(out) :: qd(pcols,pver)       <font color=#447700>! spec humidity of downdraft<a name='2200'></font>
   real(r8), intent(out) :: ql(pcols,pver)       <font color=#447700>! liq water of updraft<a name='2201'></font>
   real(r8), intent(out) :: qst(pcols,pver)      <font color=#447700>! saturation spec humidity of env.<a name='2202'></font>
   real(r8), intent(out) :: qu(pcols,pver)       <font color=#447700>! spec hum of updraft<a name='2203'></font>
   real(r8), intent(out) :: sd(pcols,pver)       <font color=#447700>! normalized dry stat energy of downdraft<a name='2204'></font>
   real(r8), intent(out) :: su(pcols,pver)       <font color=#447700>! normalized dry stat energy of updraft<a name='2205'></font>
<a name='2206'>
<a name='2207'>
   real(r8) rd                   <font color=#447700>! gas constant for dry air<a name='2208'></font>
   real(r8) grav                 <font color=#447700>! gravity<a name='2209'></font>
   real(r8) cp                   <font color=#447700>! heat capacity of dry air<a name='2210'></font>
<a name='2211'>
<font color=#447700>!<a name='2212'></font>
<font color=#447700>! Local workspace<a name='2213'></font>
<font color=#447700>!<a name='2214'></font>
   real(r8) gamma(pcols,pver)<a name='2215'>
   real(r8) dz(pcols,pver)<a name='2216'>
   real(r8) iprm(pcols,pver)<a name='2217'>
   real(r8) hu(pcols,pver)<a name='2218'>
   real(r8) hd(pcols,pver)<a name='2219'>
   real(r8) eps(pcols,pver)<a name='2220'>
   real(r8) f(pcols,pver)<a name='2221'>
   real(r8) k1(pcols,pver)<a name='2222'>
   real(r8) i2(pcols,pver)<a name='2223'>
   real(r8) ihat(pcols,pver)<a name='2224'>
   real(r8) i3(pcols,pver)<a name='2225'>
   real(r8) idag(pcols,pver)<a name='2226'>
   real(r8) i4(pcols,pver)<a name='2227'>
   real(r8) qsthat(pcols,pver)<a name='2228'>
   real(r8) hsthat(pcols,pver)<a name='2229'>
   real(r8) gamhat(pcols,pver)<a name='2230'>
   real(r8) cu(pcols,pver)<a name='2231'>
   real(r8) evp(pcols,pver)<a name='2232'>
   real(r8) cmeg(pcols,pver)<a name='2233'>
   real(r8) qds(pcols,pver)<a name='2234'>
<font color=#447700>! RBN For c0mask<a name='2235'></font>
   real(r8) c0mask(pcols)<a name='2236'>
<a name='2237'>
   real(r8) hmin(pcols)<a name='2238'>
   real(r8) expdif(pcols)<a name='2239'>
   real(r8) expnum(pcols)<a name='2240'>
   real(r8) ftemp(pcols)<a name='2241'>
   real(r8) eps0(pcols)<a name='2242'>
   real(r8) rmue(pcols)<a name='2243'>
   real(r8) zuef(pcols)<a name='2244'>
   real(r8) zdef(pcols)<a name='2245'>
   real(r8) epsm(pcols)<a name='2246'>
   real(r8) ratmjb(pcols)<a name='2247'>
   real(r8) est(pcols)<a name='2248'>
   real(r8) totpcp(pcols)<a name='2249'>
   real(r8) totevp(pcols)<a name='2250'>
   real(r8) alfa(pcols)<a name='2251'>
   real(r8) ql1<a name='2252'>
   real(r8) tu<a name='2253'>
   real(r8) estu<a name='2254'>
   real(r8) qstu<a name='2255'>
<a name='2256'>
   real(r8) small<a name='2257'>
   real(r8) mdt<a name='2258'>
<a name='2259'>
   integer khighest<a name='2260'>
   integer klowest<a name='2261'>
   integer kount<a name='2262'>
   integer i,k<a name='2263'>
<a name='2264'>
   logical doit(pcols)<a name='2265'>
   logical done(pcols)<a name='2266'>
<font color=#447700>!<a name='2267'></font>
<font color=#447700>!------------------------------------------------------------------------------<a name='2268'></font>
<font color=#447700>!<a name='2269'></font>
   do i = 1,il2g<a name='2270'>
      ftemp(i) = 0._r8<a name='2271'>
      expnum(i) = 0._r8<a name='2272'>
      expdif(i) = 0._r8<a name='2273'>
      c0mask(i)  = c0_ocn * (1._r8-landfrac(i)) +   c0_lnd * landfrac(i) <a name='2274'>
   end do<a name='2275'>
<font color=#447700>!<a name='2276'></font>
<font color=#447700>!jr Change from msg+1 to 1 to prevent blowup<a name='2277'></font>
<font color=#447700>!<a name='2278'></font>
   do k = 1,pver<a name='2279'>
      do i = 1,il2g<a name='2280'>
         dz(i,k) = zf(i,k) - zf(i,k+1)<a name='2281'>
      end do<a name='2282'>
   end do<a name='2283'>
<a name='2284'>
<font color=#447700>!<a name='2285'></font>
<font color=#447700>! initialize many output and work variables to zero<a name='2286'></font>
<font color=#447700>!<a name='2287'></font>
   pflx(:il2g,1) = 0<a name='2288'>
<a name='2289'>
   do k = 1,pver<a name='2290'>
      do i = 1,il2g<a name='2291'>
         k1(i,k) = 0._r8<a name='2292'>
         i2(i,k) = 0._r8<a name='2293'>
         i3(i,k) = 0._r8<a name='2294'>
         i4(i,k) = 0._r8<a name='2295'>
         mu(i,k) = 0._r8<a name='2296'>
         f(i,k) = 0._r8<a name='2297'>
         eps(i,k) = 0._r8<a name='2298'>
         eu(i,k) = 0._r8<a name='2299'>
         du(i,k) = 0._r8<a name='2300'>
         ql(i,k) = 0._r8<a name='2301'>
         cu(i,k) = 0._r8<a name='2302'>
         evp(i,k) = 0._r8<a name='2303'>
         cmeg(i,k) = 0._r8<a name='2304'>
         qds(i,k) = q(i,k)<a name='2305'>
         md(i,k) = 0._r8<a name='2306'>
         ed(i,k) = 0._r8<a name='2307'>
         sd(i,k) = s(i,k)<a name='2308'>
         qd(i,k) = q(i,k)<a name='2309'>
         mc(i,k) = 0._r8<a name='2310'>
         qu(i,k) = q(i,k)<a name='2311'>
         su(i,k) = s(i,k)<a name='2312'>
<font color=#447700>!        est(i)=exp(a-b/t(i,k))<a name='2313'></font>
         est(i) = c1*exp((c2* (t(i,k)-tfreez))/((t(i,k)-tfreez)+c3))<a name='2314'>
<font color=#447700>!++bee<a name='2315'></font>
         if ( p(i,k)-est(i) &gt; 0._r8 ) then<a name='2316'>
            qst(i,k) = eps1*est(i)/ (p(i,k)-est(i))<a name='2317'>
         else<a name='2318'>
            qst(i,k) = 1.0_r8<a name='2319'>
         end if<a name='2320'>
<font color=#447700>!--bee<a name='2321'></font>
         gamma(i,k) = qst(i,k)*(1._r8 + qst(i,k)/eps1)*eps1*rl/(rd*t(i,k)**2)*rl/cp<a name='2322'>
         hmn(i,k) = cp*t(i,k) + grav*z(i,k) + rl*q(i,k)<a name='2323'>
         hsat(i,k) = cp*t(i,k) + grav*z(i,k) + rl*qst(i,k)<a name='2324'>
         hu(i,k) = hmn(i,k)<a name='2325'>
         hd(i,k) = hmn(i,k)<a name='2326'>
         rprd(i,k) = 0._r8<a name='2327'>
      end do<a name='2328'>
   end do<a name='2329'>
<font color=#447700>!<a name='2330'></font>
<font color=#447700>!jr Set to zero things which make this routine blow up<a name='2331'></font>
<font color=#447700>!<a name='2332'></font>
   do k=1,msg<a name='2333'>
      do i=1,il2g<a name='2334'>
         rprd(i,k) = 0._r8<a name='2335'>
      end do<a name='2336'>
   end do<a name='2337'>
<font color=#447700>!<a name='2338'></font>
<font color=#447700>! interpolate the layer values of qst, hsat and gamma to<a name='2339'></font>
<font color=#447700>! layer interfaces<a name='2340'></font>
<font color=#447700>!<a name='2341'></font>
   do i = 1,il2g<a name='2342'>
      hsthat(i,msg+1) = hsat(i,msg+1)<a name='2343'>
      qsthat(i,msg+1) = qst(i,msg+1)<a name='2344'>
      gamhat(i,msg+1) = <A href='../../html_code/phys/module_mp_p3.F.html#GAMMA'>gamma</A><A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="GAMMA_22">(i,msg+1)<a name='2345'>
      totpcp(i) = 0._r8<a name='2346'>
      totevp(i) = 0._r8<a name='2347'>
   end do<a name='2348'>
   do k = msg + 2,pver<a name='2349'>
      do i = 1,il2g<a name='2350'>
         if (abs(qst(i,k-1)-qst(i,k)) &gt; 1.E-6_r8) then<a name='2351'>
            qsthat(i,k) = log(qst(i,k-1)/qst(i,k))*qst(i,k-1)*qst(i,k)/ (qst(i,k-1)-qst(i,k))<a name='2352'>
         else<a name='2353'>
            qsthat(i,k) = qst(i,k)<a name='2354'>
         end if<a name='2355'>
         hsthat(i,k) = cp*shat(i,k) + rl*qsthat(i,k)<a name='2356'>
         if (abs(gamma(i,k-1)-gamma(i,k)) &gt; 1.E-6_r8) then<a name='2357'>
            gamhat(i,k) = log(gamma(i,k-1)/gamma(i,k))*gamma(i,k-1)*gamma(i,k)/ &amp;<a name='2358'>
                                (gamma(i,k-1)-gamma(i,k))<a name='2359'>
         else<a name='2360'>
            gamhat(i,k) = <A href='../../html_code/phys/module_mp_p3.F.html#GAMMA'>gamma</A><A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="GAMMA_23">(i,k)<a name='2361'>
         end if<a name='2362'>
      end do<a name='2363'>
   end do<a name='2364'>
<font color=#447700>!<a name='2365'></font>
<font color=#447700>! initialize cloud top to highest plume top.<a name='2366'></font>
<font color=#447700>!jr changed hard-wired 4 to limcnv+1 (not to exceed pver)<a name='2367'></font>
<font color=#447700>!<a name='2368'></font>
   jt(:) = pver<a name='2369'>
   do i = 1,il2g<a name='2370'>
      jt(i) = max(lel(i),limcnv+1)<a name='2371'>
      jt(i) = min(jt(i),pver)<a name='2372'>
      jd(i) = pver<a name='2373'>
      jlcl(i) = lel(i)<a name='2374'>
      hmin(i) = 1.E6_r8<a name='2375'>
   end do<a name='2376'>
<font color=#447700>!<a name='2377'></font>
<font color=#447700>! find the level of minimum hsat, where detrainment starts<a name='2378'></font>
<font color=#447700>!<a name='2379'></font>
<a name='2380'>
   do k = msg + 1,pver<a name='2381'>
      do i = 1,il2g<a name='2382'>
         if (hsat(i,k) &lt;= hmin(i) .and. k &gt;= jt(i) .and. k &lt;= jb(i)) then<a name='2383'>
            hmin(i) = hsat(i,k)<a name='2384'>
            j0(i) = k<a name='2385'>
         end if<a name='2386'>
      end do<a name='2387'>
   end do<a name='2388'>
   do i = 1,il2g<a name='2389'>
      j0(i) = min(j0(i),jb(i)-2)<a name='2390'>
      j0(i) = max(j0(i),jt(i)+2)<a name='2391'>
<font color=#447700>!<a name='2392'></font>
<font color=#447700>! Fix from Guang Zhang to address out of bounds array reference<a name='2393'></font>
<font color=#447700>!<a name='2394'></font>
      j0(i) = min(j0(i),pver)<a name='2395'>
   end do<a name='2396'>
<font color=#447700>!<a name='2397'></font>
<font color=#447700>! Initialize certain arrays inside cloud<a name='2398'></font>
<font color=#447700>!<a name='2399'></font>
   do k = msg + 1,pver<a name='2400'>
      do i = 1,il2g<a name='2401'>
         if (k &gt;= jt(i) .and. k &lt;= jb(i)) then<a name='2402'>
            hu(i,k) = hmn(i,mx(i)) + cp*tiedke_add<a name='2403'>
            su(i,k) = s(i,mx(i)) + tiedke_add<a name='2404'>
         end if<a name='2405'>
      end do<a name='2406'>
   end do<a name='2407'>
<font color=#447700>!<a name='2408'></font>
<font color=#447700>! *********************************************************<a name='2409'></font>
<font color=#447700>! compute taylor series for approximate eps(z) below<a name='2410'></font>
<font color=#447700>! *********************************************************<a name='2411'></font>
<font color=#447700>!<a name='2412'></font>
   do k = pver - 1,msg + 1,-1<a name='2413'>
      do i = 1,il2g<a name='2414'>
         if (k &lt; jb(i) .and. k &gt;= jt(i)) then<a name='2415'>
            k1(i,k) = k1(i,k+1) + (hmn(i,mx(i))-hmn(i,k))*dz(i,k)<a name='2416'>
            ihat(i,k) = 0.5_r8* (k1(i,k+1)+k1(i,k))<a name='2417'>
            i2(i,k) = i2(i,k+1) + ihat(i,k)*dz(i,k)<a name='2418'>
            idag(i,k) = 0.5_r8* (i2(i,k+1)+i2(i,k))<a name='2419'>
            i3(i,k) = i3(i,k+1) + idag(i,k)*dz(i,k)<a name='2420'>
            iprm(i,k) = 0.5_r8* (i3(i,k+1)+i3(i,k))<a name='2421'>
            i4(i,k) = i4(i,k+1) + iprm(i,k)*dz(i,k)<a name='2422'>
         end if<a name='2423'>
      end do<a name='2424'>
   end do<a name='2425'>
<font color=#447700>!<a name='2426'></font>
<font color=#447700>! re-initialize hmin array for ensuing calculation.<a name='2427'></font>
<font color=#447700>!<a name='2428'></font>
   do i = 1,il2g<a name='2429'>
      hmin(i) = 1.E6_r8<a name='2430'>
   end do<a name='2431'>
   do k = msg + 1,pver<a name='2432'>
      do i = 1,il2g<a name='2433'>
         if (k &gt;= j0(i) .and. k &lt;= jb(i) .and. hmn(i,k) &lt;= hmin(i)) then<a name='2434'>
            hmin(i) = hmn(i,k)<a name='2435'>
            expdif(i) = hmn(i,mx(i)) - hmin(i)<a name='2436'>
         end if<a name='2437'>
      end do<a name='2438'>
   end do<a name='2439'>
<font color=#447700>!<a name='2440'></font>
<font color=#447700>! *********************************************************<a name='2441'></font>
<font color=#447700>! compute approximate eps(z) using above taylor series<a name='2442'></font>
<font color=#447700>! *********************************************************<a name='2443'></font>
<font color=#447700>!<a name='2444'></font>
   do k = msg + 2,pver<a name='2445'>
      do i = 1,il2g<a name='2446'>
         expnum(i) = 0._r8<a name='2447'>
         ftemp(i) = 0._r8<a name='2448'>
         if (k &lt; jt(i) .or. k &gt;= jb(i)) then<a name='2449'>
            k1(i,k) = 0._r8<a name='2450'>
            expnum(i) = 0._r8<a name='2451'>
         else<a name='2452'>
            expnum(i) = hmn(i,mx(i)) - (hsat(i,k-1)*(zf(i,k)-z(i,k)) + &amp;<a name='2453'>
                        hsat(i,k)* (z(i,k-1)-zf(i,k)))/(z(i,k-1)-z(i,k))<a name='2454'>
         end if<a name='2455'>
         if ((expdif(i) &gt; 100._r8 .and. expnum(i) &gt; 0._r8) .and. &amp;<a name='2456'>
	     k1(i,k) &gt; expnum(i)*dz(i,k)) then<a name='2457'>
            ftemp(i) = expnum(i)/k1(i,k)<a name='2458'>
            f(i,k) = ftemp(i) + i2(i,k)/k1(i,k)*ftemp(i)**2 + &amp;<a name='2459'>
                     (2._r8*i2(i,k)**2-k1(i,k)*i3(i,k))/k1(i,k)**2* &amp;<a name='2460'>
                     ftemp(i)**3 + (-5._r8*k1(i,k)*i2(i,k)*i3(i,k)+ &amp;<a name='2461'>
                     5._r8*i2(i,k)**3+k1(i,k)**2*i4(i,k))/ &amp;<a name='2462'>
                     k1(i,k)**3*ftemp(i)**4<a name='2463'>
            f(i,k) = max(f(i,k),0._r8)<a name='2464'>
            f(i,k) = min(f(i,k),0.0002_r8)<a name='2465'>
         end if<a name='2466'>
      end do<a name='2467'>
   end do<a name='2468'>
   do i = 1,il2g<a name='2469'>
      if (j0(i) &lt; jb(i)) then<a name='2470'>
         if (f(i,j0(i)) &lt; 1.E-6_r8 .and. f(i,j0(i)+1) &gt; f(i,j0(i))) j0(i) = j0(i) + 1<a name='2471'>
      end if<a name='2472'>
   end do<a name='2473'>
   do k = msg + 2,pver<a name='2474'>
      do i = 1,il2g<a name='2475'>
         if (k &gt;= jt(i) .and. k &lt;= j0(i)) then<a name='2476'>
            f(i,k) = max(f(i,k),f(i,k-1))<a name='2477'>
         end if<a name='2478'>
      end do<a name='2479'>
   end do<a name='2480'>
   do i = 1,il2g<a name='2481'>
      eps0(i) = <A href='../../html_code/phys/module_mp_full_sbm.F.html#F'>f</A><A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="F_7">(i,j0(i))<a name='2482'>
      eps(i,jb(i)) = eps0(i)<a name='2483'>
   end do<a name='2484'>
<font color=#447700>!<a name='2485'></font>
<font color=#447700>! This is set to match the Rasch and Kristjansson paper<a name='2486'></font>
<font color=#447700>!<a name='2487'></font>
   do k = pver,msg + 1,-1<a name='2488'>
      do i = 1,il2g<a name='2489'>
         if (k &gt;= j0(i) .and. k &lt;= jb(i)) then<a name='2490'>
            eps(i,k) = <A href='../../html_code/phys/module_mp_full_sbm.F.html#F'>f</A><A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="F_8">(i,j0(i))<a name='2491'>
         end if<a name='2492'>
      end do<a name='2493'>
   end do<a name='2494'>
   do k = pver,msg + 1,-1<a name='2495'>
      do i = 1,il2g<a name='2496'>
         if (k &lt; j0(i) .and. k &gt;= jt(i)) eps(i,k) = <A href='../../html_code/phys/module_mp_full_sbm.F.html#F'>f</A><A href='../../html_code/phys/module_cu_camzm.F.html#CLDPRP' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="F_9">(i,k)<a name='2497'>
      end do<a name='2498'>
   end do<a name='2499'>
<font color=#447700>!<a name='2500'></font>
<font color=#447700>! specify the updraft mass flux mu, entrainment eu, detrainment du<a name='2501'></font>
<font color=#447700>! and moist static energy hu.<a name='2502'></font>
<font color=#447700>! here and below mu, eu,du, md and ed are all normalized by mb<a name='2503'></font>
<font color=#447700>!<a name='2504'></font>
   do i = 1,il2g<a name='2505'>
      if (eps0(i) &gt; 0._r8) then<a name='2506'>
         mu(i,jb(i)) = 1._r8<a name='2507'>
         eu(i,jb(i)) = mu(i,jb(i))/dz(i,jb(i))<a name='2508'>
      end if<a name='2509'>
   end do<a name='2510'>
   do k = pver,msg + 1,-1<a name='2511'>
      do i = 1,il2g<a name='2512'>
         if (eps0(i) &gt; 0._r8 .and. (k &gt;= jt(i) .and. k &lt; jb(i))) then<a name='2513'>
            zuef(i) = zf(i,k) - zf(i,jb(i))<a name='2514'>
            rmue(i) = (1._r8/eps0(i))* (exp(eps(i,k+1)*zuef(i))-1._r8)/zuef(i)<a name='2515'>
            mu(i,k) = (1._r8/eps0(i))* (exp(eps(i,k  )*zuef(i))-1._r8)/zuef(i)<a name='2516'>
            eu(i,k) = (rmue(i)-mu(i,k+1))/dz(i,k)<a name='2517'>
            du(i,k) = (rmue(i)-mu(i,k))/dz(i,k)<a name='2518'>
         end if<a name='2519'>
      end do<a name='2520'>
   end do<a name='2521'>
<font color=#447700>!<a name='2522'></font>
   khighest = pverp<a name='2523'>
   klowest = 1<a name='2524'>
   do i=1,il2g<a name='2525'>
      khighest = min(khighest,lel(i))<a name='2526'>
      klowest = max(klowest,jb(i))<a name='2527'>
   end do<a name='2528'>
   do k = klowest-1,khighest,-1<a name='2529'>
<font color=#447700>!cdir$ ivdep<a name='2530'></font>
      do i = 1,il2g<a name='2531'>
         if (k &lt;= jb(i)-1 .and. k &gt;= lel(i) .and. eps0(i) &gt; 0._r8) then<a name='2532'>
            if (mu(i,k) &lt; 0.01_r8) then<a name='2533'>
               hu(i,k) = hu(i,jb(i))<a name='2534'>
               mu(i,k) = 0._r8<a name='2535'>
               eu(i,k) = 0._r8<a name='2536'>
               du(i,k) = mu(i,k+1)/dz(i,k)<a name='2537'>
            else<a name='2538'>
               hu(i,k) = mu(i,k+1)/mu(i,k)*hu(i,k+1) + &amp;<a name='2539'>
                         dz(i,k)/mu(i,k)* (eu(i,k)*hmn(i,k)- du(i,k)*hsat(i,k))<a name='2540'>
            end if<a name='2541'>
         end if<a name='2542'>
      end do<a name='2543'>
   end do<a name='2544'>
<font color=#447700>!<a name='2545'></font>
<font color=#447700>! reset cloud top index beginning from two layers above the<a name='2546'></font>
<font color=#447700>! cloud base (i.e. if cloud is only one layer thick, top is not reset<a name='2547'></font>
<font color=#447700>!<a name='2548'></font>
   do i=1,il2g<a name='2549'>
      doit(i) = .true.<a name='2550'>
   end do<a name='2551'>
   do k=klowest-2,khighest-1,-1<a name='2552'>
      do i=1,il2g<a name='2553'>
         if (doit(i) .and. k &lt;= jb(i)-2 .and. k &gt;= lel(i)-1) then<a name='2554'>
  	   if (hu(i,k) &lt;= hsthat(i,k) .and. hu(i,k+1) &gt; hsthat(i,k+1) &amp;<a name='2555'>
	       .and. mu(i,k) &gt;= 0.02_r8) then<a name='2556'>
               if (hu(i,k)-hsthat(i,k) &lt; -2000._r8) then<a name='2557'>
                  jt(i) = k + 1<a name='2558'>
                  doit(i) = .false.<a name='2559'>
               else<a name='2560'>
                  jt(i) = k<a name='2561'>
                  if (eps0(i) &lt;= 0._r8) doit(i) = .false.<a name='2562'>
               end if<a name='2563'>
            else if (hu(i,k) &gt; hu(i,jb(i)) .or. mu(i,k) &lt; 0.01_r8) then<a name='2564'>
               jt(i) = k + 1<a name='2565'>
               doit(i) = .false.<a name='2566'>
            end if<a name='2567'>
         end if<a name='2568'>
      end do<a name='2569'>
   end do<a name='2570'>
   do k = pver,msg + 1,-1<a name='2571'>
<font color=#447700>!cdir$ ivdep<a name='2572'></font>
      do i = 1,il2g<a name='2573'>
         if (k &gt;= lel(i) .and. k &lt;= jt(i) .and. eps0(i) &gt; 0._r8) then<a name='2574'>
            mu(i,k) = 0._r8<a name='2575'>
            eu(i,k) = 0._r8<a name='2576'>
            du(i,k) = 0._r8<a name='2577'>
            hu(i,k) = hu(i,jb(i))<a name='2578'>
         end if<a name='2579'>
         if (k == jt(i) .and. eps0(i) &gt; 0._r8) then<a name='2580'>
            du(i,k) = mu(i,k+1)/dz(i,k)<a name='2581'>
            eu(i,k) = 0._r8<a name='2582'>
            mu(i,k) = 0._r8<a name='2583'>
         end if<a name='2584'>
      end do<a name='2585'>
   end do<a name='2586'>
<font color=#447700>!<a name='2587'></font>
<font color=#447700>! specify downdraft properties (no downdrafts if jd.ge.jb).<a name='2588'></font>
<font color=#447700>! scale down downward mass flux profile so that net flux<a name='2589'></font>
<font color=#447700>! (up-down) at cloud base in not negative.<a name='2590'></font>
<font color=#447700>!<a name='2591'></font>
   do i = 1,il2g<a name='2592'>
<font color=#447700>!<a name='2593'></font>
<font color=#447700>! in normal downdraft strength run alfa=0.2.  In test4 alfa=0.1<a name='2594'></font>
<font color=#447700>!<a name='2595'></font>
      alfa(i) = 0.1_r8<a name='2596'>
      jt(i) = min(jt(i),jb(i)-1)<a name='2597'>
      jd(i) = max(j0(i),jt(i)+1)<a name='2598'>
      jd(i) = min(jd(i),jb(i))<a name='2599'>
      hd(i,jd(i)) = hmn(i,jd(i)-1)<a name='2600'>
      if (jd(i) &lt; jb(i) .and. eps0(i) &gt; 0._r8) then<a name='2601'>
         epsm(i) = eps0(i)<a name='2602'>
         md(i,jd(i)) = -alfa(i)*epsm(i)/eps0(i)<a name='2603'>
      end if<a name='2604'>
   end do<a name='2605'>
   do k = msg + 1,pver<a name='2606'>
      do i = 1,il2g<a name='2607'>
         if ((k &gt; jd(i) .and. k &lt;= jb(i)) .and. eps0(i) &gt; 0._r8) then<a name='2608'>
            zdef(i) = zf(i,jd(i)) - zf(i,k)<a name='2609'>
            md(i,k) = -alfa(i)/ (2._r8*eps0(i))*(exp(2._r8*epsm(i)*zdef(i))-1._r8)/zdef(i)<a name='2610'>
         end if<a name='2611'>
      end do<a name='2612'>
   end do<a name='2613'>
   do k = msg + 1,pver<a name='2614'>
      do i = 1,il2g<a name='2615'>
         if ((k &gt;= jt(i) .and. k &lt;= jb(i)) .and. eps0(i) &gt; 0._r8 .and. jd(i) &lt; jb(i)) then<a name='2616'>
            ratmjb(i) = min(abs(mu(i,jb(i))/md(i,jb(i))),1._r8)<a name='2617'>
            md(i,k) = md(i,k)*ratmjb(i)<a name='2618'>
         end if<a name='2619'>
      end do<a name='2620'>
   end do<a name='2621'>
<a name='2622'>
   small = 1.e-20_r8<a name='2623'>
   do k = msg + 1,pver<a name='2624'>
      do i = 1,il2g<a name='2625'>
         if ((k &gt;= jt(i) .and. k &lt;= pver) .and. eps0(i) &gt; 0._r8) then<a name='2626'>
            ed(i,k-1) = (md(i,k-1)-md(i,k))/dz(i,k-1)<a name='2627'>
            mdt = min(md(i,k),-small)<a name='2628'>
            hd(i,k) = (md(i,k-1)*hd(i,k-1) - dz(i,k-1)*ed(i,k-1)*hmn(i,k-1))/mdt<a name='2629'>
         end if<a name='2630'>
      end do<a name='2631'>
   end do<a name='2632'>
<font color=#447700>!<a name='2633'></font>
<font color=#447700>! calculate updraft and downdraft properties.<a name='2634'></font>
<font color=#447700>!<a name='2635'></font>
   do k = msg + 2,pver<a name='2636'>
      do i = 1,il2g<a name='2637'>
         if ((k &gt;= jd(i) .and. k &lt;= jb(i)) .and. eps0(i) &gt; 0._r8 .and. jd(i) &lt; jb(i)) then<a name='2638'>
            qds(i,k) = qsthat(i,k) + gamhat(i,k)*(hd(i,k)-hsthat(i,k))/ &amp;<a name='2639'>
               (rl*(1._r8 + gamhat(i,k)))<a name='2640'>
         end if<a name='2641'>
      end do<a name='2642'>
   end do<a name='2643'>
<font color=#447700>!<a name='2644'></font>
   do i = 1,il2g<a name='2645'>
      done(i) = .false.<a name='2646'>
   end do<a name='2647'>
   kount = 0<a name='2648'>
   do k = pver,msg + 2,-1<a name='2649'>
      do i = 1,il2g<a name='2650'>
         if (( .not. done(i) .and. k &gt; jt(i) .and. k &lt; jb(i)) .and. eps0(i) &gt; 0._r8) then<a name='2651'>
            su(i,k) = mu(i,k+1)/mu(i,k)*su(i,k+1) + &amp;<a name='2652'>
                      dz(i,k)/mu(i,k)* (eu(i,k)-du(i,k))*s(i,k)<a name='2653'>
            qu(i,k) = mu(i,k+1)/mu(i,k)*qu(i,k+1) + dz(i,k)/mu(i,k)* (eu(i,k)*q(i,k)- &amp;<a name='2654'>
                            du(i,k)*qst(i,k))<a name='2655'>
            tu = su(i,k) - grav/cp*zf(i,k)<a name='2656'>
            estu = c1*exp((c2* (tu-tfreez))/ ((tu-tfreez)+c3))<a name='2657'>
            qstu = eps1*estu/ ((p(i,k)+p(i,k-1))/2._r8-estu)<a name='2658'>
            if (qu(i,k) &gt;= qstu) then<a name='2659'>
               jlcl(i) = k<a name='2660'>
               kount = kount + 1<a name='2661'>
               done(i) = .true.<a name='2662'>
            end if<a name='2663'>
         end if<a name='2664'>
      end do<a name='2665'>
      if (kount &gt;= il2g) goto 690<a name='2666'>
   end do<a name='2667'>
690 continue<a name='2668'>
   do k = msg + 2,pver<a name='2669'>
      do i = 1,il2g<a name='2670'>
         if (k == jb(i) .and. eps0(i) &gt; 0._r8) then<a name='2671'>
            qu(i,k) = q(i,mx(i))<a name='2672'>
            su(i,k) = (hu(i,k)-rl*qu(i,k))/cp<a name='2673'>
         end if<a name='2674'>
         if ((k &gt; jt(i) .and. k &lt;= jlcl(i)) .and. eps0(i) &gt; 0._r8) then<a name='2675'>
            su(i,k) = shat(i,k) + (hu(i,k)-hsthat(i,k))/(cp* (1._r8+gamhat(i,k)))<a name='2676'>
            qu(i,k) = qsthat(i,k) + gamhat(i,k)*(hu(i,k)-hsthat(i,k))/ &amp;<a name='2677'>
                     (rl* (1._r8+gamhat(i,k)))<a name='2678'>
         end if<a name='2679'>
      end do<a name='2680'>
   end do<a name='2681'>
<a name='2682'>
<font color=#447700>! compute condensation in updraft<a name='2683'></font>
   do k = pver,msg + 2,-1<a name='2684'>
      do i = 1,il2g<a name='2685'>
         if (k &gt;= jt(i) .and. k &lt; jb(i) .and. eps0(i) &gt; 0._r8) then<a name='2686'>
            cu(i,k) = ((mu(i,k)*su(i,k)-mu(i,k+1)*su(i,k+1))/ &amp;<a name='2687'>
                      dz(i,k)- (eu(i,k)-du(i,k))*s(i,k))/(rl/cp)<a name='2688'>
            if (k == jt(i)) cu(i,k) = 0._r8<a name='2689'>
            cu(i,k) = max(0._r8,cu(i,k))<a name='2690'>
         end if<a name='2691'>
      end do<a name='2692'>
   end do<a name='2693'>
<a name='2694'>
<font color=#447700>! compute condensed liquid, rain production rate<a name='2695'></font>
<font color=#447700>! accumulate total precipitation (condensation - detrainment of liquid)<a name='2696'></font>
<font color=#447700>! Note ql1 = ql(k) + rprd(k)*dz(k)/mu(k)<a name='2697'></font>
<font color=#447700>! The differencing is somewhat strange (e.g. du(i,k)*ql(i,k+1)) but is<a name='2698'></font>
<font color=#447700>! consistently applied.<a name='2699'></font>
<font color=#447700>!    mu, ql are interface quantities<a name='2700'></font>
<font color=#447700>!    cu, du, eu, rprd are midpoint quantites<a name='2701'></font>
   do k = pver,msg + 2,-1<a name='2702'>
      do i = 1,il2g<a name='2703'>
         rprd(i,k) = 0._r8<a name='2704'>
         if (k &gt;= jt(i) .and. k &lt; jb(i) .and. eps0(i) &gt; 0._r8 .and. mu(i,k) &gt;= 0.0_r8) then<a name='2705'>
            if (mu(i,k) &gt; 0._r8) then<a name='2706'>
               ql1 = 1._r8/mu(i,k)* (mu(i,k+1)*ql(i,k+1)- &amp;<a name='2707'>
                     dz(i,k)*du(i,k)*ql(i,k+1)+dz(i,k)*cu(i,k))<a name='2708'>
               ql(i,k) = ql1/ (1._r8+dz(i,k)*c0mask(i))<a name='2709'>
            else<a name='2710'>
               ql(i,k) = 0._r8<a name='2711'>
            end if<a name='2712'>
            totpcp(i) = totpcp(i) + dz(i,k)*(cu(i,k)-du(i,k)*ql(i,k+1))<a name='2713'>
            rprd(i,k) = c0mask(i)*mu(i,k)*ql(i,k)<a name='2714'>
         end if<a name='2715'>
      end do<a name='2716'>
   end do<a name='2717'>
<font color=#447700>!<a name='2718'></font>
   do i = 1,il2g<a name='2719'>
      qd(i,jd(i)) = qds(i,jd(i))<a name='2720'>
      sd(i,jd(i)) = (hd(i,jd(i)) - rl*qd(i,jd(i)))/cp<a name='2721'>
   end do<a name='2722'>
<font color=#447700>!<a name='2723'></font>
   do k = msg + 2,pver<a name='2724'>
      do i = 1,il2g<a name='2725'>
         if (k &gt;= jd(i) .and. k &lt; jb(i) .and. eps0(i) &gt; 0._r8) then<a name='2726'>
            qd(i,k+1) = qds(i,k+1)<a name='2727'>
            evp(i,k) = -ed(i,k)*q(i,k) + (md(i,k)*qd(i,k)-md(i,k+1)*qd(i,k+1))/dz(i,k)<a name='2728'>
            evp(i,k) = max(evp(i,k),0._r8)<a name='2729'>
            mdt = min(md(i,k+1),-small)<a name='2730'>
            sd(i,k+1) = ((rl/cp*evp(i,k)-ed(i,k)*s(i,k))*dz(i,k) + md(i,k)*sd(i,k))/mdt<a name='2731'>
            totevp(i) = totevp(i) - dz(i,k)*ed(i,k)*q(i,k)<a name='2732'>
         end if<a name='2733'>
      end do<a name='2734'>
   end do<a name='2735'>
   do i = 1,il2g<a name='2736'>
<font color=#447700>!*guang         totevp(i) = totevp(i) + md(i,jd(i))*q(i,jd(i)-1) -<a name='2737'></font>
      totevp(i) = totevp(i) + md(i,jd(i))*qd(i,jd(i)) - md(i,jb(i))*qd(i,jb(i))<a name='2738'>
   end do<a name='2739'>
<font color=#447700>!!$   if (.true.) then<a name='2740'></font>
   if (.false.) then<a name='2741'>
      do i = 1,il2g<a name='2742'>
         k = jb(i)<a name='2743'>
         if (eps0(i) &gt; 0._r8) then<a name='2744'>
            evp(i,k) = -ed(i,k)*q(i,k) + (md(i,k)*qd(i,k))/dz(i,k)<a name='2745'>
            evp(i,k) = max(evp(i,k),0._r8)<a name='2746'>
            totevp(i) = totevp(i) - dz(i,k)*ed(i,k)*q(i,k)<a name='2747'>
         end if<a name='2748'>
      end do<a name='2749'>
   endif<a name='2750'>
<a name='2751'>
   do i = 1,il2g<a name='2752'>
      totpcp(i) = max(totpcp(i),0._r8)<a name='2753'>
      totevp(i) = max(totevp(i),0._r8)<a name='2754'>
   end do<a name='2755'>
<font color=#447700>!<a name='2756'></font>
   do k = msg + 2,pver<a name='2757'>
      do i = 1,il2g<a name='2758'>
         if (totevp(i) &gt; 0._r8 .and. totpcp(i) &gt; 0._r8) then<a name='2759'>
            md(i,k)  = md (i,k)*min(1._r8, totpcp(i)/(totevp(i)+totpcp(i)))<a name='2760'>
            ed(i,k)  = ed (i,k)*min(1._r8, totpcp(i)/(totevp(i)+totpcp(i)))<a name='2761'>
            evp(i,k) = evp(i,k)*min(1._r8, totpcp(i)/(totevp(i)+totpcp(i)))<a name='2762'>
         else<a name='2763'>
            md(i,k) = 0._r8<a name='2764'>
            ed(i,k) = 0._r8<a name='2765'>
            evp(i,k) = 0._r8<a name='2766'>
         end if<a name='2767'>
<font color=#447700>! cmeg is the cloud water condensed - rain water evaporated<a name='2768'></font>
<font color=#447700>! rprd is the cloud water converted to rain - (rain evaporated)<a name='2769'></font>
         cmeg(i,k) = cu(i,k) - evp(i,k)<a name='2770'>
         rprd(i,k) = rprd(i,k)-evp(i,k)<a name='2771'>
      end do<a name='2772'>
   end do<a name='2773'>
<a name='2774'>
<font color=#447700>! compute the net precipitation flux across interfaces<a name='2775'></font>
   pflx(:il2g,1) = 0._r8<a name='2776'>
   do k = 2,pverp<a name='2777'>
      do i = 1,il2g<a name='2778'>
         pflx(i,k) = pflx(i,k-1) + rprd(i,k-1)*dz(i,k-1)<a name='2779'>
      end do<a name='2780'>
   end do<a name='2781'>
<font color=#447700>!<a name='2782'></font>
   do k = msg + 1,pver<a name='2783'>
      do i = 1,il2g<a name='2784'>
         mc(i,k) = mu(i,k) + md(i,k)<a name='2785'>
      end do<a name='2786'>
   end do<a name='2787'>
<font color=#447700>!<a name='2788'></font>
   return<a name='2789'>
end subroutine cldprp<a name='2790'>
<a name='2791'>
<A NAME='CLOSURE'><A href='../../html_code/phys/module_cu_camzm.F.html#CLOSURE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='2792'>
<font color=#993300>subroutine </font><font color=#cc0000>closure</font>(lchnk   , &amp; <A href='../../call_to/CLOSURE.html' TARGET='index'>1</A><a name='2793'>
                   q       ,t       ,p       ,z       ,s       , &amp;<a name='2794'>
                   tp      ,qs      ,qu      ,su      ,mc      , &amp;<a name='2795'>
                   du      ,mu      ,md      ,qd      ,sd      , &amp;<a name='2796'>
                   qhat    ,shat    ,dp      ,qstp    ,zf      , &amp;<a name='2797'>
                   ql      ,dsubcld ,mb      ,cape    ,tl      , &amp;<a name='2798'>
                   lcl     ,lel     ,jt      ,mx      ,il1g    , &amp;<a name='2799'>
                   il2g    ,rd      ,grav    ,cp      ,rl      , &amp;<a name='2800'>
                   msg     ,capelmt )<a name='2801'>
<font color=#447700>!----------------------------------------------------------------------- <a name='2802'></font>
<font color=#447700>! <a name='2803'></font>
<font color=#447700>! Purpose: <a name='2804'></font>
<font color=#447700>! &lt;Say what the routine does&gt; <a name='2805'></font>
<font color=#447700>! <a name='2806'></font>
<font color=#447700>! Method: <a name='2807'></font>
<font color=#447700>! &lt;Describe the algorithm(s) used in the routine.&gt; <a name='2808'></font>
<font color=#447700>! &lt;Also include any applicable external references.&gt; <a name='2809'></font>
<font color=#447700>! <a name='2810'></font>
<font color=#447700>! Author: G. Zhang and collaborators. CCM contact:P. Rasch<a name='2811'></font>
<font color=#447700>! This is contributed code not fully standardized by the CCM core group.<a name='2812'></font>
<font color=#447700>!<a name='2813'></font>
<font color=#447700>! this code is very much rougher than virtually anything else in the CCM<a name='2814'></font>
<font color=#447700>! We expect to release cleaner code in a future release<a name='2815'></font>
<font color=#447700>!<a name='2816'></font>
<font color=#447700>! the documentation has been enhanced to the degree that we are able<a name='2817'></font>
<font color=#447700>! <a name='2818'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='2819'></font>
#ifndef WRF_PORT<a name='2820'>
   use dycore,    only: dycore_is, get_resolution<a name='2821'>
#endif<a name='2822'>
<a name='2823'>
   implicit none<a name='2824'>
<a name='2825'>
<font color=#447700>!<a name='2826'></font>
<font color=#447700>!-----------------------------Arguments---------------------------------<a name='2827'></font>
<font color=#447700>!<a name='2828'></font>
   integer, intent(in) :: lchnk                 <font color=#447700>! chunk identifier<a name='2829'></font>
<a name='2830'>
   real(r8), intent(inout) :: q(pcols,pver)        <font color=#447700>! spec humidity<a name='2831'></font>
   real(r8), intent(inout) :: t(pcols,pver)        <font color=#447700>! temperature<a name='2832'></font>
   real(r8), intent(inout) :: p(pcols,pver)        <font color=#447700>! pressure (mb)<a name='2833'></font>
   real(r8), intent(inout) :: mb(pcols)            <font color=#447700>! cloud base mass flux<a name='2834'></font>
   real(r8), intent(in) :: z(pcols,pver)        <font color=#447700>! height (m)<a name='2835'></font>
   real(r8), intent(in) :: s(pcols,pver)        <font color=#447700>! normalized dry static energy<a name='2836'></font>
   real(r8), intent(in) :: tp(pcols,pver)       <font color=#447700>! parcel temp<a name='2837'></font>
   real(r8), intent(in) :: qs(pcols,pver)       <font color=#447700>! sat spec humidity<a name='2838'></font>
   real(r8), intent(in) :: qu(pcols,pver)       <font color=#447700>! updraft spec. humidity<a name='2839'></font>
   real(r8), intent(in) :: su(pcols,pver)       <font color=#447700>! normalized dry stat energy of updraft<a name='2840'></font>
   real(r8), intent(in) :: mc(pcols,pver)       <font color=#447700>! net convective mass flux<a name='2841'></font>
   real(r8), intent(in) :: du(pcols,pver)       <font color=#447700>! detrainment from updraft<a name='2842'></font>
   real(r8), intent(in) :: mu(pcols,pver)       <font color=#447700>! mass flux of updraft<a name='2843'></font>
   real(r8), intent(in) :: md(pcols,pver)       <font color=#447700>! mass flux of downdraft<a name='2844'></font>
   real(r8), intent(in) :: qd(pcols,pver)       <font color=#447700>! spec. humidity of downdraft<a name='2845'></font>
   real(r8), intent(in) :: sd(pcols,pver)       <font color=#447700>! dry static energy of downdraft<a name='2846'></font>
   real(r8), intent(in) :: qhat(pcols,pver)     <font color=#447700>! environment spec humidity at interfaces<a name='2847'></font>
   real(r8), intent(in) :: shat(pcols,pver)     <font color=#447700>! env. normalized dry static energy at intrfcs<a name='2848'></font>
   real(r8), intent(in) :: dp(pcols,pver)       <font color=#447700>! pressure thickness of layers<a name='2849'></font>
   real(r8), intent(in) :: qstp(pcols,pver)     <font color=#447700>! spec humidity of parcel<a name='2850'></font>
   real(r8), intent(in) :: zf(pcols,pver+1)     <font color=#447700>! height of interface levels<a name='2851'></font>
   real(r8), intent(in) :: ql(pcols,pver)       <font color=#447700>! liquid water mixing ratio<a name='2852'></font>
<a name='2853'>
   real(r8), intent(in) :: cape(pcols)          <font color=#447700>! available pot. energy of column<a name='2854'></font>
   real(r8), intent(in) :: tl(pcols)<a name='2855'>
   real(r8), intent(in) :: dsubcld(pcols)       <font color=#447700>! thickness of subcloud layer<a name='2856'></font>
<a name='2857'>
   integer, intent(in) :: lcl(pcols)        <font color=#447700>! index of lcl<a name='2858'></font>
   integer, intent(in) :: lel(pcols)        <font color=#447700>! index of launch leve<a name='2859'></font>
   integer, intent(in) :: jt(pcols)         <font color=#447700>! top of updraft<a name='2860'></font>
   integer, intent(in) :: mx(pcols)         <font color=#447700>! base of updraft<a name='2861'></font>
<font color=#447700>!<a name='2862'></font>
<font color=#447700>!--------------------------Local variables------------------------------<a name='2863'></font>
<font color=#447700>!<a name='2864'></font>
   real(r8) dtpdt(pcols,pver)<a name='2865'>
   real(r8) dqsdtp(pcols,pver)<a name='2866'>
   real(r8) dtmdt(pcols,pver)<a name='2867'>
   real(r8) dqmdt(pcols,pver)<a name='2868'>
   real(r8) dboydt(pcols,pver)<a name='2869'>
   real(r8) thetavp(pcols,pver)<a name='2870'>
   real(r8) thetavm(pcols,pver)<a name='2871'>
<a name='2872'>
   real(r8) dtbdt(pcols),dqbdt(pcols),dtldt(pcols)<a name='2873'>
   real(r8) beta<a name='2874'>
   real(r8) capelmt<a name='2875'>
   real(r8) cp<a name='2876'>
   real(r8) dadt(pcols)<a name='2877'>
   real(r8) debdt<a name='2878'>
   real(r8) dltaa<a name='2879'>
   real(r8) eb<a name='2880'>
   real(r8) grav<a name='2881'>
<a name='2882'>
   integer i<a name='2883'>
   integer il1g<a name='2884'>
   integer il2g<a name='2885'>
   integer k, kmin, kmax<a name='2886'>
   integer msg<a name='2887'>
<a name='2888'>
   real(r8) rd<a name='2889'>
   real(r8) rl<a name='2890'>
<font color=#447700>! change of subcloud layer properties due to convection is<a name='2891'></font>
<font color=#447700>! related to cumulus updrafts and downdrafts.<a name='2892'></font>
<font color=#447700>! mc(z)=f(z)*mb, mub=betau*mb, mdb=betad*mb are used<a name='2893'></font>
<font color=#447700>! to define betau, betad and f(z).<a name='2894'></font>
<font color=#447700>! note that this implies all time derivatives are in effect<a name='2895'></font>
<font color=#447700>! time derivatives per unit cloud-base mass flux, i.e. they<a name='2896'></font>
<font color=#447700>! have units of 1/mb instead of 1/sec.<a name='2897'></font>
<font color=#447700>!<a name='2898'></font>
   do i = il1g,il2g<a name='2899'>
      mb(i) = 0._r8<a name='2900'>
      eb = p(i,mx(i))*q(i,mx(i))/ (eps1+q(i,mx(i)))<a name='2901'>
      dtbdt(i) = (1._r8/dsubcld(i))* (mu(i,mx(i))*(shat(i,mx(i))-su(i,mx(i)))+ &amp;<a name='2902'>
                  md(i,mx(i))* (shat(i,mx(i))-sd(i,mx(i))))<a name='2903'>
      dqbdt(i) = (1._r8/dsubcld(i))* (mu(i,mx(i))*(qhat(i,mx(i))-qu(i,mx(i)))+ &amp;<a name='2904'>
                 md(i,mx(i))* (qhat(i,mx(i))-qd(i,mx(i))))<a name='2905'>
      debdt = eps1*p(i,mx(i))/ (eps1+q(i,mx(i)))**2*dqbdt(i)<a name='2906'>
      dtldt(i) = -2840._r8* (3.5_r8/t(i,mx(i))*dtbdt(i)-debdt/eb)/ &amp;<a name='2907'>
                 (3.5_r8*log(t(i,mx(i)))-log(eb)-4.805_r8)**2<a name='2908'>
   end do<a name='2909'>
<font color=#447700>!<a name='2910'></font>
<font color=#447700>!   dtmdt and dqmdt are cumulus heating and drying.<a name='2911'></font>
<font color=#447700>!<a name='2912'></font>
   do k = msg + 1,pver<a name='2913'>
      do i = il1g,il2g<a name='2914'>
         dtmdt(i,k) = 0._r8<a name='2915'>
         dqmdt(i,k) = 0._r8<a name='2916'>
      end do<a name='2917'>
   end do<a name='2918'>
<font color=#447700>!<a name='2919'></font>
   do k = msg + 1,pver - 1<a name='2920'>
      do i = il1g,il2g<a name='2921'>
         if (k == jt(i)) then<a name='2922'>
            dtmdt(i,k) = (1._r8/dp(i,k))*(mu(i,k+1)* (su(i,k+1)-shat(i,k+1)- &amp;<a name='2923'>
                          rl/cp*ql(i,k+1))+md(i,k+1)* (sd(i,k+1)-shat(i,k+1)))<a name='2924'>
            dqmdt(i,k) = (1._r8/dp(i,k))*(mu(i,k+1)* (qu(i,k+1)- &amp;<a name='2925'>
                         qhat(i,k+1)+ql(i,k+1))+md(i,k+1)*(qd(i,k+1)-qhat(i,k+1)))<a name='2926'>
         end if<a name='2927'>
      end do<a name='2928'>
   end do<a name='2929'>
<font color=#447700>!<a name='2930'></font>
   beta = 0._r8<a name='2931'>
   do k = msg + 1,pver - 1<a name='2932'>
      do i = il1g,il2g<a name='2933'>
         if (k &gt; jt(i) .and. k &lt; mx(i)) then<a name='2934'>
            dtmdt(i,k) = (mc(i,k)* (shat(i,k)-s(i,k))+mc(i,k+1)* (s(i,k)-shat(i,k+1)))/ &amp;<a name='2935'>
                         dp(i,k) - rl/cp*du(i,k)*(beta*ql(i,k)+ (1-beta)*ql(i,k+1))<a name='2936'>
<font color=#447700>!          dqmdt(i,k)=(mc(i,k)*(qhat(i,k)-q(i,k))<a name='2937'></font>
<font color=#447700>!     1                +mc(i,k+1)*(q(i,k)-qhat(i,k+1)))/dp(i,k)<a name='2938'></font>
<font color=#447700>!     2                +du(i,k)*(qs(i,k)-q(i,k))<a name='2939'></font>
<font color=#447700>!     3                +du(i,k)*(beta*ql(i,k)+(1-beta)*ql(i,k+1))<a name='2940'></font>
<a name='2941'>
            dqmdt(i,k) = (mu(i,k+1)* (qu(i,k+1)-qhat(i,k+1)+cp/rl* (su(i,k+1)-s(i,k)))- &amp;<a name='2942'>
                          mu(i,k)* (qu(i,k)-qhat(i,k)+cp/rl*(su(i,k)-s(i,k)))+md(i,k+1)* &amp;<a name='2943'>
                         (qd(i,k+1)-qhat(i,k+1)+cp/rl*(sd(i,k+1)-s(i,k)))-md(i,k)* &amp;<a name='2944'>
                         (qd(i,k)-qhat(i,k)+cp/rl*(sd(i,k)-s(i,k))))/dp(i,k) + &amp;<a name='2945'>
                          du(i,k)* (beta*ql(i,k)+(1-beta)*ql(i,k+1))<a name='2946'>
         end if<a name='2947'>
      end do<a name='2948'>
   end do<a name='2949'>
<font color=#447700>!<a name='2950'></font>
   do k = msg + 1,pver<a name='2951'>
      do i = il1g,il2g<a name='2952'>
         if (k &gt;= lel(i) .and. k &lt;= lcl(i)) then<a name='2953'>
            thetavp(i,k) = tp(i,k)* (1000._r8/p(i,k))** (rd/cp)*(1._r8+1.608_r8*qstp(i,k)-q(i,mx(i)))<a name='2954'>
            thetavm(i,k) = t(i,k)* (1000._r8/p(i,k))** (rd/cp)*(1._r8+0.608_r8*q(i,k))<a name='2955'>
            dqsdtp(i,k) = qstp(i,k)* (1._r8+qstp(i,k)/eps1)*eps1*rl/(rd*tp(i,k)**2)<a name='2956'>
<font color=#447700>!<a name='2957'></font>
<font color=#447700>! dtpdt is the parcel temperature change due to change of<a name='2958'></font>
<font color=#447700>! subcloud layer properties during convection.<a name='2959'></font>
<font color=#447700>!<a name='2960'></font>
            dtpdt(i,k) = tp(i,k)/ (1._r8+rl/cp* (dqsdtp(i,k)-qstp(i,k)/tp(i,k)))* &amp;<a name='2961'>
                        (dtbdt(i)/t(i,mx(i))+rl/cp* (dqbdt(i)/tl(i)-q(i,mx(i))/ &amp;<a name='2962'>
                         tl(i)**2*dtldt(i)))<a name='2963'>
<font color=#447700>!<a name='2964'></font>
<font color=#447700>! dboydt is the integrand of cape change.<a name='2965'></font>
<font color=#447700>!<a name='2966'></font>
            dboydt(i,k) = ((dtpdt(i,k)/tp(i,k)+1._r8/(1._r8+1.608_r8*qstp(i,k)-q(i,mx(i)))* &amp;<a name='2967'>
                          (1.608_r8 * dqsdtp(i,k) * dtpdt(i,k) -dqbdt(i))) - (dtmdt(i,k)/t(i,k)+0.608_r8/ &amp;<a name='2968'>
                          (1._r8+0.608_r8*q(i,k))*dqmdt(i,k)))*grav*thetavp(i,k)/thetavm(i,k)<a name='2969'>
         end if<a name='2970'>
      end do<a name='2971'>
   end do<a name='2972'>
<font color=#447700>!<a name='2973'></font>
   do k = msg + 1,pver<a name='2974'>
      do i = il1g,il2g<a name='2975'>
         if (k &gt; lcl(i) .and. k &lt; mx(i)) then<a name='2976'>
            thetavp(i,k) = tp(i,k)* (1000._r8/p(i,k))** (rd/cp)*(1._r8+0.608_r8*q(i,mx(i)))<a name='2977'>
            thetavm(i,k) = t(i,k)* (1000._r8/p(i,k))** (rd/cp)*(1._r8+0.608_r8*q(i,k))<a name='2978'>
<font color=#447700>!<a name='2979'></font>
<font color=#447700>! dboydt is the integrand of cape change.<a name='2980'></font>
<font color=#447700>!<a name='2981'></font>
            dboydt(i,k) = (dtbdt(i)/t(i,mx(i))+0.608_r8/ (1._r8+0.608_r8*q(i,mx(i)))*dqbdt(i)- &amp;<a name='2982'>
                          dtmdt(i,k)/t(i,k)-0.608_r8/ (1._r8+0.608_r8*q(i,k))*dqmdt(i,k))* &amp;<a name='2983'>
                          grav*thetavp(i,k)/thetavm(i,k)<a name='2984'>
         end if<a name='2985'>
      end do<a name='2986'>
   end do<a name='2987'>
<a name='2988'>
<font color=#447700>!<a name='2989'></font>
<font color=#447700>! buoyant energy change is set to 2/3*excess cape per 3 hours<a name='2990'></font>
<font color=#447700>!<a name='2991'></font>
   dadt(il1g:il2g)  = 0._r8<a name='2992'>
   kmin = minval(lel(il1g:il2g))<a name='2993'>
   kmax = maxval(mx(il1g:il2g)) - 1<a name='2994'>
   do k = kmin, kmax<a name='2995'>
      do i = il1g,il2g<a name='2996'>
         if ( k &gt;= lel(i) .and. k &lt;= mx(i) - 1) then<a name='2997'>
            dadt(i) = dadt(i) + dboydt(i,k)* (zf(i,k)-zf(i,k+1))<a name='2998'>
         endif<a name='2999'>
      end do<a name='3000'>
   end do<a name='3001'>
   do i = il1g,il2g<a name='3002'>
      dltaa = -1._r8* (cape(i)-capelmt)<a name='3003'>
      if (dadt(i) /= 0._r8) mb(i) = max(dltaa/tau/dadt(i),0._r8)<a name='3004'>
   end do<a name='3005'>
<font color=#447700>!<a name='3006'></font>
   return<a name='3007'>
end subroutine closure<a name='3008'>
<a name='3009'>
<A NAME='Q1Q2_PJR'><A href='../../html_code/phys/module_cu_camzm.F.html#Q1Q2_PJR' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3010'>
<font color=#993300>subroutine </font><font color=#cc0000>q1q2_pjr</font>(lchnk   , &amp; <A href='../../call_to/Q1Q2_PJR.html' TARGET='index'>1</A><a name='3011'>
                    dqdt    ,dsdt    ,q       ,qs      ,qu      , &amp;<a name='3012'>
                    su      ,du      ,qhat    ,shat    ,dp      , &amp;<a name='3013'>
                    mu      ,md      ,sd      ,qd      ,ql      , &amp;<a name='3014'>
                    dsubcld ,jt      ,mx      ,il1g    ,il2g    , &amp;<a name='3015'>
                    cp      ,rl      ,msg     ,          &amp;<a name='3016'>
                    dl      ,evp     ,cu      )<a name='3017'>
<a name='3018'>
<a name='3019'>
   implicit none<a name='3020'>
<a name='3021'>
<font color=#447700>!----------------------------------------------------------------------- <a name='3022'></font>
<font color=#447700>! <a name='3023'></font>
<font color=#447700>! Purpose: <a name='3024'></font>
<font color=#447700>! &lt;Say what the routine does&gt; <a name='3025'></font>
<font color=#447700>! <a name='3026'></font>
<font color=#447700>! Method: <a name='3027'></font>
<font color=#447700>! &lt;Describe the algorithm(s) used in the routine.&gt; <a name='3028'></font>
<font color=#447700>! &lt;Also include any applicable external references.&gt; <a name='3029'></font>
<font color=#447700>! <a name='3030'></font>
<font color=#447700>! Author: phil rasch dec 19 1995<a name='3031'></font>
<font color=#447700>! <a name='3032'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='3033'></font>
<a name='3034'>
<a name='3035'>
   real(r8), intent(in) :: cp<a name='3036'>
<a name='3037'>
   integer, intent(in) :: lchnk             <font color=#447700>! chunk identifier<a name='3038'></font>
   integer, intent(in) :: il1g<a name='3039'>
   integer, intent(in) :: il2g<a name='3040'>
   integer, intent(in) :: msg<a name='3041'>
<a name='3042'>
   real(r8), intent(in) :: q(pcols,pver)<a name='3043'>
   real(r8), intent(in) :: qs(pcols,pver)<a name='3044'>
   real(r8), intent(in) :: qu(pcols,pver)<a name='3045'>
   real(r8), intent(in) :: su(pcols,pver)<a name='3046'>
   real(r8), intent(in) :: du(pcols,pver)<a name='3047'>
   real(r8), intent(in) :: qhat(pcols,pver)<a name='3048'>
   real(r8), intent(in) :: shat(pcols,pver)<a name='3049'>
   real(r8), intent(in) :: dp(pcols,pver)<a name='3050'>
   real(r8), intent(in) :: mu(pcols,pver)<a name='3051'>
   real(r8), intent(in) :: md(pcols,pver)<a name='3052'>
   real(r8), intent(in) :: sd(pcols,pver)<a name='3053'>
   real(r8), intent(in) :: qd(pcols,pver)<a name='3054'>
   real(r8), intent(in) :: ql(pcols,pver)<a name='3055'>
   real(r8), intent(in) :: evp(pcols,pver)<a name='3056'>
   real(r8), intent(in) :: cu(pcols,pver)<a name='3057'>
   real(r8), intent(in) :: dsubcld(pcols)<a name='3058'>
<a name='3059'>
   real(r8),intent(out) :: dqdt(pcols,pver),dsdt(pcols,pver)<a name='3060'>
   real(r8),intent(out) :: dl(pcols,pver)<a name='3061'>
   integer kbm<a name='3062'>
   integer ktm<a name='3063'>
   integer jt(pcols)<a name='3064'>
   integer mx(pcols)<a name='3065'>
<font color=#447700>!<a name='3066'></font>
<font color=#447700>! work fields:<a name='3067'></font>
<font color=#447700>!<a name='3068'></font>
   integer i<a name='3069'>
   integer k<a name='3070'>
<a name='3071'>
   real(r8) emc<a name='3072'>
   real(r8) rl<a name='3073'>
<font color=#447700>!-------------------------------------------------------------------<a name='3074'></font>
   do k = msg + 1,pver<a name='3075'>
      do i = il1g,il2g<a name='3076'>
         dsdt(i,k) = 0._r8<a name='3077'>
         dqdt(i,k) = 0._r8<a name='3078'>
         dl(i,k) = 0._r8<a name='3079'>
      end do<a name='3080'>
   end do<a name='3081'>
<font color=#447700>!<a name='3082'></font>
<font color=#447700>! find the highest level top and bottom levels of convection<a name='3083'></font>
<font color=#447700>!<a name='3084'></font>
   ktm = pver<a name='3085'>
   kbm = pver<a name='3086'>
   do i = il1g, il2g<a name='3087'>
      ktm = min(ktm,jt(i))<a name='3088'>
      kbm = min(kbm,mx(i))<a name='3089'>
   end do<a name='3090'>
<a name='3091'>
   do k = ktm,pver-1<a name='3092'>
      do i = il1g,il2g<a name='3093'>
         emc = -cu (i,k)               &amp;         <font color=#447700>! condensation in updraft<a name='3094'></font>
               +evp(i,k)                         <font color=#447700>! evaporating rain in downdraft<a name='3095'></font>
<a name='3096'>
         dsdt(i,k) = -rl/cp*emc &amp;<a name='3097'>
                     + (+mu(i,k+1)* (su(i,k+1)-shat(i,k+1)) &amp;<a name='3098'>
                        -mu(i,k)*   (su(i,k)-shat(i,k)) &amp;<a name='3099'>
                        +md(i,k+1)* (sd(i,k+1)-shat(i,k+1)) &amp;<a name='3100'>
                        -md(i,k)*   (sd(i,k)-shat(i,k)) &amp;<a name='3101'>
                       )/dp(i,k)<a name='3102'>
<a name='3103'>
         dqdt(i,k) = emc + &amp;<a name='3104'>
                    (+mu(i,k+1)* (qu(i,k+1)-qhat(i,k+1)) &amp;<a name='3105'>
                     -mu(i,k)*   (qu(i,k)-qhat(i,k)) &amp;<a name='3106'>
                     +md(i,k+1)* (qd(i,k+1)-qhat(i,k+1)) &amp;<a name='3107'>
                     -md(i,k)*   (qd(i,k)-qhat(i,k)) &amp;<a name='3108'>
                    )/dp(i,k)<a name='3109'>
<a name='3110'>
         dl(i,k) = du(i,k)*ql(i,k+1)<a name='3111'>
<a name='3112'>
      end do<a name='3113'>
   end do<a name='3114'>
<a name='3115'>
<font color=#447700>!<a name='3116'></font>
<font color=#447700>!DIR$ NOINTERCHANGE!<a name='3117'></font>
   do k = kbm,pver<a name='3118'>
      do i = il1g,il2g<a name='3119'>
         if (k == mx(i)) then<a name='3120'>
            dsdt(i,k) = (1._r8/dsubcld(i))* &amp;<a name='3121'>
                        (-mu(i,k)* (su(i,k)-shat(i,k)) &amp;<a name='3122'>
                         -md(i,k)* (sd(i,k)-shat(i,k)) &amp;<a name='3123'>
                        )<a name='3124'>
            dqdt(i,k) = (1._r8/dsubcld(i))* &amp;<a name='3125'>
                        (-mu(i,k)*(qu(i,k)-qhat(i,k)) &amp;<a name='3126'>
                         -md(i,k)*(qd(i,k)-qhat(i,k)) &amp;<a name='3127'>
                        )<a name='3128'>
         else if (k &gt; mx(i)) then<a name='3129'>
            dsdt(i,k) = dsdt(i,k-1)<a name='3130'>
            dqdt(i,k) = dqdt(i,k-1)<a name='3131'>
         end if<a name='3132'>
      end do<a name='3133'>
   end do<a name='3134'>
<font color=#447700>!<a name='3135'></font>
   return<a name='3136'>
end subroutine q1q2_pjr<a name='3137'>
<a name='3138'>
<A NAME='BUOYAN_DILUTE'><A href='../../html_code/phys/module_cu_camzm.F.html#BUOYAN_DILUTE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3139'>
<font color=#993300>subroutine </font><font color=#cc0000>buoyan_dilute</font>(lchnk   ,ncol    , &amp; <A href='../../call_to/BUOYAN_DILUTE.html' TARGET='index'>1</A>,<A href='../../call_from/BUOYAN_DILUTE.html' TARGET='index'>1</A><a name='3140'>
                  q       ,t       ,p       ,z       ,pf      , &amp;<a name='3141'>
                  tp      ,qstp    ,tl      ,rl      ,cape    , &amp;<a name='3142'>
                  pblt    ,lcl     ,lel     ,lon     ,mx      , &amp;<a name='3143'>
                  rd      ,grav    ,cp      ,msg     , &amp;<a name='3144'>
                  tpert   )<a name='3145'>
<font color=#447700>!----------------------------------------------------------------------- <a name='3146'></font>
<font color=#447700>! <a name='3147'></font>
<font color=#447700>! Purpose: <a name='3148'></font>
<font color=#447700>! Calculates CAPE the lifting condensation level and the convective top<a name='3149'></font>
<font color=#447700>! where buoyancy is first -ve.<a name='3150'></font>
<font color=#447700>! <a name='3151'></font>
<font color=#447700>! Method: Calculates the parcel temperature based on a simple constant<a name='3152'></font>
<font color=#447700>! entraining plume model. CAPE is integrated from buoyancy.<a name='3153'></font>
<font color=#447700>! 09/09/04 - Simplest approach using an assumed entrainment rate for <a name='3154'></font>
<font color=#447700>!            testing (dmpdp). <a name='3155'></font>
<font color=#447700>! 08/04/05 - Swap to convert dmpdz to dmpdp  <a name='3156'></font>
<font color=#447700>!<a name='3157'></font>
<font color=#447700>! SCAM Logical Switches - DILUTE:RBN - Now Disabled <a name='3158'></font>
<font color=#447700>! ---------------------<a name='3159'></font>
<font color=#447700>! switch(1) = .T. - Uses the dilute parcel calculation to obtain tendencies.<a name='3160'></font>
<font color=#447700>! switch(2) = .T. - Includes entropy/q changes due to condensate loss and freezing.<a name='3161'></font>
<font color=#447700>! switch(3) = .T. - Adds the PBL Tpert for the parcel temperature at all levels.<a name='3162'></font>
<font color=#447700>! <a name='3163'></font>
<font color=#447700>! References:<a name='3164'></font>
<font color=#447700>! Raymond and Blythe (1992) JAS <a name='3165'></font>
<font color=#447700>! <a name='3166'></font>
<font color=#447700>! Author:<a name='3167'></font>
<font color=#447700>! Richard Neale - September 2004<a name='3168'></font>
<font color=#447700>! <a name='3169'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='3170'></font>
   implicit none<a name='3171'>
<font color=#447700>!-----------------------------------------------------------------------<a name='3172'></font>
<font color=#447700>!<a name='3173'></font>
<font color=#447700>! input arguments<a name='3174'></font>
<font color=#447700>!<a name='3175'></font>
   integer, intent(in) :: lchnk                 <font color=#447700>! chunk identifier<a name='3176'></font>
   integer, intent(in) :: ncol                  <font color=#447700>! number of atmospheric columns<a name='3177'></font>
<a name='3178'>
   real(r8), intent(in) :: q(pcols,pver)        <font color=#447700>! spec. humidity<a name='3179'></font>
   real(r8), intent(in) :: t(pcols,pver)        <font color=#447700>! temperature<a name='3180'></font>
   real(r8), intent(in) :: p(pcols,pver)        <font color=#447700>! pressure<a name='3181'></font>
   real(r8), intent(in) :: z(pcols,pver)        <font color=#447700>! height<a name='3182'></font>
   real(r8), intent(in) :: pf(pcols,pver+1)     <font color=#447700>! pressure at interfaces<a name='3183'></font>
   real(r8), intent(in) :: pblt(pcols)          <font color=#447700>! index of pbl depth<a name='3184'></font>
   real(r8), intent(in) :: tpert(pcols)         <font color=#447700>! perturbation temperature by pbl processes<a name='3185'></font>
<a name='3186'>
<font color=#447700>!<a name='3187'></font>
<font color=#447700>! output arguments<a name='3188'></font>
<font color=#447700>!<a name='3189'></font>
   real(r8), intent(out) :: tp(pcols,pver)       <font color=#447700>! parcel temperature<a name='3190'></font>
   real(r8), intent(out) :: qstp(pcols,pver)     <font color=#447700>! saturation mixing ratio of parcel (only above lcl, just q below).<a name='3191'></font>
   real(r8), intent(out) :: tl(pcols)            <font color=#447700>! parcel temperature at lcl<a name='3192'></font>
   real(r8), intent(out) :: cape(pcols)          <font color=#447700>! convective aval. pot. energy.<a name='3193'></font>
   integer lcl(pcols)        <font color=#447700>!<a name='3194'></font>
   integer lel(pcols)        <font color=#447700>!<a name='3195'></font>
   integer lon(pcols)        <font color=#447700>! level of onset of deep convection<a name='3196'></font>
   integer mx(pcols)         <font color=#447700>! level of max moist static energy<a name='3197'></font>
<font color=#447700>!<a name='3198'></font>
<font color=#447700>!--------------------------Local Variables------------------------------<a name='3199'></font>
<font color=#447700>!<a name='3200'></font>
   real(r8) capeten(pcols,5)     <font color=#447700>! provisional value of cape<a name='3201'></font>
   real(r8) tv(pcols,pver)       <font color=#447700>!<a name='3202'></font>
   real(r8) tpv(pcols,pver)      <font color=#447700>!<a name='3203'></font>
   real(r8) buoy(pcols,pver)<a name='3204'>
<a name='3205'>
   real(r8) a1(pcols)<a name='3206'>
   real(r8) a2(pcols)<a name='3207'>
   real(r8) estp(pcols)<a name='3208'>
   real(r8) pl(pcols)<a name='3209'>
   real(r8) plexp(pcols)<a name='3210'>
   real(r8) hmax(pcols)<a name='3211'>
   real(r8) hmn(pcols)<a name='3212'>
   real(r8) y(pcols)<a name='3213'>
<a name='3214'>
   logical plge600(pcols)<a name='3215'>
   integer knt(pcols)<a name='3216'>
   integer lelten(pcols,5)<a name='3217'>
<a name='3218'>
   real(r8) cp<a name='3219'>
   real(r8) e<a name='3220'>
   real(r8) grav<a name='3221'>
<a name='3222'>
   integer i<a name='3223'>
   integer k<a name='3224'>
   integer msg<a name='3225'>
   integer n<a name='3226'>
<a name='3227'>
   real(r8) rd<a name='3228'>
   real(r8) rl<a name='3229'>
#ifdef PERGRO<a name='3230'>
   real(r8) rhd<a name='3231'>
#endif<a name='3232'>
<font color=#447700>!<a name='3233'></font>
<font color=#447700>!-----------------------------------------------------------------------<a name='3234'></font>
<font color=#447700>!<a name='3235'></font>
   do n = 1,5<a name='3236'>
      do i = 1,ncol<a name='3237'>
         lelten(i,n) = pver<a name='3238'>
         capeten(i,n) = 0._r8<a name='3239'>
      end do<a name='3240'>
   end do<a name='3241'>
<font color=#447700>!<a name='3242'></font>
   do i = 1,ncol<a name='3243'>
      lon(i) = pver<a name='3244'>
      knt(i) = 0<a name='3245'>
      lel(i) = pver<a name='3246'>
      mx(i) = lon(i)<a name='3247'>
      cape(i) = 0._r8<a name='3248'>
      hmax(i) = 0._r8<a name='3249'>
   end do<a name='3250'>
<a name='3251'>
   tp(:ncol,:) = t(:ncol,:)<a name='3252'>
   qstp(:ncol,:) = q(:ncol,:)<a name='3253'>
<a name='3254'>
<font color=#447700>!!! RBN - Initialize tv and buoy for output.<a name='3255'></font>
<font color=#447700>!!! tv=tv : tpv=tpv : qstp=q : buoy=0.<a name='3256'></font>
   tv(:ncol,:) = t(:ncol,:) *(1._r8+1.608_r8*q(:ncol,:))/ (1._r8+q(:ncol,:))<a name='3257'>
   tpv(:ncol,:) = tv(:ncol,:)<a name='3258'>
   buoy(:ncol,:) = 0._r8<a name='3259'>
<a name='3260'>
<font color=#447700>!<a name='3261'></font>
<font color=#447700>! set "launching" level(mx) to be at maximum moist static energy.<a name='3262'></font>
<font color=#447700>! search for this level stops at planetary boundary layer top.<a name='3263'></font>
<font color=#447700>!<a name='3264'></font>
#ifdef PERGRO<a name='3265'>
   do k = pver,msg + 1,-1<a name='3266'>
      do i = 1,ncol<a name='3267'>
         hmn(i) = cp*t(i,k) + grav*z(i,k) + rl*q(i,k)<a name='3268'>
<font color=#447700>!<a name='3269'></font>
<font color=#447700>! Reset max moist static energy level when relative difference exceeds 1.e-4<a name='3270'></font>
<font color=#447700>!<a name='3271'></font>
         rhd = (hmn(i) - hmax(i))/(hmn(i) + hmax(i))<a name='3272'>
         if (k &gt;= nint(pblt(i)) .and. k &lt;= lon(i) .and. rhd &gt; -1.e-4_r8) then<a name='3273'>
            hmax(i) = hmn(i)<a name='3274'>
            mx(i) = k<a name='3275'>
         end if<a name='3276'>
      end do<a name='3277'>
   end do<a name='3278'>
#else<a name='3279'>
   do k = pver,msg + 1,-1<a name='3280'>
      do i = 1,ncol<a name='3281'>
         hmn(i) = cp*t(i,k) + grav*z(i,k) + rl*q(i,k)<a name='3282'>
         if (k &gt;= nint(pblt(i)) .and. k &lt;= lon(i) .and. hmn(i) &gt; hmax(i)) then<a name='3283'>
            hmax(i) = hmn(i)<a name='3284'>
            mx(i) = k<a name='3285'>
         end if<a name='3286'>
      end do<a name='3287'>
   end do<a name='3288'>
#endif<a name='3289'>
<a name='3290'>
<font color=#447700>! LCL dilute calculation - initialize to mx(i)<a name='3291'></font>
<font color=#447700>! Determine lcl in parcel_dilute and get pl,tl after parcel_dilute<a name='3292'></font>
<font color=#447700>! Original code actually sets LCL as level above wher condensate forms.<a name='3293'></font>
<font color=#447700>! Therefore in parcel_dilute lcl(i) will be at first level where qsmix &lt; qtmix.<a name='3294'></font>
<a name='3295'>
   do i = 1,ncol <font color=#447700>! Initialise LCL variables.<a name='3296'></font>
      lcl(i) = mx(i)<a name='3297'>
      tl(i) = t(i,mx(i))<a name='3298'>
      pl(i) = p(i,mx(i))<a name='3299'>
   end do<a name='3300'>
<a name='3301'>
<font color=#447700>!<a name='3302'></font>
<font color=#447700>! main buoyancy calculation.<a name='3303'></font>
<font color=#447700>!<a name='3304'></font>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='3305'></font>
<font color=#447700>!!! DILUTE PLUME CALCULATION USING ENTRAINING PLUME !!!<a name='3306'></font>
<font color=#447700>!!!   RBN 9/9/04   !!!<a name='3307'></font>
<a name='3308'>
   call <A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE'>parcel_dilute</A><A href='../../html_code/phys/module_cu_camzm.F.html#BUOYAN_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="PARCEL_DILUTE_1">(lchnk, ncol, msg, mx, p, t, q, tpert, tp, tpv, qstp, pl, tl, lcl)<a name='3309'>
<a name='3310'>
<a name='3311'>
<font color=#447700>! If lcl is above the nominal level of non-divergence (600 mbs),<a name='3312'></font>
<font color=#447700>! no deep convection is permitted (ensuing calculations<a name='3313'></font>
<font color=#447700>! skipped and cape retains initialized value of zero).<a name='3314'></font>
<font color=#447700>!<a name='3315'></font>
   do i = 1,ncol<a name='3316'>
      plge600(i) = pl(i).ge.600._r8 <font color=#447700>! Just change to always allow buoy calculation.<a name='3317'></font>
   end do<a name='3318'>
<a name='3319'>
<font color=#447700>!<a name='3320'></font>
<font color=#447700>! Main buoyancy calculation.<a name='3321'></font>
<font color=#447700>!<a name='3322'></font>
   do k = pver,msg + 1,-1<a name='3323'>
      do i=1,ncol<a name='3324'>
         if (k &lt;= mx(i) .and. plge600(i)) then   <font color=#447700>! Define buoy from launch level to cloud top.<a name='3325'></font>
            tv(i,k) = t(i,k)* (1._r8+1.608_r8*q(i,k))/ (1._r8+q(i,k))<a name='3326'>
            buoy(i,k) = tpv(i,k) - tv(i,k) + tiedke_add  <font color=#447700>! +0.5K or not?<a name='3327'></font>
         else<a name='3328'>
            qstp(i,k) = q(i,k)<a name='3329'>
            tp(i,k)   = t(i,k)            <a name='3330'>
            tpv(i,k)  = tv(i,k)<a name='3331'>
         endif<a name='3332'>
      end do<a name='3333'>
   end do<a name='3334'>
<a name='3335'>
<a name='3336'>
<a name='3337'>
<font color=#447700>!-------------------------------------------------------------------------------<a name='3338'></font>
<a name='3339'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='3340'></font>
<a name='3341'>
<a name='3342'>
<a name='3343'>
<font color=#447700>!<a name='3344'></font>
   do k = msg + 2,pver<a name='3345'>
      do i = 1,ncol<a name='3346'>
         if (k &lt; lcl(i) .and. plge600(i)) then<a name='3347'>
            if (buoy(i,k+1) &gt; 0. .and. buoy(i,k) &lt;= 0._r8) then<a name='3348'>
               knt(i) = min(5,knt(i) + 1)<a name='3349'>
               lelten(i,knt(i)) = k<a name='3350'>
            end if<a name='3351'>
         end if<a name='3352'>
      end do<a name='3353'>
   end do<a name='3354'>
<font color=#447700>!<a name='3355'></font>
<font color=#447700>! calculate convective available potential energy (cape).<a name='3356'></font>
<font color=#447700>!<a name='3357'></font>
   do n = 1,5<a name='3358'>
      do k = msg + 1,pver<a name='3359'>
         do i = 1,ncol<a name='3360'>
            if (plge600(i) .and. k &lt;= mx(i) .and. k &gt; lelten(i,n)) then<a name='3361'>
               capeten(i,n) = capeten(i,n) + rd*buoy(i,k)*log(pf(i,k+1)/pf(i,k))<a name='3362'>
            end if<a name='3363'>
         end do<a name='3364'>
      end do<a name='3365'>
   end do<a name='3366'>
<font color=#447700>!<a name='3367'></font>
<font color=#447700>! find maximum cape from all possible tentative capes from<a name='3368'></font>
<font color=#447700>! one sounding,<a name='3369'></font>
<font color=#447700>! and use it as the final cape, april 26, 1995<a name='3370'></font>
<font color=#447700>!<a name='3371'></font>
   do n = 1,5<a name='3372'>
      do i = 1,ncol<a name='3373'>
         if (capeten(i,n) &gt; cape(i)) then<a name='3374'>
            cape(i) = capeten(i,n)<a name='3375'>
            lel(i) = lelten(i,n)<a name='3376'>
         end if<a name='3377'>
      end do<a name='3378'>
   end do<a name='3379'>
<font color=#447700>!<a name='3380'></font>
<font color=#447700>! put lower bound on cape for diagnostic purposes.<a name='3381'></font>
<font color=#447700>!<a name='3382'></font>
   do i = 1,ncol<a name='3383'>
      cape(i) = max(cape(i), 0._r8)<a name='3384'>
   end do<a name='3385'>
<font color=#447700>!<a name='3386'></font>
   return<a name='3387'>
end subroutine buoyan_dilute<a name='3388'>
<a name='3389'>
<A NAME='PARCEL_DILUTE'><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3390'>
<font color=#993300>subroutine </font><font color=#cc0000>parcel_dilute</font> (lchnk, ncol, msg, klaunch, p, t, q, tpert, tp, tpv, qstp, pl, tl, lcl) <A href='../../call_to/PARCEL_DILUTE.html' TARGET='index'>1</A>,<A href='../../call_from/PARCEL_DILUTE.html' TARGET='index'>6</A><a name='3391'>
<a name='3392'>
<font color=#447700>! Routine  to determine <a name='3393'></font>
<font color=#447700>!   1. Tp   - Parcel temperature<a name='3394'></font>
<font color=#447700>!   2. qstp - Saturated mixing ratio at the parcel temperature.<a name='3395'></font>
<a name='3396'>
<font color=#447700>!--------------------<a name='3397'></font>
implicit none<a name='3398'>
<font color=#447700>!--------------------<a name='3399'></font>
<a name='3400'>
integer, intent(in) :: lchnk<a name='3401'>
integer, intent(in) :: ncol<a name='3402'>
integer, intent(in) :: msg<a name='3403'>
<a name='3404'>
integer, intent(in), dimension(pcols) :: klaunch(pcols)<a name='3405'>
<a name='3406'>
real(r8), intent(in), dimension(pcols,pver) :: p<a name='3407'>
real(r8), intent(in), dimension(pcols,pver) :: t<a name='3408'>
real(r8), intent(in), dimension(pcols,pver) :: q<a name='3409'>
real(r8), intent(in), dimension(pcols) :: tpert <font color=#447700>! PBL temperature perturbation.<a name='3410'></font>
<a name='3411'>
real(r8), intent(inout), dimension(pcols,pver) :: tp    <font color=#447700>! Parcel temp.<a name='3412'></font>
real(r8), intent(inout), dimension(pcols,pver) :: qstp  <font color=#447700>! Parcel water vapour (sat value above lcl).<a name='3413'></font>
real(r8), intent(inout), dimension(pcols) :: tl         <font color=#447700>! Actual temp of LCL.<a name='3414'></font>
real(r8), intent(inout), dimension(pcols) :: pl          <font color=#447700>! Actual pressure of LCL. <a name='3415'></font>
<a name='3416'>
integer, intent(inout), dimension(pcols) :: lcl <font color=#447700>! Lifting condesation level (first model level with saturation).<a name='3417'></font>
<a name='3418'>
real(r8), intent(out), dimension(pcols,pver) :: tpv   <font color=#447700>! Define tpv within this routine.<a name='3419'></font>
<a name='3420'>
<font color=#447700>!--------------------<a name='3421'></font>
<a name='3422'>
<font color=#447700>! Have to be careful as s is also dry static energy.<a name='3423'></font>
<a name='3424'>
<a name='3425'>
<font color=#447700>! If we are to retain the fact that CAM loops over grid-points in the internal<a name='3426'></font>
<font color=#447700>! loop then we need to dimension sp,atp,mp,xsh2o with ncol.<a name='3427'></font>
<a name='3428'>
<a name='3429'>
real(r8) tmix(pcols,pver)        <font color=#447700>! Tempertaure of the entraining parcel.<a name='3430'></font>
real(r8) qtmix(pcols,pver)       <font color=#447700>! Total water of the entraining parcel.<a name='3431'></font>
real(r8) qsmix(pcols,pver)       <font color=#447700>! Saturated mixing ratio at the tmix.<a name='3432'></font>
real(r8) smix(pcols,pver)        <font color=#447700>! Entropy of the entraining parcel.<a name='3433'></font>
real(r8) xsh2o(pcols,pver)       <font color=#447700>! Precipitate lost from parcel.<a name='3434'></font>
real(r8) ds_xsh2o(pcols,pver)    <font color=#447700>! Entropy change due to loss of condensate.<a name='3435'></font>
real(r8) ds_freeze(pcols,pver)   <font color=#447700>! Entropy change sue to freezing of precip.<a name='3436'></font>
<a name='3437'>
real(r8) mp(pcols)    <font color=#447700>! Parcel mass flux.<a name='3438'></font>
real(r8) qtp(pcols)   <font color=#447700>! Parcel total water.<a name='3439'></font>
real(r8) sp(pcols)    <font color=#447700>! Parcel entropy.<a name='3440'></font>
<a name='3441'>
real(r8) sp0(pcols)    <font color=#447700>! Parcel launch entropy.<a name='3442'></font>
real(r8) qtp0(pcols)   <font color=#447700>! Parcel launch total water.<a name='3443'></font>
real(r8) mp0(pcols)    <font color=#447700>! Parcel launch relative mass flux.<a name='3444'></font>
<a name='3445'>
real(r8) lwmax      <font color=#447700>! Maximum condesate that can be held in cloud before rainout.<a name='3446'></font>
real(r8) dmpdp      <font color=#447700>! Parcel fractional mass entrainment rate (/mb).<a name='3447'></font>
<font color=#447700>!real(r8) dmpdpc     ! In cloud parcel mass entrainment rate (/mb).<a name='3448'></font>
real(r8) dmpdz      <font color=#447700>! Parcel fractional mass entrainment rate (/m)<a name='3449'></font>
real(r8) dpdz,dzdp  <font color=#447700>! Hydrstatic relation and inverse of.<a name='3450'></font>
real(r8) senv       <font color=#447700>! Environmental entropy at each grid point.<a name='3451'></font>
real(r8) qtenv      <font color=#447700>! Environmental total water "   "   ".<a name='3452'></font>
real(r8) penv       <font color=#447700>! Environmental total pressure "   "   ".<a name='3453'></font>
real(r8) tenv       <font color=#447700>! Environmental total temperature "   "   ".<a name='3454'></font>
real(r8) new_s      <font color=#447700>! Hold value for entropy after condensation/freezing adjustments.<a name='3455'></font>
real(r8) new_q      <font color=#447700>! Hold value for total water after condensation/freezing adjustments.<a name='3456'></font>
real(r8) dp         <font color=#447700>! Layer thickness (center to center)<a name='3457'></font>
real(r8) tfguess    <font color=#447700>! First guess for entropy inversion - crucial for efficiency!<a name='3458'></font>
real(r8) tscool     <font color=#447700>! Super cooled temperature offset (in degC) (eg -35).<a name='3459'></font>
<a name='3460'>
real(r8) qxsk, qxskp1        <font color=#447700>! LCL excess water (k, k+1)<a name='3461'></font>
real(r8) dsdp, dqtdp, dqxsdp <font color=#447700>! LCL s, qt, p gradients (k, k+1)<a name='3462'></font>
real(r8) slcl,qtlcl,qslcl    <font color=#447700>! LCL s, qt, qs values.<a name='3463'></font>
<a name='3464'>
integer rcall       <font color=#447700>! Number of ientropy call for errors recording<a name='3465'></font>
integer nit_lheat     <font color=#447700>! Number of iterations for condensation/freezing loop.<a name='3466'></font>
integer i,k,ii   <font color=#447700>! Loop counters.<a name='3467'></font>
<a name='3468'>
<font color=#447700>!======================================================================<a name='3469'></font>
<font color=#447700>!    SUMMARY<a name='3470'></font>
<font color=#447700>!<a name='3471'></font>
<font color=#447700>!  9/9/04 - Assumes parcel is initiated from level of maxh (klaunch)<a name='3472'></font>
<font color=#447700>!           and entrains at each level with a specified entrainment rate.<a name='3473'></font>
<font color=#447700>!<a name='3474'></font>
<font color=#447700>! 15/9/04 - Calculates lcl(i) based on k where qsmix is first &lt; qtmix.          <a name='3475'></font>
<font color=#447700>!<a name='3476'></font>
<font color=#447700>!======================================================================<a name='3477'></font>
<font color=#447700>!<a name='3478'></font>
<font color=#447700>! Set some values that may be changed frequently.<a name='3479'></font>
<font color=#447700>!<a name='3480'></font>
<a name='3481'>
nit_lheat = 2 <font color=#447700>! iterations for ds,dq changes from condensation freezing.<a name='3482'></font>
dmpdz=-1.e-3_r8        <font color=#447700>! Entrainment rate. (-ve for /m)<a name='3483'></font>
<font color=#447700>!dmpdpc = 3.e-2_r8   ! In cloud entrainment rate (/mb).<a name='3484'></font>
lwmax = 1.e-3_r8    <font color=#447700>! Need to put formula in for this.<a name='3485'></font>
tscool = 0.0_r8   <font color=#447700>! Temp at which water loading freezes in the cloud.<a name='3486'></font>
<a name='3487'>
qtmix=0._r8<a name='3488'>
smix=0._r8<a name='3489'>
<a name='3490'>
qtenv = 0._r8<a name='3491'>
senv = 0._r8<a name='3492'>
tenv = 0._r8<a name='3493'>
penv = 0._r8<a name='3494'>
<a name='3495'>
qtp0 = 0._r8<a name='3496'>
sp0  = 0._r8<a name='3497'>
mp0 = 0._r8<a name='3498'>
<a name='3499'>
qtp = 0._r8<a name='3500'>
sp = 0._r8<a name='3501'>
mp = 0._r8<a name='3502'>
<a name='3503'>
new_q = 0._r8<a name='3504'>
new_s = 0._r8<a name='3505'>
<a name='3506'>
<font color=#447700>! **** Begin loops ****<a name='3507'></font>
<a name='3508'>
do k = pver, msg+1, -1<a name='3509'>
   do i=1,ncol <a name='3510'>
<a name='3511'>
<font color=#447700>! Initialize parcel values at launch level.<a name='3512'></font>
<a name='3513'>
      if (k == klaunch(i)) then <a name='3514'>
         qtp0(i) = q(i,k)   <font color=#447700>! Parcel launch total water (assuming subsaturated) - OK????.<a name='3515'></font>
         sp0(i)  = <A href='../../html_code/phys/module_cu_camzm.F.html#ENTROPY'>entropy</A><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ENTROPY_1">(t(i,k),p(i,k),qtp0(i))  <font color=#447700>! Parcel launch entropy.<a name='3516'></font>
         mp0(i)  = 1._r8       <font color=#447700>! Parcel launch relative mass (i.e. 1 parcel stays 1 parcel for dmpdp=0, undilute). <a name='3517'></font>
         smix(i,k)  = sp0(i)<a name='3518'>
         qtmix(i,k) = qtp0(i)<a name='3519'>
         tfguess = t(i,k)<a name='3520'>
         rcall = 1<a name='3521'>
         call <A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY'>ientropy</A><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="IENTROPY_1"> (rcall,i,lchnk,smix(i,k),p(i,k),qtmix(i,k),tmix(i,k),qsmix(i,k),tfguess)<a name='3522'>
      end if<a name='3523'>
<a name='3524'>
<font color=#447700>! Entraining levels<a name='3525'></font>
      <a name='3526'>
      if (k &lt; klaunch(i)) then <a name='3527'>
<a name='3528'>
<font color=#447700>! Set environmental values for this level.                 <a name='3529'></font>
         <a name='3530'>
         dp = (p(i,k)-p(i,k+1)) <font color=#447700>! In -ve mb as p decreasing with height - difference between center of layers.<a name='3531'></font>
         qtenv = 0.5_r8*(q(i,k)+q(i,k+1))         <font color=#447700>! Total water of environment.<a name='3532'></font>
         tenv  = 0.5_r8*(t(i,k)+t(i,k+1)) <a name='3533'>
         penv  = 0.5_r8*(p(i,k)+p(i,k+1))<a name='3534'>
<a name='3535'>
         senv  = <A href='../../html_code/phys/module_cu_camzm.F.html#ENTROPY'>entropy</A><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ENTROPY_2">(tenv,penv,qtenv)  <font color=#447700>! Entropy of environment.   <a name='3536'></font>
<a name='3537'>
<font color=#447700>! Determine fractional entrainment rate /pa given value /m.<a name='3538'></font>
<a name='3539'>
         dpdz = -(penv*grav)/(rgas*tenv) <font color=#447700>! in mb/m since  p in mb.<a name='3540'></font>
         dzdp = 1._r8/dpdz                  <font color=#447700>! in m/mb<a name='3541'></font>
         dmpdp = dmpdz*dzdp              <font color=#447700>! /mb Fractional entrainment<a name='3542'></font>
<a name='3543'>
<font color=#447700>! Sum entrainment to current level<a name='3544'></font>
<font color=#447700>! entrains q,s out of intervening dp layers, in which linear variation is assumed<a name='3545'></font>
<font color=#447700>! so really it entrains the mean of the 2 stored values.<a name='3546'></font>
<a name='3547'>
         sp(i)  = sp(i)  - dmpdp*dp*senv <a name='3548'>
         qtp(i) = qtp(i) - dmpdp*dp*qtenv <a name='3549'>
         mp(i)  = mp(i)  - dmpdp*dp<a name='3550'>
            <a name='3551'>
<font color=#447700>! Entrain s and qt to next level.<a name='3552'></font>
<a name='3553'>
         smix(i,k)  = (sp0(i)  +  sp(i)) / (mp0(i) + mp(i))<a name='3554'>
         qtmix(i,k) = (qtp0(i) + qtp(i)) / (mp0(i) + mp(i))<a name='3555'>
<a name='3556'>
<font color=#447700>! Invert entropy from s and q to determine T and saturation-capped q of mixture.<a name='3557'></font>
<font color=#447700>! t(i,k) used as a first guess so that it converges faster.<a name='3558'></font>
<a name='3559'>
         tfguess = tmix(i,k+1)<a name='3560'>
         rcall = 2<a name='3561'>
         call <A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY'>ientropy</A><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="IENTROPY_2">(rcall,i,lchnk,smix(i,k),p(i,k),qtmix(i,k),tmix(i,k),qsmix(i,k),tfguess)   <a name='3562'>
<a name='3563'>
<font color=#447700>!<a name='3564'></font>
<font color=#447700>! Determine if this is lcl of this column if qsmix &lt;= qtmix.<a name='3565'></font>
<font color=#447700>! FIRST LEVEL where this happens on ascending.<a name='3566'></font>
<a name='3567'>
         if (qsmix(i,k) &lt;= qtmix(i,k) .and. qsmix(i,k+1) &gt; qtmix(i,k+1)) then<a name='3568'>
            lcl(i) = k<a name='3569'>
            qxsk   = qtmix(i,k) - qsmix(i,k)<a name='3570'>
            qxskp1 = qtmix(i,k+1) - qsmix(i,k+1)<a name='3571'>
            dqxsdp = (qxsk - qxskp1)/dp<a name='3572'>
            pl(i)  = p(i,k+1) - qxskp1/dqxsdp    <font color=#447700>! pressure level of actual lcl.<a name='3573'></font>
            dsdp   = (smix(i,k)  - smix(i,k+1))/dp<a name='3574'>
            dqtdp  = (qtmix(i,k) - qtmix(i,k+1))/dp<a name='3575'>
            slcl   = smix(i,k+1)  +  dsdp* (pl(i)-p(i,k+1))  <a name='3576'>
            qtlcl  = qtmix(i,k+1) +  dqtdp*(pl(i)-p(i,k+1))<a name='3577'>
<a name='3578'>
            tfguess = tmix(i,k)<a name='3579'>
            rcall = 3<a name='3580'>
            call <A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY'>ientropy</A><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="IENTROPY_3"> (rcall,i,lchnk,slcl,pl(i),qtlcl,tl(i),qslcl,tfguess)<a name='3581'>
<a name='3582'>
<font color=#447700>!            write(iulog,*)' '<a name='3583'></font>
<font color=#447700>!            write(iulog,*)' p',p(i,k+1),pl(i),p(i,lcl(i))<a name='3584'></font>
<font color=#447700>!            write(iulog,*)' t',tmix(i,k+1),tl(i),tmix(i,lcl(i))<a name='3585'></font>
<font color=#447700>!            write(iulog,*)' s',smix(i,k+1),slcl,smix(i,lcl(i))<a name='3586'></font>
<font color=#447700>!            write(iulog,*)'qt',qtmix(i,k+1),qtlcl,qtmix(i,lcl(i))<a name='3587'></font>
<font color=#447700>!            write(iulog,*)'qs',qsmix(i,k+1),qslcl,qsmix(i,lcl(i))<a name='3588'></font>
<a name='3589'>
         endif<a name='3590'>
<font color=#447700>!         <a name='3591'></font>
      end if <font color=#447700>!  k &lt; klaunch<a name='3592'></font>
<a name='3593'>
 <a name='3594'>
   end do <font color=#447700>! Levels loop<a name='3595'></font>
end do <font color=#447700>! Columns loop<a name='3596'></font>
<a name='3597'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!!END ENTRAINMENT LOOP!!!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='3598'></font>
<a name='3599'>
<font color=#447700>!! Could stop now and test with this as it will provide some estimate of buoyancy<a name='3600'></font>
<font color=#447700>!! without the effects of freezing/condensation taken into account for tmix.<a name='3601'></font>
<a name='3602'>
<font color=#447700>!! So we now have a profile of entropy and total water of the entraining parcel<a name='3603'></font>
<font color=#447700>!! Varying with height from the launch level klaunch parcel=environment. To the <a name='3604'></font>
<font color=#447700>!! top allowed level for the existence of convection.<a name='3605'></font>
<a name='3606'>
<font color=#447700>!! Now we have to adjust these values such that the water held in vaopor is &lt; or <a name='3607'></font>
<font color=#447700>!! = to qsmix. Therefore, we assume that the cloud holds a certain amount of<a name='3608'></font>
<font color=#447700>!! condensate (lwmax) and the rest is rained out (xsh2o). This, obviously <a name='3609'></font>
<font color=#447700>!! provides latent heating to the mixed parcel and so this has to be added back <a name='3610'></font>
<font color=#447700>!! to it. But does this also increase qsmix as well? Also freezing processes<a name='3611'></font>
 <a name='3612'>
<a name='3613'>
xsh2o = 0._r8<a name='3614'>
ds_xsh2o = 0._r8<a name='3615'>
ds_freeze = 0._r8<a name='3616'>
<a name='3617'>
<font color=#447700>!!!!!!!!!!!!!!!!!!!!!!!!!PRECIPITATION/FREEZING LOOP!!!!!!!!!!!!!!!!!!!!!!!!!!<a name='3618'></font>
<font color=#447700>!! Iterate solution twice for accuracy<a name='3619'></font>
<a name='3620'>
<a name='3621'>
<a name='3622'>
do k = pver, msg+1, -1<a name='3623'>
   do i=1,ncol    <a name='3624'>
      <a name='3625'>
<font color=#447700>! Initialize variables at k=klaunch<a name='3626'></font>
      <a name='3627'>
      if (k == klaunch(i)) then<a name='3628'>
<a name='3629'>
<font color=#447700>! Set parcel values at launch level assume no liquid water.            <a name='3630'></font>
<a name='3631'>
         tp(i,k)    = tmix(i,k)<a name='3632'>
         qstp(i,k)  = q(i,k) <a name='3633'>
         tpv(i,k)   =  (tp(i,k) + tpert(i)) * (1._r8+1.608_r8*qstp(i,k)) / (1._r8+qstp(i,k))<a name='3634'>
         <a name='3635'>
      end if<a name='3636'>
<a name='3637'>
      if (k &lt; klaunch(i)) then<a name='3638'>
            <a name='3639'>
<font color=#447700>! Initiaite loop if switch(2) = .T. - RBN:DILUTE - TAKEN OUT BUT COULD BE RETURNED LATER.<a name='3640'></font>
<a name='3641'>
<font color=#447700>! Iterate nit_lheat times for s,qt changes.<a name='3642'></font>
<a name='3643'>
         do ii=0,nit_lheat-1            <a name='3644'>
<a name='3645'>
<font color=#447700>! Rain (xsh2o) is excess condensate, bar LWMAX (Accumulated loss from qtmix).<a name='3646'></font>
<a name='3647'>
            xsh2o(i,k) = max (0._r8, qtmix(i,k) - qsmix(i,k) - lwmax)<a name='3648'>
<a name='3649'>
<font color=#447700>! Contribution to ds from precip loss of condensate (Accumulated change from smix).(-ve)                     <a name='3650'></font>
                     <a name='3651'>
            ds_xsh2o(i,k) = ds_xsh2o(i,k+1) - cpliq * log (tmix(i,k)/tfreez) * max(0._r8,(xsh2o(i,k)-xsh2o(i,k+1)))<a name='3652'>
<font color=#447700>!<a name='3653'></font>
<font color=#447700>! Entropy of freezing: latice times amount of water involved divided by T.<a name='3654'></font>
<font color=#447700>!<a name='3655'></font>
 <a name='3656'>
            if (tmix(i,k) &lt;= tfreez+tscool .and. ds_freeze(i,k+1) == 0._r8) then <font color=#447700>! One off freezing of condensate. <a name='3657'></font>
               ds_freeze(i,k) = (latice/tmix(i,k)) * max(0._r8,qtmix(i,k)-qsmix(i,k)-xsh2o(i,k)) <font color=#447700>! Gain of LH<a name='3658'></font>
            end if<a name='3659'>
            <a name='3660'>
            if (tmix(i,k) &lt;= tfreez+tscool .and. ds_freeze(i,k+1) /= 0._r8) then <font color=#447700>! Continual freezing of additional condensate.<a name='3661'></font>
               ds_freeze(i,k) = ds_freeze(i,k+1)+(latice/tmix(i,k)) * max(0._r8,(qsmix(i,k+1)-qsmix(i,k)))<a name='3662'>
            end if<a name='3663'>
            <a name='3664'>
<font color=#447700>! Adjust entropy and accordingly to sum of ds (be careful of signs).<a name='3665'></font>
<a name='3666'>
            new_s = smix(i,k) + ds_xsh2o(i,k) + ds_freeze(i,k) <a name='3667'>
<a name='3668'>
<font color=#447700>! Adjust liquid water and accordingly to xsh2o.<a name='3669'></font>
<a name='3670'>
            new_q = qtmix(i,k) - xsh2o(i,k)<a name='3671'>
<a name='3672'>
<font color=#447700>! Invert entropy to get updated Tmix and qsmix of parcel.<a name='3673'></font>
<a name='3674'>
            tfguess = tmix(i,k)<a name='3675'>
            rcall =4<a name='3676'>
            call <A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY'>ientropy</A><A href='../../html_code/phys/module_cu_camzm.F.html#PARCEL_DILUTE' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="IENTROPY_4"> (rcall,i,lchnk,new_s, p(i,k), new_q, tmix(i,k), qsmix(i,k), tfguess)<a name='3677'>
            <a name='3678'>
         end do  <font color=#447700>! Iteration loop for freezing processes.<a name='3679'></font>
<a name='3680'>
<font color=#447700>! tp  - Parcel temp is temp of mixture.<a name='3681'></font>
<font color=#447700>! tpv - Parcel v. temp should be density temp with new_q total water. <a name='3682'></font>
<a name='3683'>
         tp(i,k)    = tmix(i,k)<a name='3684'>
<a name='3685'>
<font color=#447700>! tpv = tprho in the presence of condensate (i.e. when new_q &gt; qsmix)<a name='3686'></font>
<a name='3687'>
         if (new_q &gt; qsmix(i,k)) then  <font color=#447700>! Super-saturated so condensate present - reduces buoyancy.<a name='3688'></font>
            qstp(i,k) = qsmix(i,k)<a name='3689'>
         else                          <font color=#447700>! Just saturated/sub-saturated - no condensate virtual effects.<a name='3690'></font>
            qstp(i,k) = new_q<a name='3691'>
         end if<a name='3692'>
<a name='3693'>
         tpv(i,k) = (tp(i,k)+tpert(i))* (1._r8+1.608_r8*qstp(i,k)) / (1._r8+ new_q) <a name='3694'>
<a name='3695'>
      end if <font color=#447700>! k &lt; klaunch<a name='3696'></font>
      <a name='3697'>
   end do <font color=#447700>! Loop for columns<a name='3698'></font>
   <a name='3699'>
end do  <font color=#447700>! Loop for vertical levels.<a name='3700'></font>
<a name='3701'>
<a name='3702'>
return<a name='3703'>
end subroutine parcel_dilute<a name='3704'>
<a name='3705'>
<font color=#447700>!-----------------------------------------------------------------------------------------<a name='3706'></font>
<A NAME='ENTROPY'><A href='../../html_code/phys/module_cu_camzm.F.html#ENTROPY' TARGET='top_target'><IMG SRC="../../gif/bar_green.gif" border=0></A><a name='3707'>
real(r8) <font color=#993300>function </font><font color=#cc0000>entropy</font>(TK,p,qtot) <A href='../../call_to/ENTROPY.html' TARGET='index'>2</A><a name='3708'>
<font color=#447700>!-----------------------------------------------------------------------------------------<a name='3709'></font>
<font color=#447700>!<a name='3710'></font>
<font color=#447700>! TK(K),p(mb),qtot(kg/kg)<a name='3711'></font>
<font color=#447700>! from Raymond and Blyth 1992<a name='3712'></font>
<font color=#447700>!<a name='3713'></font>
     real(r8), intent(in) :: p,qtot,TK<a name='3714'>
     real(r8) :: qv,qsat,e,esat,L,eref,pref<a name='3715'>
<a name='3716'>
pref = 1000.0_r8           <font color=#447700>! mb<a name='3717'></font>
eref = 6.106_r8            <font color=#447700>! sat p at tfreez (mb)<a name='3718'></font>
<a name='3719'>
L = rl - (cpliq - cpwv)*(TK-tfreez)         <font color=#447700>! T IN CENTIGRADE<a name='3720'></font>
<a name='3721'>
<font color=#447700>! Replace call to satmixutils.<a name='3722'></font>
<a name='3723'>
esat = c1*exp(c2*(TK-tfreez)/(c3+TK-tfreez))       <font color=#447700>! esat(T) in mb<a name='3724'></font>
qsat=eps1*esat/(p-esat)                      <font color=#447700>! Sat. mixing ratio (in kg/kg).<a name='3725'></font>
<a name='3726'>
qv = min(qtot,qsat)                         <font color=#447700>! Partition qtot into vapor part only.<a name='3727'></font>
e = qv*p / (eps1 +qv)<a name='3728'>
<a name='3729'>
entropy = (cpres + qtot*cpliq)*log( TK/tfreez) - rgas*log( (p-e)/pref ) + &amp;<a name='3730'>
        L*qv/TK - qv*rh2o*log(qv/qsat)<a name='3731'>
<font color=#447700>! <a name='3732'></font>
return<a name='3733'>
end FUNCTION entropy<a name='3734'>
<a name='3735'>
<font color=#447700>!<a name='3736'></font>
<font color=#447700>!-----------------------------------------------------------------------------------------<a name='3737'></font>
<A NAME='IENTROPY'><A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3738'>
   <font color=#993300>SUBROUTINE </font><font color=#cc0000>ientropy</font> (rcall,icol,lchnk,s,p,qt,T,qsat,Tfg) <A href='../../call_to/IENTROPY.html' TARGET='index'>4</A>,<A href='../../call_from/IENTROPY.html' TARGET='index'>4</A><a name='3739'>
<font color=#447700>!-----------------------------------------------------------------------------------------<a name='3740'></font>
<font color=#447700>!<a name='3741'></font>
<font color=#447700>! p(mb), Tfg/T(K), qt/qv(kg/kg), s(J/kg). <a name='3742'></font>
<font color=#447700>! Inverts entropy, pressure and total water qt <a name='3743'></font>
<font color=#447700>! for T and saturated vapor mixing ratio<a name='3744'></font>
<font color=#447700>! <a name='3745'></font>
#ifndef WRF_PORT<a name='3746'>
     use phys_grid, only: get_rlon_p, get_rlat_p<a name='3747'>
#endif<a name='3748'>
<a name='3749'>
     integer, intent(in) :: icol, lchnk, rcall<a name='3750'>
     real(r8), intent(in)  :: s, p, Tfg, qt<a name='3751'>
     real(r8), intent(out) :: qsat, T<a name='3752'>
     real(r8) :: qv,Ts,dTs,fs1,fs2,esat     <a name='3753'>
     real(r8) :: pref,eref,L,e<a name='3754'>
     real(r8) :: this_lat,this_lon<a name='3755'>
     integer :: LOOPMAX,i<a name='3756'>
<a name='3757'>
LOOPMAX = 100                   <font color=#447700>!* max number of iteration loops <a name='3758'></font>
<a name='3759'>
<font color=#447700>! Values for entropy<a name='3760'></font>
pref = 1000.0_r8           <font color=#447700>! mb ref pressure.<a name='3761'></font>
eref = 6.106_r8           <font color=#447700>! sat p at tfreez (mb)<a name='3762'></font>
<a name='3763'>
<font color=#447700>! Invert the entropy equation -- use Newton's method<a name='3764'></font>
<a name='3765'>
Ts = Tfg                  <font color=#447700>! Better first guess based on Tprofile from conv.<a name='3766'></font>
<a name='3767'>
converge: do i=0, LOOPMAX<a name='3768'>
<a name='3769'>
   L = rl - (cpliq - cpwv)*(Ts-tfreez) <a name='3770'>
<a name='3771'>
   esat = c1*exp(c2*(Ts-tfreez)/(c3+Ts-tfreez)) <font color=#447700>! Bolton (eq. 10)<a name='3772'></font>
   qsat = eps1*esat/(p-esat)     <a name='3773'>
   qv = min(qt,qsat) <a name='3774'>
   e = qv*p / (eps1 +qv)  <font color=#447700>! Bolton (eq. 16)<a name='3775'></font>
   fs1 = (cpres + qt*cpliq)*log( Ts/tfreez ) - rgas*log( (p-e)/pref ) + &amp;<a name='3776'>
        L*qv/Ts - qv*rh2o*log(qv/qsat) - s<a name='3777'>
   <a name='3778'>
   L = rl - (cpliq - cpwv)*(Ts-1._r8-tfreez)         <a name='3779'>
<a name='3780'>
   esat = c1*exp(c2*(Ts-1._r8-tfreez)/(c3+Ts-1._r8-tfreez))<a name='3781'>
   qsat = eps1*esat/(p-esat)  <a name='3782'>
   qv = min(qt,qsat) <a name='3783'>
   e = qv*p / (eps1 +qv)<a name='3784'>
   fs2 = (cpres + qt*cpliq)*log( (Ts-1._r8)/tfreez ) - rgas*log( (p-e)/pref ) + &amp;<a name='3785'>
        L*qv/(Ts-1._r8) - qv*rh2o*log(qv/qsat) - s <a name='3786'>
   <a name='3787'>
   dTs = fs1/(fs2 - fs1)<a name='3788'>
   Ts  = Ts+dTs<a name='3789'>
   if (abs(dTs).lt.0.001_r8) exit converge<a name='3790'>
   if (i .eq. LOOPMAX - 1) then<a name='3791'>
#ifndef WRF_PORT<a name='3792'>
      this_lat = get_rlat_p(lchnk, icol)*57.296_r8<a name='3793'>
      this_lon = get_rlon_p(lchnk, icol)*57.296_r8<a name='3794'>
#else<a name='3795'>
<font color=#447700>!Do not worry about the specific lat/lon in WRF<a name='3796'></font>
      this_lat = 0.<a name='3797'>
      this_lon = 0.<a name='3798'>
#endif<a name='3799'>
      write(iulog,*) '*** ZM_CONV: IENTROPY: Failed and about to exit, info follows ****'<a name='3800'>
#ifdef WRF_PORT<a name='3801'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_533">(1,iulog)<a name='3802'>
#endif<a name='3803'>
      write(iulog,100) 'ZM_CONV: IENTROPY. Details: call#,lchnk,icol= ',rcall,lchnk,icol, &amp;<a name='3804'>
       ' lat: ',this_lat,' lon: ',this_lon, &amp;<a name='3805'>
       ' P(mb)= ', p, ' Tfg(K)= ', Tfg, ' qt(g/kg) = ', 1000._r8*qt, &amp;<a name='3806'>
       ' qsat(g/kg) = ', 1000._r8*qsat,', s(J/kg) = ',s<a name='3807'>
#ifdef WRF_PORT<a name='3808'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_534">(1,iulog)<a name='3809'>
#endif<a name='3810'>
      write(iulog,*) '*** Please report this crash to Po-Lun.Ma@pnnl.gov ***'<a name='3811'>
#ifdef WRF_PORT<a name='3812'>
      call <A href='../../html_code/frame/wrf_debug.F.html#WRF_DEBUG'>wrf_debug</A><A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_DEBUG_535">(1,iulog)<a name='3813'>
#endif <a name='3814'>
      call <A href='../../html_code/phys/module_sf_clm.F.html#ENDRUN'>endrun</A><A href='../../html_code/phys/module_cu_camzm.F.html#IENTROPY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ENDRUN_27">('**** ZM_CONV IENTROPY: Tmix did not converge ****')<a name='3815'>
   end if<a name='3816'>
enddo converge<a name='3817'>
<a name='3818'>
<font color=#447700>! Replace call to satmixutils.<a name='3819'></font>
<a name='3820'>
esat = c1*exp(c2*(Ts-tfreez)/(c3+Ts-tfreez))<a name='3821'>
qsat=eps1*esat/(p-esat)<a name='3822'>
<a name='3823'>
qv = min(qt,qsat)                             <font color=#447700>!       /* check for saturation */<a name='3824'></font>
T = Ts <a name='3825'>
<a name='3826'>
 100    format (A,I1,I4,I4,7(A,F6.2))<a name='3827'>
<a name='3828'>
return<a name='3829'>
end SUBROUTINE ientropy<a name='3830'>
<a name='3831'>
end module module_cu_camzm<a name='3832'>
</pre></body></html>