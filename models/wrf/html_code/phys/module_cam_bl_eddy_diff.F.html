<HTML> <BODY BGCOLOR=#ddddee LINK=#0000aa VLINK=#0000ff ALINK=#ff0000 ><BASE TARGET="bottom_target"><PRE><a name='1'>
#define WRF_PORT<a name='2'>
#define MODAL_AERO<a name='3'>
<font color=#447700>! Updated to CESM1.0.3 (CAM5.1.01) by Balwinder.Singh@pnnl.gov<a name='4'></font>
<a name='5'>
<A NAME='EDDY_DIFF'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#EDDY_DIFF' TARGET='top_target'><IMG SRC="../../gif/bar_purple.gif" border=0></A><a name='6'>
  <font color=#993300>module </font><font color=#cc0000>eddy_diff</font> <A href='../../call_to/EDDY_DIFF.html' TARGET='index'>2</A>,<A href='../../call_from/EDDY_DIFF.html' TARGET='index'>2</A><a name='7'>
<a name='8'>
  <font color=#447700>!--------------------------------------------------------------------------------- !<a name='9'></font>
  <font color=#447700>!                                                                                  !<a name='10'></font>
  <font color=#447700>! The University of Washington Moist Turbulence Scheme to compute eddy diffusion   ! <a name='11'></font>
  <font color=#447700>! coefficients associated with dry and moist turbulences in the whole              !<a name='12'></font>
  <font color=#447700>! atmospheric layers.                                                              !<a name='13'></font>
  <font color=#447700>!                                                                                  !<a name='14'></font>
  <font color=#447700>! For detailed description of the code and its performances, see                   !<a name='15'></font>
  <font color=#447700>!                                                                                  !<a name='16'></font>
  <font color=#447700>! 1.'A new moist turbulence parametrization in the Community Atmosphere Model'     !<a name='17'></font>
  <font color=#447700>!    by Christopher S. Bretherton and Sungsu Park. J. Climate. 2009. 22. 3422-3448 !<a name='18'></font>
  <font color=#447700>! 2.'The University of Washington shallow convection and moist turbulence schemes  !<a name='19'></font>
  <font color=#447700>!    and their impact on climate simulations with the Community Atmosphere Model'  !<a name='20'></font>
  <font color=#447700>!    by Sungsu Park and Christopher S. Bretherton. J. Climate. 2009. 22. 3449-3469 !<a name='21'></font>
  <font color=#447700>!                                                                                  !<a name='22'></font>
  <font color=#447700>! For questions on the scheme and code, send an email to                           !<a name='23'></font>
  <font color=#447700>!     Sungsu Park      at sungsup@ucar.edu (tel: 303-497-1375)                     !<a name='24'></font>
  <font color=#447700>!     Chris Bretherton at breth@washington.edu                                     !<a name='25'></font>
  <font color=#447700>!                                                                                  ! <a name='26'></font>
  <font color=#447700>! Developed by Chris Bretherton at the University of Washington, Seattle, WA.      !<a name='27'></font>
  <font color=#447700>!              Sungsu Park      at the CGD/NCAR, Boulder, CO.                      !<a name='28'></font>
  <font color=#447700>! Last coded on May.2006, Dec.2009 by Sungsu Park.                                 !<a name='29'></font>
  <font color=#447700>!                                                                                  !  <a name='30'></font>
  <font color=#447700>!--------------------------------------------------------------------------------- !<a name='31'></font>
<a name='32'>
  use <A href='../../html_code/phys/module_cam_bl_diffusion_solver.F.html#DIFFUSION_SOLVER'>diffusion_solver</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="DIFFUSION_SOLVER_4">, only : vdiff_selector<a name='33'>
#ifndef WRF_PORT <a name='34'>
  use cam_history,      only : outfld, addfld, phys_decomp<a name='35'>
  use cam_logfile,      only : iulog<a name='36'>
  use ppgrid,           only : pver<a name='37'>
#else<a name='38'>
  use <A href='../../html_code/phys/module_cam_support.F.html#MODULE_CAM_SUPPORT'>module_cam_support</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CAM_SUPPORT_5">,   only: iulog, pver,outfld, addfld, phys_decomp  <a name='39'>
#endif<a name='40'>
<a name='41'>
  implicit none<a name='42'>
  private<a name='43'>
  save<a name='44'>
<a name='45'>
  public init_eddy_diff<a name='46'>
  public compute_eddy_diff<a name='47'>
<a name='48'>
  type(vdiff_selector)        :: fieldlist_wet                  <font color=#447700>! Logical switches for moist mixing ratio diffusion<a name='49'></font>
  type(vdiff_selector)        :: fieldlist_dry                  <font color=#447700>! Logical switches for dry   mixing ratio diffusion<a name='50'></font>
  integer,          parameter :: r8 = selected_real_kind(12)    <font color=#447700>! 8 byte real<a name='51'></font>
<a name='52'>
  <font color=#447700>! --------------------------------- !<a name='53'></font>
  <font color=#447700>! PBL Parameters used in the UW PBL !<a name='54'></font>
  <font color=#447700>! --------------------------------- !<a name='55'></font>
<a name='56'>
  character,        parameter :: sftype         = 'l'           <font color=#447700>! Method for calculating saturation fraction<a name='57'></font>
<a name='58'>
  character(len=4), parameter :: choice_evhc    = 'maxi'        <font color=#447700>! 'orig',   'ramp',   'maxi'   : recommended to be used with choice_radf <a name='59'></font>
  character(len=6), parameter :: choice_radf    = 'maxi'        <font color=#447700>! 'orig',   'ramp',   'maxi'   : recommended to be used with choice_evhc <a name='60'></font>
  character(len=6), parameter :: choice_SRCL    = 'nonamb'      <font color=#447700>! 'origin', 'remove', 'nonamb'<a name='61'></font>
 <a name='62'>
  character(len=6), parameter :: choice_tunl    = 'rampcl'      <font color=#447700>! 'origin', 'rampsl'(Sungsu), 'rampcl'(Chris)<a name='63'></font>
  real(r8),         parameter :: ctunl          =  2._r8        <font color=#447700>!  Maximum asympt leng = ctunl*tunl when choice_tunl = 'rampsl(cl)' [ no unit ]<a name='64'></font>
  character(len=6), parameter :: choice_leng    = 'origin'      <font color=#447700>! 'origin', 'takemn'<a name='65'></font>
  real(r8),         parameter :: cleng          =  3._r8        <font color=#447700>!  Order of 'leng' when choice_leng = 'origin' [ no unit ]<a name='66'></font>
  character(len=6), parameter :: choice_tkes    = 'ibprod'      <font color=#447700>! 'ibprod' (include tkes in computing bprod), 'ebprod'(exclude)<a name='67'></font>
<a name='68'>
  <font color=#447700>! Parameters for 'sedimenttaion-entrainment feedback' for liquid stratus <a name='69'></font>
  <font color=#447700>! If .false.,  no sedimentation entrainment feedback ( i.e., use default evhc )<a name='70'></font>
<a name='71'>
  logical,          parameter :: id_sedfact     = .false.<a name='72'>
  real(r8),         parameter :: ased           =  9._r8        <font color=#447700>!  Valid only when id_sedfact = .true.<a name='73'></font>
<a name='74'>
  <font color=#447700>! --------------------------------------------------------------------------------------------------- !<a name='75'></font>
  <font color=#447700>! Parameters governing entrainment efficiency A = a1l(i)*evhc, evhc = 1 + a2l * a3l * L * ql / jt2slv !<a name='76'></font>
  <font color=#447700>! Here, 'ql' is cloud-top LWC and 'jt2slv' is the jump in 'slv' across                                !<a name='77'></font>
  <font color=#447700>! the cloud-top entrainment zone ( across two grid layers to consider full mixture )                  !<a name='78'></font>
  <font color=#447700>! --------------------------------------------------------------------------------------------------- !<a name='79'></font>
<a name='80'>
  real(r8),         parameter :: a1l            =   0.10_r8     <font color=#447700>! Dry entrainment efficiency for TKE closure<a name='81'></font>
                                                                <font color=#447700>! a1l = 0.2*tunl*erat^-1.5, where erat = &lt;e&gt;/wstar^2 for dry CBL =  0.3.<a name='82'></font>
<a name='83'>
  real(r8),         parameter :: a1i            =   0.2_r8      <font color=#447700>! Dry entrainment efficiency for wstar closure<a name='84'></font>
  real(r8),         parameter :: ccrit          =   0.5_r8      <font color=#447700>! Minimum allowable sqrt(tke)/wstar. Used in solving cubic equation for 'ebrk'<a name='85'></font>
  real(r8),         parameter :: wstar3factcrit =   0.5_r8      <font color=#447700>! 1/wstar3factcrit is the maximally allowed enhancement of 'wstar3' due to entrainment.<a name='86'></font>
<a name='87'>
  real(r8),         parameter :: a2l            =   30._r8      <font color=#447700>! Moist entrainment enhancement param (recommended range : 10~30 )<a name='88'></font>
  real(r8),         parameter :: a3l            =   0.8_r8      <font color=#447700>! Approximation to a complicated thermodynamic parameters<a name='89'></font>
<a name='90'>
  real(r8),         parameter :: jbumin         =   .001_r8     <font color=#447700>! Minimum buoyancy jump at an entrainment jump, [m/s2]<a name='91'></font>
  real(r8),         parameter :: evhcmax        =   10._r8      <font color=#447700>! Upper limit of evaporative enhancement factor<a name='92'></font>
<a name='93'>
  real(r8),         parameter :: ustar_min      =   0.01_r8     <font color=#447700>! Minimum permitted value of ustar [ m/s ] <a name='94'></font>
  real(r8),         parameter :: onet           =   1._r8/3._r8 <font color=#447700>! 1/3 power in wind gradient expression [ no unit ]<a name='95'></font>
#ifndef WRF_PORT<a name='96'>
  <font color=#447700>!pver is not a parameter in cam_support module in WRF, therefore ncvmax cannot be equated to pver as parameter <a name='97'></font>
  integer,          parameter :: ncvmax         =   pver        <font color=#447700>! Max numbers of CLs (good to set to 'pver')<a name='98'></font>
#else<a name='99'>
  integer                     :: ncvmax  <a name='100'>
#endif<a name='101'>
  real(r8),         parameter :: qmin           =   1.e-5_r8    <font color=#447700>! Minimum grid-mean LWC counted as clouds [kg/kg]<a name='102'></font>
  real(r8),         parameter :: ntzero         =   1.e-12_r8   <font color=#447700>! Not zero (small positive number used in 's2')<a name='103'></font>
  real(r8),         parameter :: b1             =   5.8_r8      <font color=#447700>! TKE dissipation D = e^3/(b1*leng), e = b1*W.<a name='104'></font>
  real(r8)                    :: b123                           <font color=#447700>! b1**(2/3)<a name='105'></font>
  real(r8),         parameter :: tunl           =   0.085_r8    <font color=#447700>! Asympt leng = tunl*(turb lay depth)<a name='106'></font>
  real(r8),         parameter :: alph1          =   0.5562_r8   <font color=#447700>! alph1~alph5 : Galperin instability function parameters<a name='107'></font>
  real(r8),         parameter :: alph2          =  -4.3640_r8   <font color=#447700>!               These coefficients are used to calculate <a name='108'></font>
  real(r8),         parameter :: alph3          = -34.6764_r8   <font color=#447700>!               'sh' and 'sm' from 'gh'.<a name='109'></font>
  real(r8),         parameter :: alph4          =  -6.1272_r8   <font color=#447700>!<a name='110'></font>
  real(r8),         parameter :: alph5          =   0.6986_r8   <font color=#447700>!<a name='111'></font>
  real(r8),         parameter :: ricrit         =   0.19_r8     <font color=#447700>! Critical Richardson number for turbulence. Can be any value &gt;= 0.19.<a name='112'></font>
  real(r8),         parameter :: ae             =   1._r8       <font color=#447700>! TKE transport efficiency [no unit]<a name='113'></font>
  real(r8),         parameter :: rinc           =  -0.04_r8     <font color=#447700>! Minimum W/&lt;W&gt; used for CL merging test <a name='114'></font>
  real(r8),         parameter :: wpertmin       =   1.e-6_r8    <font color=#447700>! Minimum PBL eddy vertical velocity perturbation<a name='115'></font>
  real(r8),         parameter :: wfac           =   1._r8       <font color=#447700>! Ratio of 'wpert' to sqrt(tke) for CL.<a name='116'></font>
  real(r8),         parameter :: tfac           =   1._r8       <font color=#447700>! Ratio of 'tpert' to (w't')/wpert for CL. Same ratio also used for q<a name='117'></font>
  real(r8),         parameter :: fak            =   8.5_r8      <font color=#447700>! Constant in surface temperature excess for stable STL. [ no unit ]         <a name='118'></font>
  real(r8),         parameter :: rcapmin        =   0.1_r8      <font color=#447700>! Minimum allowable e/&lt;e&gt; in a CL<a name='119'></font>
  real(r8),         parameter :: rcapmax        =   2.0_r8      <font color=#447700>! Maximum allowable e/&lt;e&gt; in a CL<a name='120'></font>
  real(r8),         parameter :: tkemax         =  20._r8       <font color=#447700>! TKE is capped at tkemax [m2/s2]<a name='121'></font>
  real(r8),         parameter :: lambda         =   0.5_r8      <font color=#447700>! Under-relaxation factor ( 0 &lt; lambda =&lt; 1 )<a name='122'></font>
<a name='123'>
  logical,          parameter :: use_kvf        =  .false.      <font color=#447700>! .true. (.false.) : initialize kvh/kvm =  kvf ( 0. )<a name='124'></font>
  logical,          parameter :: use_dw_surf    =  .true.       <font color=#447700>! Used in 'zisocl'. Default is 'true'<a name='125'></font>
                                                                <font color=#447700>! If 'true', surface interfacial energy does not contribute to the CL mean<a name='126'></font>
                                                                <font color=#447700>!            stbility functions after finishing merging.     For this case,<a name='127'></font>
                                                                <font color=#447700>!           'dl2n2_surf' is only used for a merging test based on 'l2n2'<a name='128'></font>
                                                                <font color=#447700>! If 'false',surface interfacial enery explicitly contribute to    CL mean<a name='129'></font>
                                                                <font color=#447700>!            stability functions after finishing merging.    For this case,<a name='130'></font>
                                                                <font color=#447700>!           'dl2n2_surf' and 'dl2s2_surf' are directly used for calculating<a name='131'></font>
                                                                <font color=#447700>!            surface interfacial layer energetics<a name='132'></font>
<a name='133'>
  logical,          parameter :: set_qrlzero    =  .false.      <font color=#447700>! .true. ( .false.) : turning-off ( on) radiative-turbulence interaction by setting qrl = 0.<a name='134'></font>
<a name='135'>
  <font color=#447700>! ------------------------------------- !<a name='136'></font>
  <font color=#447700>! PBL Parameters not used in the UW PBL !<a name='137'></font>
  <font color=#447700>! ------------------------------------- !<a name='138'></font>
<a name='139'>
  real(r8),         parameter :: pblmaxp        =  4.e4_r8      <font color=#447700>! PBL max depth in pressure units. <a name='140'></font>
  real(r8),         parameter :: zkmin          =  0.01_r8      <font color=#447700>! Minimum kneutral*f(ri). <a name='141'></font>
  real(r8),         parameter :: betam          = 15.0_r8       <font color=#447700>! Constant in wind gradient expression.<a name='142'></font>
  real(r8),         parameter :: betas          =  5.0_r8       <font color=#447700>! Constant in surface layer gradient expression.<a name='143'></font>
  real(r8),         parameter :: betah          = 15.0_r8       <font color=#447700>! Constant in temperature gradient expression.<a name='144'></font>
  real(r8),         parameter :: fakn           =  7.2_r8       <font color=#447700>! Constant in turbulent prandtl number.<a name='145'></font>
  real(r8),         parameter :: ricr           =  0.3_r8       <font color=#447700>! Critical richardson number.<a name='146'></font>
  real(r8),         parameter :: sffrac         =  0.1_r8       <font color=#447700>! Surface layer fraction of boundary layer<a name='147'></font>
  real(r8),         parameter :: binm           =  betam*sffrac <font color=#447700>! betam * sffrac<a name='148'></font>
  real(r8),         parameter :: binh           =  betah*sffrac <font color=#447700>! betah * sffrac<a name='149'></font>
<a name='150'>
  <font color=#447700>! ------------------------------------------------------- !<a name='151'></font>
  <font color=#447700>! PBL constants set using values from other parts of code !<a name='152'></font>
  <font color=#447700>! ------------------------------------------------------- !<a name='153'></font>
<a name='154'>
  real(r8)                    :: cpair                          <font color=#447700>! Specific heat of dry air<a name='155'></font>
  real(r8)                    :: rair                           <font color=#447700>! Gas const for dry air<a name='156'></font>
  real(r8)                    :: zvir                           <font color=#447700>! rh2o/rair - 1<a name='157'></font>
  real(r8)                    :: latvap                         <font color=#447700>! Latent heat of vaporization<a name='158'></font>
  real(r8)                    :: latice                         <font color=#447700>! Latent heat of fusion<a name='159'></font>
  real(r8)                    :: latsub                         <font color=#447700>! Latent heat of sublimation<a name='160'></font>
  real(r8)                    :: g                              <font color=#447700>! Gravitational acceleration<a name='161'></font>
  real(r8)                    :: vk                             <font color=#447700>! Von Karman's constant<a name='162'></font>
  real(r8)                    :: ccon                           <font color=#447700>! fak * sffrac * vk<a name='163'></font>
<a name='164'>
  integer                     :: ntop_turb                      <font color=#447700>! Top interface level to which turbulent vertical diffusion is applied ( = 1 )<a name='165'></font>
  integer                     :: nbot_turb                      <font color=#447700>! Bottom interface level to which turbulent vertical diff is applied ( = pver )<a name='166'></font>
<a name='167'>
  real(r8), allocatable       :: ml2(:)                         <font color=#447700>! Mixing lengths squared. Not used in the UW PBL. Used for computing free air diffusivity.<a name='168'></font>
<a name='169'>
  CONTAINS<a name='170'>
<a name='171'>
  <font color=#447700>!============================================================================ !<a name='172'></font>
  <font color=#447700>!                                                                             !<a name='173'></font>
  <font color=#447700>!============================================================================ !<a name='174'></font>
  <a name='175'>
<A NAME='INIT_EDDY_DIFF'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='176'>
  <font color=#993300>subroutine </font><font color=#cc0000>init_eddy_diff</font>( kind, pver, gravx, cpairx, rairx, zvirx, &amp;  <A href='../../call_to/INIT_EDDY_DIFF.html' TARGET='index'>1</A>,<A href='../../call_from/INIT_EDDY_DIFF.html' TARGET='index'>72</A><a name='177'>
                             latvapx, laticex, ntop_eddy, nbot_eddy, hypm, vkx )<a name='178'>
    <font color=#447700>!---------------------------------------------------------------- ! <a name='179'></font>
    <font color=#447700>! Purpose:                                                        !<a name='180'></font>
    <font color=#447700>! Initialize time independent constants/variables of PBL package. !<a name='181'></font>
    <font color=#447700>!---------------------------------------------------------------- !<a name='182'></font>
    use <A href='../../html_code/phys/module_cam_bl_diffusion_solver.F.html#DIFFUSION_SOLVER'>diffusion_solver</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="DIFFUSION_SOLVER_5">, only: init_vdiff, vdiff_select<a name='183'>
#ifndef WRF_PORT <a name='184'>
    use cam_history,      only: outfld, addfld, phys_decomp<a name='185'>
#else<a name='186'>
    use <A href='../../html_code/phys/module_cam_support.F.html#MODULE_CAM_SUPPORT'>module_cam_support</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CAM_SUPPORT_6">,   only: outfld, addfld, phys_decomp  <a name='187'>
#endif<a name='188'>
    implicit none<a name='189'>
    <font color=#447700>! --------- !<a name='190'></font>
    <font color=#447700>! Arguments !<a name='191'></font>
    <font color=#447700>! --------- !<a name='192'></font>
    integer,  intent(in) :: kind       <font color=#447700>! Kind of reals being passed in<a name='193'></font>
    integer,  intent(in) :: pver       <font color=#447700>! Number of vertical layers<a name='194'></font>
    integer,  intent(in) :: ntop_eddy  <font color=#447700>! Top interface level to which eddy vertical diffusivity is applied ( = 1 )<a name='195'></font>
    integer,  intent(in) :: nbot_eddy  <font color=#447700>! Bottom interface level to which eddy vertical diffusivity is applied ( = pver )<a name='196'></font>
    real(r8), intent(in) :: gravx      <font color=#447700>! Acceleration of gravity<a name='197'></font>
    real(r8), intent(in) :: cpairx     <font color=#447700>! Specific heat of dry air<a name='198'></font>
    real(r8), intent(in) :: rairx      <font color=#447700>! Gas constant for dry air<a name='199'></font>
    real(r8), intent(in) :: zvirx      <font color=#447700>! rh2o/rair - 1<a name='200'></font>
    real(r8), intent(in) :: latvapx    <font color=#447700>! Latent heat of vaporization<a name='201'></font>
    real(r8), intent(in) :: laticex    <font color=#447700>! Latent heat of fusion<a name='202'></font>
    real(r8), intent(in) :: hypm(pver) <font color=#447700>! Reference pressures at midpoints<a name='203'></font>
    real(r8), intent(in) :: vkx        <font color=#447700>! Von Karman's constant<a name='204'></font>
<a name='205'>
    character(128)       :: errstring  <font color=#447700>! Error status for init_vdiff<a name='206'></font>
    integer              :: k          <font color=#447700>! Vertical loop index<a name='207'></font>
#ifdef WRF_PORT    <a name='208'>
    <font color=#447700>!As pver is not parameter in the cam_support module in WRF, a value to ncvmax is given here<a name='209'></font>
    ncvmax = pver        <font color=#447700>! Max numbers of CLs (good to set to 'pver') <a name='210'></font>
#endif<a name='211'>
    if( kind .ne. r8 ) then<a name='212'>
        write(iulog,*) 'wrong KIND of reals passed to init_diffusvity -- exiting.'<a name='213'>
#ifdef WRF_PORT<a name='214'>
        call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_538">(iulog)<a name='215'>
#endif <a name='216'>
        stop 'init_eddy_diff'<a name='217'>
    endif<a name='218'>
<a name='219'>
    <font color=#447700>! --------------- !<a name='220'></font>
    <font color=#447700>! Basic constants !<a name='221'></font>
    <font color=#447700>! --------------- !<a name='222'></font>
<a name='223'>
    cpair     = cpairx<a name='224'>
    rair      = rairx<a name='225'>
    g         = gravx<a name='226'>
    zvir      = zvirx<a name='227'>
    latvap    = latvapx<a name='228'>
    latice    = laticex<a name='229'>
    latsub    = latvap + latice<a name='230'>
    vk        = vkx<a name='231'>
    ccon      = fak*sffrac*vk<a name='232'>
    ntop_turb = ntop_eddy<a name='233'>
    nbot_turb = nbot_eddy<a name='234'>
    b123      = b1**(2._r8/3._r8)<a name='235'>
<a name='236'>
    <font color=#447700>! Set the square of the mixing lengths. Only for CAM3 HB PBL scheme.<a name='237'></font>
    <font color=#447700>! Not used for UW moist PBL. Used for free air eddy diffusivity.<a name='238'></font>
#ifndef WRF_PORT <a name='239'>
    <font color=#447700>! ml2 is never used currently as use_kvf is set to false<a name='240'></font>
    allocate(ml2(pver+1))<a name='241'>
    ml2(1:ntop_turb) = 0._r8<a name='242'>
    do k = ntop_turb + 1, nbot_turb<a name='243'>
       ml2(k) = 30.0_r8**2<a name='244'>
    end do<a name='245'>
    ml2(nbot_turb+1:pver+1) = 0._r8<a name='246'>
#endif<a name='247'>
    <a name='248'>
    <font color=#447700>! Initialize diffusion solver module<a name='249'></font>
<a name='250'>
    call <A href='../../html_code/phys/module_cam_bl_diffusion_solver.F.html#INIT_VDIFF'>init_vdiff</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="INIT_VDIFF_2">(r8, 1, rair, g, fieldlist_wet, fieldlist_dry, errstring)<a name='251'>
<a name='252'>
    <font color=#447700>! Select the fields which will be diffused <a name='253'></font>
<a name='254'>
    if(vdiff_select(fieldlist_wet,'s').ne.'')   write(iulog,*) 'error: ', vdiff_select(fieldlist_wet,'s')<a name='255'>
#ifdef WRF_PORT<a name='256'>
        call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_539">(iulog)<a name='257'>
#endif <a name='258'>
    if(vdiff_select(fieldlist_wet,'q',1).ne.'') write(iulog,*) 'error: ', vdiff_select(fieldlist_wet,'q',1)<a name='259'>
#ifdef WRF_PORT<a name='260'>
        call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_540">(iulog)<a name='261'>
#endif <a name='262'>
    if(vdiff_select(fieldlist_wet,'u').ne.'')   write(iulog,*) 'error: ', vdiff_select(fieldlist_wet,'u')<a name='263'>
#ifdef WRF_PORT<a name='264'>
        call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_541">(iulog)<a name='265'>
#endif <a name='266'>
    if(vdiff_select(fieldlist_wet,'v').ne.'')   write(iulog,*) 'error: ', vdiff_select(fieldlist_wet,'v')<a name='267'>
#ifdef WRF_PORT<a name='268'>
        call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_542">(iulog)<a name='269'>
#endif <a name='270'>
<a name='271'>
    <font color=#447700>! ------------------------------------------------------------------- !<a name='272'></font>
    <font color=#447700>! Writing outputs for detailed analysis of UW moist turbulence scheme !<a name='273'></font>
    <font color=#447700>! ------------------------------------------------------------------- !<a name='274'></font>
<a name='275'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_1">('UW_errorPBL',      'm2/s',    1,      'A',  'Error function of UW PBL',                              phys_decomp )<a name='276'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_2">('UW_n2',            's-2',     pver,   'A',  'Buoyancy Frequency, LI',                                phys_decomp )<a name='277'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_3">('UW_s2',            's-2',     pver,   'A',  'Shear Frequency, LI',                                   phys_decomp )<a name='278'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_4">('UW_ri',            'no',      pver,   'A',  'Interface Richardson Number, I',                        phys_decomp )<a name='279'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_5">('UW_sfuh',          'no',      pver,   'A',  'Upper-Half Saturation Fraction, L',                     phys_decomp )<a name='280'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_6">('UW_sflh',          'no',      pver,   'A',  'Lower-Half Saturation Fraction, L',                     phys_decomp )<a name='281'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_7">('UW_sfi',           'no',      pver+1, 'A',  'Interface Saturation Fraction, I',                      phys_decomp )<a name='282'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_8">('UW_cldn',          'no',      pver,   'A',  'Cloud Fraction, L',                                     phys_decomp )<a name='283'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_9">('UW_qrl',           'g*W/m2',  pver,   'A',  'LW cooling rate, L',                                    phys_decomp )<a name='284'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_10">('UW_ql',            'kg/kg',   pver,   'A',  'ql(LWC), L',                                            phys_decomp )<a name='285'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_11">('UW_chu',           'g*kg/J',  pver+1, 'A',  'Buoyancy Coefficient, chu, I',                          phys_decomp )<a name='286'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_12">('UW_chs',           'g*kg/J',  pver+1, 'A',  'Buoyancy Coefficient, chs, I',                          phys_decomp )<a name='287'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_13">('UW_cmu',           'g/kg/kg', pver+1, 'A',  'Buoyancy Coefficient, cmu, I',                          phys_decomp )<a name='288'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_14">('UW_cms',           'g/kg/kg', pver+1, 'A',  'Buoyancy Coefficient, cms, I',                          phys_decomp )    <a name='289'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_15">('UW_tke',           'm2/s2',   pver+1, 'A',  'TKE, I',                                                phys_decomp )<a name='290'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_16">('UW_wcap',          'm2/s2',   pver+1, 'A',  'Wcap, I',                                               phys_decomp )        <a name='291'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_17">('UW_bprod',         'm2/s3',   pver+1, 'A',  'Buoyancy production, I',                                phys_decomp )<a name='292'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_18">('UW_sprod',         'm2/s3',   pver+1, 'A',  'Shear production, I',                                   phys_decomp )    <a name='293'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_19">('UW_kvh',           'm2/s',    pver+1, 'A',  'Eddy diffusivity of heat, I',                           phys_decomp )<a name='294'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_20">('UW_kvm',           'm2/s',    pver+1, 'A',  'Eddy diffusivity of uv, I',                             phys_decomp )<a name='295'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_21">('UW_pblh',          'm',       1,      'A',  'PBLH, 1',                                               phys_decomp )<a name='296'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_22">('UW_pblhp',         'Pa',      1,      'A',  'PBLH pressure, 1',                                      phys_decomp )<a name='297'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_23">('UW_tpert',         'K',       1,      'A',  'Convective T excess, 1',                                phys_decomp )<a name='298'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_24">('UW_qpert',         'kg/kg',   1,      'A',  'Convective qt excess, I',                               phys_decomp )<a name='299'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_25">('UW_wpert',         'm/s',     1,      'A',  'Convective W excess, I',                                phys_decomp )<a name='300'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_26">('UW_ustar',         'm/s',     1,      'A',  'Surface Frictional Velocity, 1',                        phys_decomp )<a name='301'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_27">('UW_tkes',          'm2/s2',   1,      'A',  'Surface TKE, 1',                                        phys_decomp )<a name='302'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_28">('UW_minpblh',       'm',       1,      'A',  'Minimum PBLH, 1',                                       phys_decomp )<a name='303'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_29">('UW_turbtype',      'no',      pver+1, 'A',  'Interface Turbulence Type, I',                          phys_decomp )    <a name='304'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_30">('UW_kbase_o',       'no',      ncvmax, 'A',  'Initial CL Base Exterbal Interface Index, CL',          phys_decomp )<a name='305'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_31">('UW_ktop_o',        'no',      ncvmax, 'A',  'Initial Top Exterbal Interface Index, CL',              phys_decomp )<a name='306'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_32">('UW_ncvfin_o',      '#',       1,      'A',  'Initial Total Number of CL regimes, CL',                phys_decomp )<a name='307'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_33">('UW_kbase_mg',      'no',      ncvmax, 'A',  'kbase after merging, CL',                               phys_decomp )<a name='308'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_34">('UW_ktop_mg',       'no',      ncvmax, 'A',  'ktop after merging, CL',                                phys_decomp )<a name='309'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_35">('UW_ncvfin_mg',     '#',       1,      'A',  'ncvfin after merging, CL',                              phys_decomp )<a name='310'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_36">('UW_kbase_f',       'no',      ncvmax, 'A',  'Final kbase with SRCL, CL',                             phys_decomp )<a name='311'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_37">('UW_ktop_f',        'no',      ncvmax, 'A',  'Final ktop with SRCL, CL',                              phys_decomp )<a name='312'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_38">('UW_ncvfin_f',      '#',       1,      'A',  'Final ncvfin with SRCL, CL',                            phys_decomp )<a name='313'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_39">('UW_wet',           'm/s',     ncvmax, 'A',  'Entrainment rate at CL top, CL',                        phys_decomp )<a name='314'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_40">('UW_web',           'm/s',     ncvmax, 'A',  'Entrainment rate at CL base, CL',                       phys_decomp )<a name='315'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_41">('UW_jtbu',          'm/s2',    ncvmax, 'A',  'Buoyancy jump across CL top, CL',                       phys_decomp )<a name='316'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_42">('UW_jbbu',          'm/s2',    ncvmax, 'A',  'Buoyancy jump across CL base, CL',                      phys_decomp )<a name='317'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_43">('UW_evhc',          'no',      ncvmax, 'A',  'Evaporative enhancement factor, CL',                    phys_decomp )<a name='318'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_44">('UW_jt2slv',        'J/kg',    ncvmax, 'A',  'slv jump for evhc, CL',                                 phys_decomp )<a name='319'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_45">('UW_n2ht',          's-2',     ncvmax, 'A',  'n2 at just below CL top interface, CL',                 phys_decomp )<a name='320'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_46">('UW_n2hb',          's-2',     ncvmax, 'A',  'n2 at just above CL base interface',                    phys_decomp )<a name='321'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_47">('UW_lwp',           'kg/m2',   ncvmax, 'A',  'LWP in the CL top layer, CL',                           phys_decomp )<a name='322'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_48">('UW_optdepth',      'no',      ncvmax, 'A',  'Optical depth of the CL top layer, CL',                 phys_decomp )<a name='323'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_49">('UW_radfrac',       'no',      ncvmax, 'A',  'Fraction of radiative cooling confined in the CL top',  phys_decomp )<a name='324'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_50">('UW_radf',          'm2/s3',   ncvmax, 'A',  'Buoyancy production at the CL top by radf, I',          phys_decomp )        <a name='325'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_51">('UW_wstar',         'm/s',     ncvmax, 'A',  'Convective velocity, Wstar, CL',                        phys_decomp )<a name='326'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_52">('UW_wstar3fact',    'no',      ncvmax, 'A',  'Enhancement of wstar3 due to entrainment, CL',          phys_decomp )<a name='327'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_53">('UW_ebrk',          'm2/s2',   ncvmax, 'A',  'CL-averaged TKE, CL',                                   phys_decomp )<a name='328'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_54">('UW_wbrk',          'm2/s2',   ncvmax, 'A',  'CL-averaged W, CL',                                     phys_decomp )<a name='329'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_55">('UW_lbrk',          'm',       ncvmax, 'A',  'CL internal thickness, CL',                             phys_decomp )<a name='330'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_56">('UW_ricl',          'no',      ncvmax, 'A',  'CL-averaged Ri, CL',                                    phys_decomp )<a name='331'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_57">('UW_ghcl',          'no',      ncvmax, 'A',  'CL-averaged gh, CL',                                    phys_decomp )<a name='332'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_58">('UW_shcl',          'no',      ncvmax, 'A',  'CL-averaged sh, CL',                                    phys_decomp )<a name='333'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_59">('UW_smcl',          'no',      ncvmax, 'A',  'CL-averaged sm, CL',                                    phys_decomp )<a name='334'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_60">('UW_gh',            'no',      pver+1, 'A',  'gh at all interfaces, I',                               phys_decomp )<a name='335'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_61">('UW_sh',            'no',      pver+1, 'A',  'sh at all interfaces, I',                               phys_decomp )<a name='336'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_62">('UW_sm',            'no',      pver+1, 'A',  'sm at all interfaces, I',                               phys_decomp )<a name='337'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_63">('UW_ria',           'no',      pver+1, 'A',  'ri at all interfaces, I',                               phys_decomp )<a name='338'>
    call <A href='../../html_code/phys/module_cam_support.F.html#ADDFLD'>addfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#INIT_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ADDFLD_64">('UW_leng',          'm/s',     pver+1, 'A',  'Turbulence length scale, I',                            phys_decomp )<a name='339'>
<a name='340'>
  return<a name='341'>
<a name='342'>
  end subroutine init_eddy_diff<a name='343'>
<a name='344'>
  <font color=#447700>!=============================================================================== !<a name='345'></font>
  <font color=#447700>!                                                                                !<a name='346'></font>
  <font color=#447700>!=============================================================================== !<a name='347'></font>
  <a name='348'>
<A NAME='COMPUTE_EDDY_DIFF'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='349'>
  <font color=#993300>subroutine </font><font color=#cc0000>compute_eddy_diff</font>( lchnk  ,                                                            &amp; <A href='../../call_to/COMPUTE_EDDY_DIFF.html' TARGET='index'>1</A>,<A href='../../call_from/COMPUTE_EDDY_DIFF.html' TARGET='index'>73</A><a name='350'>
                                pcols  , pver   , ncol     , t       , qv       , ztodt   ,         &amp;<a name='351'>
                                ql     , qi     , s        , rpdel   , cldn     , qrl     , wsedl , &amp;<a name='352'>
                                z      , zi     , pmid     , pi      , u        , v       ,         &amp;<a name='353'>
                                taux   , tauy   , shflx    , qflx    , wstarent , nturb   ,         &amp;<a name='354'>
                                ustar  , pblh   , kvm_in   , kvh_in  , kvm_out  , kvh_out , kvq   , &amp; <a name='355'>
                                cgh    , cgs    , tpert    , qpert   , wpert    , tke     , bprod , &amp;<a name='356'>
                                sprod  , sfi    , qsat     , kvinit  ,                              &amp;<a name='357'>
                                tauresx, tauresy, ksrftms  ,                                        &amp;<a name='358'>
                                ipbl   , kpblh  , wstarPBL , turbtype, sm_aw )<a name='359'>
       <a name='360'>
    <font color=#447700>!-------------------------------------------------------------------- ! <a name='361'></font>
    <font color=#447700>! Purpose: Interface to compute eddy diffusivities.                   !<a name='362'></font>
    <font color=#447700>!          Eddy diffusivities are calculated in a fully implicit way  !<a name='363'></font>
    <font color=#447700>!          through iteration process.                                 !   <a name='364'></font>
    <font color=#447700>! Author:  Sungsu Park. August. 2006.                                 !<a name='365'></font>
    <font color=#447700>!                       May.    2008.                                 !<a name='366'></font>
    <font color=#447700>!-------------------------------------------------------------------- !<a name='367'></font>
    use <A href='../../html_code/phys/module_cam_bl_diffusion_solver.F.html#DIFFUSION_SOLVER'>diffusion_solver</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="DIFFUSION_SOLVER_6">, only: compute_vdiff<a name='368'>
#ifndef WRF_PORT <a name='369'>
    use cam_history,      only: outfld, addfld, phys_decomp<a name='370'>
  <font color=#447700>! use physics_types,    only: physics_state<a name='371'></font>
    use phys_debug_util,  only: phys_debug_col<a name='372'>
    use time_manager,     only: is_first_step, get_nstep<a name='373'>
#else<a name='374'>
    use <A href='../../html_code/phys/module_cam_support.F.html#MODULE_CAM_SUPPORT'>module_cam_support</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="MODULE_CAM_SUPPORT_7">,   only: outfld, addfld, phys_decomp <a name='375'>
#endif<a name='376'>
<a name='377'>
    implicit none<a name='378'>
<a name='379'>
  <font color=#447700>! type(physics_state)     :: state                     ! Physics state variables<a name='380'></font>
<a name='381'>
    <font color=#447700>! --------------- !<a name='382'></font>
    <font color=#447700>! Input Variables !<a name='383'></font>
    <font color=#447700>! --------------- ! <a name='384'></font>
<a name='385'>
    integer,  intent(in)    :: lchnk   <a name='386'>
    integer,  intent(in)    :: pcols                     <font color=#447700>! Number of atmospheric columns [ # ]<a name='387'></font>
    integer,  intent(in)    :: pver                      <font color=#447700>! Number of atmospheric layers  [ # ]<a name='388'></font>
    integer,  intent(in)    :: ncol                      <font color=#447700>! Number of atmospheric columns [ # ]<a name='389'></font>
    integer,  intent(in)    :: nturb                     <font color=#447700>! Number of iteration steps for calculating eddy diffusivity [ # ]<a name='390'></font>
    logical,  intent(in)    :: wstarent                  <font color=#447700>! .true. means use the 'wstar' entrainment closure. <a name='391'></font>
    logical,  intent(in)    :: kvinit                    <font color=#447700>! 'true' means time step = 1 : used for initializing kvh, kvm (uses kvf or zero)<a name='392'></font>
    real(r8), intent(in)    :: ztodt                     <font color=#447700>! Physics integration time step 2 delta-t [ s ]<a name='393'></font>
    real(r8), intent(in)    :: t(pcols,pver)             <font color=#447700>! Temperature [K]<a name='394'></font>
    real(r8), intent(in)    :: qv(pcols,pver)            <font color=#447700>! Water vapor  specific humidity [ kg/kg ]<a name='395'></font>
    real(r8), intent(in)    :: ql(pcols,pver)            <font color=#447700>! Liquid water specific humidity [ kg/kg ]<a name='396'></font>
    real(r8), intent(in)    :: qi(pcols,pver)            <font color=#447700>! Ice specific humidity [ kg/kg ]<a name='397'></font>
    real(r8), intent(in)    :: s(pcols,pver)             <font color=#447700>! Dry static energy [ J/kg ]<a name='398'></font>
    real(r8), intent(in)    :: rpdel(pcols,pver)         <font color=#447700>! 1./pdel where 'pdel' is thickness of the layer [ Pa ]<a name='399'></font>
    real(r8), intent(in)    :: cldn(pcols,pver)          <font color=#447700>! Stratiform cloud fraction [ fraction ]<a name='400'></font>
    real(r8), intent(in)    :: qrl(pcols,pver)           <font color=#447700>! LW cooling rate<a name='401'></font>
    real(r8), intent(in)    :: wsedl(pcols,pver)         <font color=#447700>! Sedimentation velocity of liquid stratus cloud droplet [ m/s ]<a name='402'></font>
    real(r8), intent(in)    :: z(pcols,pver)             <font color=#447700>! Layer mid-point height above surface [ m ]<a name='403'></font>
    real(r8), intent(in)    :: zi(pcols,pver+1)          <font color=#447700>! Interface height above surface [ m ]<a name='404'></font>
    real(r8), intent(in)    :: pmid(pcols,pver)          <font color=#447700>! Layer mid-point pressure [ Pa ]<a name='405'></font>
    real(r8), intent(in)    :: pi(pcols,pver+1)          <font color=#447700>! Interface pressure [ Pa ]<a name='406'></font>
    real(r8), intent(in)    :: u(pcols,pver)             <font color=#447700>! Zonal velocity [ m/s ]<a name='407'></font>
    real(r8), intent(in)    :: v(pcols,pver)             <font color=#447700>! Meridional velocity [ m/s ]<a name='408'></font>
    real(r8), intent(in)    :: taux(pcols)               <font color=#447700>! Zonal wind stress at surface [ N/m2 ]<a name='409'></font>
    real(r8), intent(in)    :: tauy(pcols)               <font color=#447700>! Meridional wind stress at surface [ N/m2 ]<a name='410'></font>
    real(r8), intent(in)    :: shflx(pcols)              <font color=#447700>! Sensible heat flux at surface [ unit ? ]<a name='411'></font>
    real(r8), intent(in)    :: qflx(pcols)               <font color=#447700>! Water vapor flux at surface [ unit ? ]<a name='412'></font>
    real(r8), intent(in)    :: kvm_in(pcols,pver+1)      <font color=#447700>! kvm saved from last timestep [ m2/s ]<a name='413'></font>
    real(r8), intent(in)    :: kvh_in(pcols,pver+1)      <font color=#447700>! kvh saved from last timestep [ m2/s ]<a name='414'></font>
    real(r8), intent(in)    :: ksrftms(pcols)            <font color=#447700>! Surface drag coefficient of turbulent mountain stress [ unit ? ]<a name='415'></font>
<a name='416'>
    <font color=#447700>! ---------------- !<a name='417'></font>
    <font color=#447700>! Output Variables !<a name='418'></font>
    <font color=#447700>! ---------------- ! <a name='419'></font>
<a name='420'>
    real(r8), intent(out)   :: kvm_out(pcols,pver+1)     <font color=#447700>! Eddy diffusivity for momentum [ m2/s ]<a name='421'></font>
    real(r8), intent(out)   :: kvh_out(pcols,pver+1)     <font color=#447700>! Eddy diffusivity for heat [ m2/s ]<a name='422'></font>
    real(r8), intent(out)   :: kvq(pcols,pver+1)         <font color=#447700>! Eddy diffusivity for constituents, moisture and tracers [ m2/s ] (note not having '_out')<a name='423'></font>
    real(r8), intent(out)   :: ustar(pcols)              <font color=#447700>! Surface friction velocity [ m/s ]<a name='424'></font>
    real(r8), intent(out)   :: pblh(pcols)               <font color=#447700>! PBL top height [ m ]<a name='425'></font>
    real(r8), intent(out)   :: cgh(pcols,pver+1)         <font color=#447700>! Counter-gradient term for heat [ J/kg/m ]<a name='426'></font>
    real(r8), intent(out)   :: cgs(pcols,pver+1)         <font color=#447700>! Counter-gradient star [ cg/flux ]<a name='427'></font>
    real(r8), intent(out)   :: tpert(pcols)              <font color=#447700>! Convective temperature excess [ K ]<a name='428'></font>
    real(r8), intent(out)   :: qpert(pcols)              <font color=#447700>! Convective humidity excess [ kg/kg ]<a name='429'></font>
    real(r8), intent(out)   :: wpert(pcols)              <font color=#447700>! Turbulent velocity excess [ m/s ]<a name='430'></font>
    real(r8), intent(out)   :: tke(pcols,pver+1)         <font color=#447700>! Turbulent kinetic energy [ m2/s2 ]<a name='431'></font>
    real(r8), intent(out)   :: bprod(pcols,pver+1)       <font color=#447700>! Buoyancy production [ m2/s3 ] <a name='432'></font>
    real(r8), intent(out)   :: sprod(pcols,pver+1)       <font color=#447700>! Shear production [ m2/s3 ] <a name='433'></font>
    real(r8), intent(out)   :: sfi(pcols,pver+1)         <font color=#447700>! Interfacial layer saturation fraction [ fraction ]<a name='434'></font>
    real(r8), intent(out)   :: turbtype(pcols,pver+1)    <font color=#447700>! Turbulence type identifier at all interfaces [ no unit ]<a name='435'></font>
    real(r8), intent(out)   :: sm_aw(pcols,pver+1)       <font color=#447700>! Normalized Galperin instability function for momentum [ no unit ]<a name='436'></font>
                                                         <font color=#447700>! This is 1 when neutral condition (Ri=0), 4.964 for maximum unstable case, and 0 when Ri &gt; Ricrit=0.19. <a name='437'></font>
    real(r8), intent(out)   :: ipbl(pcols)               <font color=#447700>! If 1, PBL is CL, while if 0, PBL is STL.<a name='438'></font>
    real(r8), intent(out)   :: kpblh(pcols)              <font color=#447700>! Layer index containing PBL top within or at the base interface<a name='439'></font>
    real(r8), intent(out)   :: wstarPBL(pcols)           <font color=#447700>! Convective velocity within PBL [ m/s ]<a name='440'></font>
<a name='441'>
    <font color=#447700>! ---------------------- !<a name='442'></font>
    <font color=#447700>! Input-Output Variables !<a name='443'></font>
    <font color=#447700>! ---------------------- ! <a name='444'></font>
<a name='445'>
    real(r8), intent(inout) :: tauresx(pcols)            <font color=#447700>! Residual stress to be added in vdiff to correct for turb<a name='446'></font>
    real(r8), intent(inout) :: tauresy(pcols)            <font color=#447700>! Stress mismatch between sfc and atm accumulated in prior timesteps<a name='447'></font>
<a name='448'>
    <font color=#447700>! --------------- !<a name='449'></font>
    <font color=#447700>! Local Variables !<a name='450'></font>
    <font color=#447700>! --------------- !<a name='451'></font>
<a name='452'>
    integer                    icol<a name='453'>
    integer                    i, k, iturb, status<a name='454'>
    integer,  external      :: qsat<a name='455'>
    character(128)          :: errstring                 <font color=#447700>! Error status for compute_vdiff<a name='456'></font>
<a name='457'>
    real(r8)                :: tautotx(pcols)            <font color=#447700>! Total stress including tms<a name='458'></font>
    real(r8)                :: tautoty(pcols)            <font color=#447700>! Total stress including tms<a name='459'></font>
    real(r8)                :: kvf(pcols,pver+1)         <font color=#447700>! Free atmospheric eddy diffusivity [ m2/s ]<a name='460'></font>
    real(r8)                :: kvm(pcols,pver+1)         <font color=#447700>! Eddy diffusivity for momentum [ m2/s ]<a name='461'></font>
    real(r8)                :: kvh(pcols,pver+1)         <font color=#447700>! Eddy diffusivity for heat [ m2/s ]<a name='462'></font>
    real(r8)                :: kvm_preo(pcols,pver+1)    <font color=#447700>! Eddy diffusivity for momentum [ m2/s ]<a name='463'></font>
    real(r8)                :: kvh_preo(pcols,pver+1)    <font color=#447700>! Eddy diffusivity for heat [ m2/s ]<a name='464'></font>
    real(r8)                :: kvm_pre(pcols,pver+1)     <font color=#447700>! Eddy diffusivity for momentum [ m2/s ]<a name='465'></font>
    real(r8)                :: kvh_pre(pcols,pver+1)     <font color=#447700>! Eddy diffusivity for heat [ m2/s ]<a name='466'></font>
    real(r8)                :: errorPBL(pcols)           <font color=#447700>! Error function showing whether PBL produced convergent solution or not. [ unit ? ]<a name='467'></font>
    real(r8)                :: s2(pcols,pver)            <font color=#447700>! Shear squared, defined at interfaces except surface [ s-2 ]<a name='468'></font>
    real(r8)                :: n2(pcols,pver)            <font color=#447700>! Buoyancy frequency, defined at interfaces except surface [ s-2 ]<a name='469'></font>
    real(r8)                :: ri(pcols,pver)            <font color=#447700>! Richardson number, 'n2/s2', defined at interfaces except surface [ s-2 ]<a name='470'></font>
    real(r8)                :: pblhp(pcols)              <font color=#447700>! PBL top pressure [ Pa ]<a name='471'></font>
    real(r8)                :: minpblh(pcols)            <font color=#447700>! Minimum PBL height based on surface stress<a name='472'></font>
<a name='473'>
    real(r8)                :: qt(pcols,pver)            <font color=#447700>! Total specific humidity [ kg/kg ]<a name='474'></font>
    real(r8)                :: sfuh(pcols,pver)          <font color=#447700>! Saturation fraction in upper half-layer [ fraction ]<a name='475'></font>
    real(r8)                :: sflh(pcols,pver)          <font color=#447700>! Saturation fraction in lower half-layer [ fraction ]<a name='476'></font>
    real(r8)                :: sl(pcols,pver)            <font color=#447700>! Liquid water static energy [ J/kg ]<a name='477'></font>
    real(r8)                :: slv(pcols,pver)           <font color=#447700>! Liquid water virtual static energy [ J/kg ]<a name='478'></font>
    real(r8)                :: slslope(pcols,pver)       <font color=#447700>! Slope of 'sl' in each layer<a name='479'></font>
    real(r8)                :: qtslope(pcols,pver)       <font color=#447700>! Slope of 'qt' in each layer<a name='480'></font>
    real(r8)                :: rrho(pcols)               <font color=#447700>! Density at the lowest layer<a name='481'></font>
    real(r8)                :: qvfd(pcols,pver)          <font color=#447700>! Specific humidity for diffusion [ kg/kg ]<a name='482'></font>
    real(r8)                :: tfd(pcols,pver)           <font color=#447700>! Temperature for diffusion [ K ]<a name='483'></font>
    real(r8)                :: slfd(pcols,pver)          <font color=#447700>! Liquid static energy [ J/kg ]<a name='484'></font>
    real(r8)                :: qtfd(pcols,pver)          <font color=#447700>! Total specific humidity [ kg/kg ] <a name='485'></font>
    real(r8)                :: qlfd(pcols,pver)          <font color=#447700>! Liquid water specific humidity for diffusion [ kg/kg ]<a name='486'></font>
    real(r8)                :: ufd(pcols,pver)           <font color=#447700>! U-wind for diffusion [ m/s ]<a name='487'></font>
    real(r8)                :: vfd(pcols,pver)           <font color=#447700>! V-wind for diffusion [ m/s ]<a name='488'></font>
<a name='489'>
    <font color=#447700>! Buoyancy coefficients : w'b' = ch * w'sl' + cm * w'qt'<a name='490'></font>
<a name='491'>
    real(r8)                :: chu(pcols,pver+1)         <font color=#447700>! Heat buoyancy coef for dry states, defined at each interface, finally.<a name='492'></font>
    real(r8)                :: chs(pcols,pver+1)         <font color=#447700>! Heat buoyancy coef for sat states, defined at each interface, finally. <a name='493'></font>
    real(r8)                :: cmu(pcols,pver+1)         <font color=#447700>! Moisture buoyancy coef for dry states, defined at each interface, finally.<a name='494'></font>
    real(r8)                :: cms(pcols,pver+1)         <font color=#447700>! Moisture buoyancy coef for sat states, defined at each interface, finally. <a name='495'></font>
<a name='496'>
    real(r8)                :: jnk1d(pcols)<a name='497'>
    real(r8)                :: jnk2d(pcols,pver+1)  <a name='498'>
    real(r8)                :: zero(pcols)<a name='499'>
    real(r8)                :: zero2d(pcols,pver+1)<a name='500'>
    real(r8)                :: es(1)                     <font color=#447700>! Saturation vapor pressure<a name='501'></font>
    real(r8)                :: qs(1)                     <font color=#447700>! Saturation specific humidity<a name='502'></font>
    real(r8)                :: gam(1)                    <font color=#447700>! (L/cp)*dqs/dT<a name='503'></font>
    real(r8)                :: ep2, templ, temps<a name='504'>
<a name='505'>
    <font color=#447700>! ------------------------------- !<a name='506'></font>
    <font color=#447700>! Variables for diagnostic output !<a name='507'></font>
    <font color=#447700>! ------------------------------- !<a name='508'></font>
<a name='509'>
    real(r8)                :: tkes(pcols)               <font color=#447700>! TKE at surface interface [ m2/s2 ]<a name='510'></font>
    real(r8)                :: kbase_o(pcols,ncvmax)     <font color=#447700>! Original external base interface index of CL from 'exacol'<a name='511'></font>
    real(r8)                :: ktop_o(pcols,ncvmax)      <font color=#447700>! Original external top  interface index of CL from 'exacol'<a name='512'></font>
    real(r8)                :: ncvfin_o(pcols)           <font color=#447700>! Original number of CLs from 'exacol'<a name='513'></font>
    real(r8)                :: kbase_mg(pcols,ncvmax)    <font color=#447700>! 'kbase' after extending-merging from 'zisocl'<a name='514'></font>
    real(r8)                :: ktop_mg(pcols,ncvmax)     <font color=#447700>! 'ktop' after extending-merging from 'zisocl'<a name='515'></font>
    real(r8)                :: ncvfin_mg(pcols)          <font color=#447700>! 'ncvfin' after extending-merging from 'zisocl'<a name='516'></font>
    real(r8)                :: kbase_f(pcols,ncvmax)     <font color=#447700>! Final 'kbase' after extending-merging &amp; including SRCL<a name='517'></font>
    real(r8)                :: ktop_f(pcols,ncvmax)      <font color=#447700>! Final 'ktop' after extending-merging &amp; including SRCL<a name='518'></font>
    real(r8)                :: ncvfin_f(pcols)           <font color=#447700>! Final 'ncvfin' after extending-merging &amp; including SRCL<a name='519'></font>
    real(r8)                :: wet(pcols,ncvmax)         <font color=#447700>! Entrainment rate at the CL top  [ m/s ] <a name='520'></font>
    real(r8)                :: web(pcols,ncvmax)         <font color=#447700>! Entrainment rate at the CL base [ m/s ]. Set to zero if CL is based at surface.<a name='521'></font>
    real(r8)                :: jtbu(pcols,ncvmax)        <font color=#447700>! Buoyancy jump across the CL top  [ m/s2 ]  <a name='522'></font>
    real(r8)                :: jbbu(pcols,ncvmax)        <font color=#447700>! Buoyancy jump across the CL base [ m/s2 ]  <a name='523'></font>
    real(r8)                :: evhc(pcols,ncvmax)        <font color=#447700>! Evaporative enhancement factor at the CL top<a name='524'></font>
    real(r8)                :: jt2slv(pcols,ncvmax)      <font color=#447700>! Jump of slv ( across two layers ) at CL top used only for evhc [ J/kg ]<a name='525'></font>
    real(r8)                :: n2ht(pcols,ncvmax)        <font color=#447700>! n2 defined at the CL top  interface but using sfuh(kt)   instead of sfi(kt) [ s-2 ] <a name='526'></font>
    real(r8)                :: n2hb(pcols,ncvmax)        <font color=#447700>! n2 defined at the CL base interface but using sflh(kb-1) instead of sfi(kb) [ s-2 ]<a name='527'></font>
    real(r8)                :: lwp(pcols,ncvmax)         <font color=#447700>! LWP in the CL top layer [ kg/m2 ]<a name='528'></font>
    real(r8)                :: opt_depth(pcols,ncvmax)   <font color=#447700>! Optical depth of the CL top layer<a name='529'></font>
    real(r8)                :: radinvfrac(pcols,ncvmax)  <font color=#447700>! Fraction of radiative cooling confined in the top portion of CL top layer<a name='530'></font>
    real(r8)                :: radf(pcols,ncvmax)        <font color=#447700>! Buoyancy production at the CL top due to LW radiative cooling [ m2/s3 ]<a name='531'></font>
    real(r8)                :: wstar(pcols,ncvmax)       <font color=#447700>! Convective velocity in each CL [ m/s ]<a name='532'></font>
    real(r8)                :: wstar3fact(pcols,ncvmax)  <font color=#447700>! Enhancement of 'wstar3' due to entrainment (inverse) [ no unit ]<a name='533'></font>
    real(r8)                :: ebrk(pcols,ncvmax)        <font color=#447700>! Net mean TKE of CL including entrainment effect [ m2/s2 ]<a name='534'></font>
    real(r8)                :: wbrk(pcols,ncvmax)        <font color=#447700>! Net mean normalized TKE (W) of CL, 'ebrk/b1' including entrainment effect [ m2/s2 ]<a name='535'></font>
    real(r8)                :: lbrk(pcols,ncvmax)        <font color=#447700>! Energetic internal thickness of CL [m]<a name='536'></font>
    real(r8)                :: ricl(pcols,ncvmax)        <font color=#447700>! CL internal mean Richardson number<a name='537'></font>
    real(r8)                :: ghcl(pcols,ncvmax)        <font color=#447700>! Half of normalized buoyancy production of CL<a name='538'></font>
    real(r8)                :: shcl(pcols,ncvmax)        <font color=#447700>! Galperin instability function of heat-moisture of CL<a name='539'></font>
    real(r8)                :: smcl(pcols,ncvmax)        <font color=#447700>! Galperin instability function of mementum of CL<a name='540'></font>
    real(r8)                :: ghi(pcols,pver+1)         <font color=#447700>! Half of normalized buoyancy production at all interfaces<a name='541'></font>
    real(r8)                :: shi(pcols,pver+1)         <font color=#447700>! Galperin instability function of heat-moisture at all interfaces<a name='542'></font>
    real(r8)                :: smi(pcols,pver+1)         <font color=#447700>! Galperin instability function of heat-moisture at all interfaces<a name='543'></font>
    real(r8)                :: rii(pcols,pver+1)         <font color=#447700>! Interfacial Richardson number defined at all interfaces<a name='544'></font>
    real(r8)                :: lengi(pcols,pver+1)       <font color=#447700>! Turbulence length scale at all interfaces [ m ]<a name='545'></font>
    real(r8)                :: wcap(pcols,pver+1)        <font color=#447700>! Normalized TKE at all interfaces [ m2/s2 ]<a name='546'></font>
<a name='547'>
    <font color=#447700>! ---------- !<a name='548'></font>
    <font color=#447700>! Initialize !<a name='549'></font>
    <font color=#447700>! ---------- !<a name='550'></font>
<a name='551'>
    zero(:)     = 0._r8<a name='552'>
    zero2d(:,:) = 0._r8<a name='553'>
<a name='554'>
    <font color=#447700>! ----------------------- !<a name='555'></font>
    <font color=#447700>! Main Computation Begins ! <a name='556'></font>
    <font color=#447700>! ----------------------- !<a name='557'></font>
<a name='558'>
    ufd(:ncol,:)  = u(:ncol,:)<a name='559'>
    vfd(:ncol,:)  = v(:ncol,:)<a name='560'>
    tfd(:ncol,:)  = t(:ncol,:)<a name='561'>
    qvfd(:ncol,:) = qv(:ncol,:)<a name='562'>
    qlfd(:ncol,:) = ql(:ncol,:)<a name='563'>
    <a name='564'>
    do iturb = 1, nturb<a name='565'>
<a name='566'>
     <font color=#447700>! Compute total stress by including 'tms'.<a name='567'></font>
     <font color=#447700>! Here, in computing 'tms', we can use either iteratively changed 'ufd,vfd' or the<a name='568'></font>
     <font color=#447700>! initially given 'u,v' to the PBL scheme. Note that normal stress, 'taux, tauy'<a name='569'></font>
     <font color=#447700>! are not changed by iteration. In order to treat 'tms' in a fully implicit way,<a name='570'></font>
     <font color=#447700>! I am using updated wind, here.<a name='571'></font>
<a name='572'>
       tautotx(:ncol) = taux(:ncol) - ksrftms(:ncol) * ufd(:ncol,pver)<a name='573'>
       tautoty(:ncol) = tauy(:ncol) - ksrftms(:ncol) * vfd(:ncol,pver)<a name='574'>
<a name='575'>
     <font color=#447700>! Calculate (qt,sl,n2,s2,ri) from a given set of (t,qv,ql,qi,u,v)<a name='576'></font>
<a name='577'>
       call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#TRBINTD'>trbintd</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="TRBINTD_1">( &amp;<a name='578'>
                     pcols    , pver    , ncol  , z       , ufd     , vfd     , tfd   , pmid    , &amp;<a name='579'>
                     tautotx  , tautoty , ustar , rrho    , s2      , n2      , ri    , zi      , &amp;<a name='580'>
                     pi       , cldn    , qtfd  , qvfd    , qlfd    , qi      , sfi   , sfuh    , &amp;<a name='581'>
                     sflh     , slfd    , slv   , slslope , qtslope , chs     , chu   , cms     , &amp;<a name='582'>
                     cmu      , minpblh , qsat )<a name='583'>
<a name='584'>
     <font color=#447700>! Save initial (i.e., before iterative diffusion) profile of (qt,sl) at each iteration.         <a name='585'></font>
     <font color=#447700>! Only necessary for (qt,sl) not (u,v) because (qt,sl) are newly calculated variables. <a name='586'></font>
<a name='587'>
       if( iturb .eq. 1 ) then<a name='588'>
           qt(:ncol,:) = qtfd(:ncol,:)<a name='589'>
           sl(:ncol,:) = slfd(:ncol,:)<a name='590'>
       endif<a name='591'>
<a name='592'>
     <font color=#447700>! Get free atmosphere exchange coefficients. This 'kvf' is not used in UW moist PBL scheme<a name='593'></font>
#ifndef WRF_PORT<a name='594'>
       call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#AUSTAUSCH_ATM'>austausch_atm</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="AUSTAUSCH_ATM_1">( pcols, pver, ncol, ri, s2, kvf )<a name='595'>
#else<a name='596'>
       if(use_kvf)call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#AUSTAUSCH_ATM'>austausch_atm</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="AUSTAUSCH_ATM_2">( pcols, pver, ncol, ri, s2, kvf )<a name='597'>
#endif<a name='598'>
<a name='599'>
     <font color=#447700>! Initialize kvh/kvm to send to caleddy, depending on model timestep and iteration number<a name='600'></font>
     <font color=#447700>! This is necessary for 'wstar-based' entrainment closure.<a name='601'></font>
<a name='602'>
       if( iturb .eq. 1 ) then<a name='603'>
           if( kvinit ) then<a name='604'>
           <font color=#447700>! First iteration of first model timestep : Use free tropospheric value or zero.<a name='605'></font>
             if( use_kvf ) then<a name='606'>
                 kvh(:ncol,:) = kvf(:ncol,:)<a name='607'>
                 kvm(:ncol,:) = kvf(:ncol,:)<a name='608'>
             else<a name='609'>
                 kvh(:ncol,:) = 0._r8<a name='610'>
                 kvm(:ncol,:) = 0._r8<a name='611'>
             endif<a name='612'>
           else<a name='613'>
             <font color=#447700>! First iteration on any model timestep except the first : Use value from previous timestep<a name='614'></font>
             kvh(:ncol,:) = kvh_in(:ncol,:)<a name='615'>
             kvm(:ncol,:) = kvm_in(:ncol,:)<a name='616'>
           endif<a name='617'>
       else<a name='618'>
        <font color=#447700>! Not the first iteration : Use from previous iteration<a name='619'></font>
          kvh(:ncol,:) = kvh_out(:ncol,:)<a name='620'>
          kvm(:ncol,:) = kvm_out(:ncol,:)<a name='621'>
       endif<a name='622'>
<a name='623'>
     <font color=#447700>! Calculate eddy diffusivity (kvh_out,kvm_out) and (tke,bprod,sprod) using<a name='624'></font>
     <font color=#447700>! a given (kvh,kvm) which are used only for initializing (bprod,sprod)  at<a name='625'></font>
     <font color=#447700>! the first part of caleddy. (bprod,sprod) are fully updated at the end of<a name='626'></font>
     <font color=#447700>! caleddy after calculating (kvh_out,kvm_out) <a name='627'></font>
<a name='628'>
       call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY'>caleddy</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="CALEDDY_1">( pcols     , pver      , ncol      ,                     &amp;<a name='629'>
                     slfd      , qtfd      , qlfd      , slv      ,ufd     , &amp;<a name='630'>
                     vfd       , pi        , z         , zi       ,          &amp;<a name='631'>
                     qflx      , shflx     , slslope   , qtslope  ,          &amp;<a name='632'>
                     chu       , chs       , cmu       , cms      ,sfuh    , &amp;<a name='633'>
                     sflh      , n2        , s2        , ri       ,rrho    , &amp;<a name='634'>
                     pblh      , ustar     ,                                 &amp;<a name='635'>
                     kvh       , kvm       , kvh_out   , kvm_out  ,          &amp;<a name='636'>
                     tpert     , qpert     , qrl       , kvf      , tke    , &amp;<a name='637'>
                     wstarent  , bprod     , sprod     , minpblh  , wpert  , &amp;<a name='638'>
                     tkes      , turbtype  , sm_aw     ,                     &amp; <a name='639'>
                     kbase_o   , ktop_o    , ncvfin_o  ,                     &amp;<a name='640'>
                     kbase_mg  , ktop_mg   , ncvfin_mg ,                     &amp;                  <a name='641'>
                     kbase_f   , ktop_f    , ncvfin_f  ,                     &amp;                  <a name='642'>
                     wet       , web       , jtbu      , jbbu     ,          &amp;<a name='643'>
                     evhc      , jt2slv    , n2ht      , n2hb     ,          &amp; <a name='644'>
                     lwp       , opt_depth , radinvfrac, radf     ,          &amp;<a name='645'>
                     wstar     , wstar3fact,                                 &amp;<a name='646'>
                     ebrk      , wbrk      , lbrk      , ricl     , ghcl   , &amp; <a name='647'>
                     shcl      , smcl      , ghi       , shi      , smi    , &amp;<a name='648'>
                     rii       , lengi     , wcap      , pblhp    , cldn   , &amp;<a name='649'>
                     ipbl      , kpblh     , wsedl )<a name='650'>
<a name='651'>
     <font color=#447700>! Calculate errorPBL to check whether PBL produced convergent solutions or not.<a name='652'></font>
<a name='653'>
       if( iturb .eq. nturb ) then<a name='654'>
           do i = 1, ncol<a name='655'>
              errorPBL(i) = 0._r8 <a name='656'>
              do k = 1, pver<a name='657'>
                 errorPBL(i) = errorPBL(i) + ( kvh(i,k) - kvh_out(i,k) )**2 <a name='658'>
              end do <a name='659'>
              errorPBL(i) = sqrt(errorPBL(i)/pver)<a name='660'>
           end do<a name='661'>
       end if<a name='662'>
<a name='663'>
     <font color=#447700>! Eddy diffusivities which will be used for the initialization of (bprod,<a name='664'></font>
     <font color=#447700>! sprod) in 'caleddy' at the next iteration step.<a name='665'></font>
<a name='666'>
       if( iturb .gt. 1 .and. iturb .lt. nturb ) then<a name='667'>
           kvm_out(:ncol,:) = lambda * kvm_out(:ncol,:) + ( 1._r8 - lambda ) * kvm(:ncol,:)<a name='668'>
           kvh_out(:ncol,:) = lambda * kvh_out(:ncol,:) + ( 1._r8 - lambda ) * kvh(:ncol,:)<a name='669'>
       endif<a name='670'>
<a name='671'>
     <font color=#447700>! Set nonlocal terms to zero for flux diagnostics, since not used by caleddy.<a name='672'></font>
<a name='673'>
       cgh(:ncol,:) = 0._r8<a name='674'>
       cgs(:ncol,:) = 0._r8      <a name='675'>
<a name='676'>
       if( iturb .lt. nturb ) then<a name='677'>
<a name='678'>
         <font color=#447700>! Each time we diffuse the original state<a name='679'></font>
<a name='680'>
           slfd(:ncol,:)  = sl(:ncol,:)<a name='681'>
           qtfd(:ncol,:)  = qt(:ncol,:)<a name='682'>
           ufd(:ncol,:)   = u(:ncol,:)<a name='683'>
           vfd(:ncol,:)   = v(:ncol,:)<a name='684'>
<a name='685'>
         <font color=#447700>! Diffuse initial profile of each time step using a given (kvh_out,kvm_out)<a name='686'></font>
         <font color=#447700>! In the below 'compute_vdiff', (slfd,qtfd,ufd,vfd) are 'inout' variables.<a name='687'></font>
<a name='688'>
           call <A href='../../html_code/phys/module_cam_bl_diffusion_solver.F.html#COMPUTE_VDIFF'>compute_vdiff</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMPUTE_VDIFF_3">( lchnk   ,                                                  &amp;<a name='689'>
                               pcols   , pver     , 1        , ncol         , pmid      , &amp;<a name='690'>
                               pi      , rpdel    , t        , ztodt        , taux      , &amp;<a name='691'>
                               tauy    , shflx    , qflx     , ntop_turb    , nbot_turb , &amp;<a name='692'>
                               kvh_out , kvm_out  , kvh_out  , cgs          , cgh       , &amp;<a name='693'>
                               zi      , ksrftms  , zero     , fieldlist_wet,             &amp;<a name='694'>
                               ufd     , vfd      , qtfd     , slfd         ,             &amp;<a name='695'>
                               jnk1d   , jnk1d    , jnk2d    , jnk1d        , errstring , &amp;<a name='696'>
                               tauresx , tauresy  , 0        , .false. )<a name='697'>
<a name='698'>
         <font color=#447700>! Retrieve (tfd,qvfd,qlfd) from (slfd,qtfd) in order to <a name='699'></font>
         <font color=#447700>! use 'trbintd' at the next iteration.<a name='700'></font>
          <a name='701'>
          do k = 1, pver<a name='702'>
             do i = 1, ncol<a name='703'>
              <font color=#447700>! ----------------------------------------------------- ! <a name='704'></font>
              <font color=#447700>! Compute the condensate 'qlfd' in the updated profiles !<a name='705'></font>
              <font color=#447700>! ----------------------------------------------------- !  <a name='706'></font>
              <font color=#447700>! Option.1 : Assume grid-mean condensate is homogeneously diffused by the moist turbulence scheme.<a name='707'></font>
              <font color=#447700>!            This should bs used if 'pseudodiff = .false.' in vertical_diffusion.F90.<a name='708'></font>
              <font color=#447700>! Modification : Need to be check whether below is correct in the presence of ice, qi.       <a name='709'></font>
              <font color=#447700>!                I should understand why the variation of ice, qi is neglected during diffusion.<a name='710'></font>
                templ     = ( slfd(i,k) - g*z(i,k) ) / cpair<a name='711'>
                status    =   <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>qsat</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_1">( templ, pmid(i,k), es(1), qs(1), gam(1), 1 )<a name='712'>
                ep2       =  .622_r8 <a name='713'>
                temps     =   templ + ( qtfd(i,k) - qs(1) ) / ( cpair / latvap + latvap * qs(1) / ( rair * templ**2 ) )<a name='714'>
                status    =   <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>qsat</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_2">( temps, pmid(i,k), es(1), qs(1), gam(1), 1 )<a name='715'>
                qlfd(i,k) =   max( qtfd(i,k) - qi(i,k) - qs(1) ,0._r8 )<a name='716'>
              <font color=#447700>! Option.2 : Assume condensate is not diffused by the moist turbulence scheme. <a name='717'></font>
              <font color=#447700>!            This should bs used if 'pseudodiff = .true.'  in vertical_diffusion.F90.       <a name='718'></font>
              <font color=#447700>! qlfd(i,k) = ql(i,k)<a name='719'></font>
              <font color=#447700>! ----------------------------- !<a name='720'></font>
              <font color=#447700>! Compute the other 'qvfd, tfd' ! <a name='721'></font>
              <font color=#447700>! ----------------------------- !<a name='722'></font>
                qvfd(i,k) = max( 0._r8, qtfd(i,k) - qi(i,k) - qlfd(i,k) )<a name='723'>
                tfd(i,k)  = ( slfd(i,k) + latvap * qlfd(i,k) + latsub * qi(i,k) - g*z(i,k)) / cpair<a name='724'>
             end do<a name='725'>
          end do<a name='726'>
       endif<a name='727'>
<a name='728'>
     <font color=#447700>! Debug <a name='729'></font>
     <font color=#447700>! icol = phys_debug_col(lchnk) <a name='730'></font>
     <font color=#447700>! if( icol &gt; 0 .and. get_nstep() .ge. 1 ) then<a name='731'></font>
     <font color=#447700>!     write(iulog,*) ' '<a name='732'></font>
     <font color=#447700>!     write(iulog,*) 'eddy_diff debug at the end of iteration' <a name='733'></font>
     <font color=#447700>!     write(iulog,*) 't,     qv,     ql,     cld,     u,     v'<a name='734'></font>
     <font color=#447700>!     do k = pver-3, pver<a name='735'></font>
     <font color=#447700>!        write (iulog,*) k, tfd(icol,k), qvfd(icol,k), qlfd(icol,k), cldn(icol,k), ufd(icol,k), vfd(icol,k)<a name='736'></font>
     <font color=#447700>!     end do<a name='737'></font>
     <font color=#447700>! endif<a name='738'></font>
     <font color=#447700>! Debug<a name='739'></font>
<a name='740'>
    end do  <font color=#447700>! End of 'iturb' iteration<a name='741'></font>
<a name='742'>
    kvq(:ncol,:) = kvh_out(:ncol,:)<a name='743'>
<a name='744'>
  <font color=#447700>! Compute 'wstar' within the PBL for use in the future convection scheme.<a name='745'></font>
<a name='746'>
    do i = 1, ncol<a name='747'>
       if( ipbl(i) .eq. 1._r8 ) then <a name='748'>
           wstarPBL(i) = max( 0._r8, wstar(i,1) )<a name='749'>
       else<a name='750'>
           wstarPBL(i) = 0._r8<a name='751'>
       endif<a name='752'>
    end do<a name='753'>
<a name='754'>
    <font color=#447700>! --------------------------------------------------------------- !<a name='755'></font>
    <font color=#447700>! Writing for detailed diagnostic analysis of UW moist PBL scheme !<a name='756'></font>
    <font color=#447700>! --------------------------------------------------------------- !<a name='757'></font>
<a name='758'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_1">( 'UW_errorPBL',    errorPBL,   pcols,   lchnk )<a name='759'>
<a name='760'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_2">( 'UW_n2',          n2,         pcols,   lchnk )<a name='761'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_3">( 'UW_s2',          s2,         pcols,   lchnk )<a name='762'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_4">( 'UW_ri',          ri,         pcols,   lchnk )<a name='763'>
<a name='764'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_5">( 'UW_sfuh',        sfuh,       pcols,   lchnk )<a name='765'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_6">( 'UW_sflh',        sflh,       pcols,   lchnk )<a name='766'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_7">( 'UW_sfi',         sfi,        pcols,   lchnk )<a name='767'>
<a name='768'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_8">( 'UW_cldn',        cldn,       pcols,   lchnk )<a name='769'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_9">( 'UW_qrl',         qrl,        pcols,   lchnk )<a name='770'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_10">( 'UW_ql',          qlfd,       pcols,   lchnk )<a name='771'>
<a name='772'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_11">( 'UW_chu',         chu,        pcols,   lchnk )<a name='773'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_12">( 'UW_chs',         chs,        pcols,   lchnk )<a name='774'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_13">( 'UW_cmu',         cmu,        pcols,   lchnk )<a name='775'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_14">( 'UW_cms',         cms,        pcols,   lchnk )<a name='776'>
<a name='777'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_15">( 'UW_tke',         tke,        pcols,   lchnk )<a name='778'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_16">( 'UW_wcap',        wcap,       pcols,   lchnk )<a name='779'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_17">( 'UW_bprod',       bprod,      pcols,   lchnk )<a name='780'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_18">( 'UW_sprod',       sprod,      pcols,   lchnk )<a name='781'>
<a name='782'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_19">( 'UW_kvh',         kvh_out,    pcols,   lchnk )<a name='783'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_20">( 'UW_kvm',         kvm_out,    pcols,   lchnk )<a name='784'>
<a name='785'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_21">( 'UW_pblh',        pblh,       pcols,   lchnk )<a name='786'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_22">( 'UW_pblhp',       pblhp,      pcols,   lchnk )<a name='787'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_23">( 'UW_tpert',       tpert,      pcols,   lchnk )<a name='788'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_24">( 'UW_qpert',       qpert,      pcols,   lchnk )<a name='789'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_25">( 'UW_wpert',       wpert,      pcols,   lchnk )<a name='790'>
<a name='791'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_26">( 'UW_ustar',       ustar,      pcols,   lchnk )<a name='792'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_27">( 'UW_tkes',        tkes,       pcols,   lchnk )<a name='793'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_28">( 'UW_minpblh',     minpblh,    pcols,   lchnk )<a name='794'>
<a name='795'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_29">( 'UW_turbtype',    turbtype,   pcols,   lchnk )<a name='796'>
<a name='797'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_30">( 'UW_kbase_o',     kbase_o,    pcols,   lchnk )<a name='798'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_31">( 'UW_ktop_o',      ktop_o,     pcols,   lchnk )<a name='799'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_32">( 'UW_ncvfin_o',    ncvfin_o,   pcols,   lchnk )<a name='800'>
<a name='801'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_33">( 'UW_kbase_mg',    kbase_mg,   pcols,   lchnk )<a name='802'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_34">( 'UW_ktop_mg',     ktop_mg,    pcols,   lchnk )<a name='803'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_35">( 'UW_ncvfin_mg',   ncvfin_mg,  pcols,   lchnk )<a name='804'>
<a name='805'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_36">( 'UW_kbase_f',     kbase_f,    pcols,   lchnk )<a name='806'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_37">( 'UW_ktop_f',      ktop_f,     pcols,   lchnk )<a name='807'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_38">( 'UW_ncvfin_f',    ncvfin_f,   pcols,   lchnk ) <a name='808'>
<a name='809'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_39">( 'UW_wet',         wet,        pcols,   lchnk )<a name='810'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_40">( 'UW_web',         web,        pcols,   lchnk )<a name='811'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_41">( 'UW_jtbu',        jtbu,       pcols,   lchnk )<a name='812'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_42">( 'UW_jbbu',        jbbu,       pcols,   lchnk )<a name='813'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_43">( 'UW_evhc',        evhc,       pcols,   lchnk )<a name='814'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_44">( 'UW_jt2slv',      jt2slv,     pcols,   lchnk )<a name='815'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_45">( 'UW_n2ht',        n2ht,       pcols,   lchnk )<a name='816'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_46">( 'UW_n2hb',        n2hb,       pcols,   lchnk )<a name='817'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_47">( 'UW_lwp',         lwp,        pcols,   lchnk )<a name='818'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_48">( 'UW_optdepth',    opt_depth,  pcols,   lchnk )<a name='819'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_49">( 'UW_radfrac',     radinvfrac, pcols,   lchnk )<a name='820'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_50">( 'UW_radf',        radf,       pcols,   lchnk )<a name='821'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_51">( 'UW_wstar',       wstar,      pcols,   lchnk )<a name='822'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_52">( 'UW_wstar3fact',  wstar3fact, pcols,   lchnk )<a name='823'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_53">( 'UW_ebrk',        ebrk,       pcols,   lchnk )<a name='824'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_54">( 'UW_wbrk',        wbrk,       pcols,   lchnk )<a name='825'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_55">( 'UW_lbrk',        lbrk,       pcols,   lchnk )<a name='826'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_56">( 'UW_ricl',        ricl,       pcols,   lchnk )<a name='827'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_57">( 'UW_ghcl',        ghcl,       pcols,   lchnk )<a name='828'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_58">( 'UW_shcl',        shcl,       pcols,   lchnk )<a name='829'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_59">( 'UW_smcl',        smcl,       pcols,   lchnk )<a name='830'>
<a name='831'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_60">( 'UW_gh',          ghi,        pcols,   lchnk )<a name='832'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_61">( 'UW_sh',          shi,        pcols,   lchnk )<a name='833'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_62">( 'UW_sm',          smi,        pcols,   lchnk )<a name='834'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_63">( 'UW_ria',         rii,        pcols,   lchnk )<a name='835'>
    call <A href='../../html_code/phys/module_cam_support.F.html#OUTFLD'>outfld</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_EDDY_DIFF' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="OUTFLD_64">( 'UW_leng',        lengi,      pcols,   lchnk )<a name='836'>
<a name='837'>
    return<a name='838'>
    <a name='839'>
  end subroutine compute_eddy_diff<a name='840'>
<a name='841'>
  <font color=#447700>!=============================================================================== !<a name='842'></font>
  <font color=#447700>!                                                                                !<a name='843'></font>
  <font color=#447700>!=============================================================================== !<a name='844'></font>
  <a name='845'>
<A NAME='SFDIAG'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#SFDIAG' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='846'>
  <font color=#993300>subroutine </font><font color=#cc0000>sfdiag</font>( pcols   , pver    , ncol    , qt      , ql      , sl      , &amp; <A href='../../call_to/SFDIAG.html' TARGET='index'>1</A>,<A href='../../call_from/SFDIAG.html' TARGET='index'>2</A><a name='847'>
                     pi      , pm      , zi      , cld     , sfi     , sfuh    , &amp;<a name='848'>
                     sflh    , slslope , qtslope , qsat )<a name='849'>
    <font color=#447700>!----------------------------------------------------------------------- ! <a name='850'></font>
    <font color=#447700>!                                                                        !<a name='851'></font>
    <font color=#447700>! Purpose: Interface for calculating saturation fractions  at upper and  ! <a name='852'></font>
    <font color=#447700>!          lower-half layers, &amp; interfaces for use by turbulence scheme  !<a name='853'></font>
    <font color=#447700>!                                                                        !<a name='854'></font>
    <font color=#447700>! Method : Various but 'l' should be chosen for consistency.             !<a name='855'></font>
    <font color=#447700>!                                                                        ! <a name='856'></font>
    <font color=#447700>! Author : B. Stevens and C. Bretherton (August 2000)                    !<a name='857'></font>
    <font color=#447700>!          Sungsu Park. August 2006.                                     !<a name='858'></font>
    <font color=#447700>!                       May.   2008.                                     ! <a name='859'></font>
    <font color=#447700>!                                                                        !  <a name='860'></font>
    <font color=#447700>! S.Park : The computed saturation fractions are repeatedly              !<a name='861'></font>
    <font color=#447700>!          used to compute buoyancy coefficients in'trbintd' &amp; 'caleddy'.!  <a name='862'></font>
    <font color=#447700>!----------------------------------------------------------------------- !<a name='863'></font>
<a name='864'>
    implicit none       <a name='865'>
<a name='866'>
    <font color=#447700>! --------------- !<a name='867'></font>
    <font color=#447700>! Input arguments !<a name='868'></font>
    <font color=#447700>! --------------- !<a name='869'></font>
<a name='870'>
    integer,  external    :: qsat<a name='871'>
<a name='872'>
    integer,  intent(in)  :: pcols               <font color=#447700>! Number of atmospheric columns   <a name='873'></font>
    integer,  intent(in)  :: pver                <font color=#447700>! Number of atmospheric layers   <a name='874'></font>
    integer,  intent(in)  :: ncol                <font color=#447700>! Number of atmospheric columns   <a name='875'></font>
<a name='876'>
    real(r8), intent(in)  :: sl(pcols,pver)      <font color=#447700>! Liquid water static energy [ J/kg ]<a name='877'></font>
    real(r8), intent(in)  :: qt(pcols,pver)      <font color=#447700>! Total water specific humidity [ kg/kg ]<a name='878'></font>
    real(r8), intent(in)  :: ql(pcols,pver)      <font color=#447700>! Liquid water specific humidity [ kg/kg ]<a name='879'></font>
    real(r8), intent(in)  :: pi(pcols,pver+1)    <font color=#447700>! Interface pressures [ Pa ]<a name='880'></font>
    real(r8), intent(in)  :: pm(pcols,pver)      <font color=#447700>! Layer mid-point pressures [ Pa ]<a name='881'></font>
    real(r8), intent(in)  :: zi(pcols,pver+1)    <font color=#447700>! Interface heights [ m ]<a name='882'></font>
    real(r8), intent(in)  :: cld(pcols,pver)     <font color=#447700>! Stratiform cloud fraction [ fraction ]<a name='883'></font>
    real(r8), intent(in)  :: slslope(pcols,pver) <font color=#447700>! Slope of 'sl' in each layer<a name='884'></font>
    real(r8), intent(in)  :: qtslope(pcols,pver) <font color=#447700>! Slope of 'qt' in each layer<a name='885'></font>
<a name='886'>
    <font color=#447700>! ---------------- !<a name='887'></font>
    <font color=#447700>! Output arguments !<a name='888'></font>
    <font color=#447700>! ---------------- !<a name='889'></font>
<a name='890'>
    real(r8), intent(out) :: sfi(pcols,pver+1)   <font color=#447700>! Interfacial layer saturation fraction [ fraction ]<a name='891'></font>
    real(r8), intent(out) :: sfuh(pcols,pver)    <font color=#447700>! Saturation fraction in upper half-layer [ fraction ]<a name='892'></font>
    real(r8), intent(out) :: sflh(pcols,pver)    <font color=#447700>! Saturation fraction in lower half-layer [ fraction ]<a name='893'></font>
<a name='894'>
    <font color=#447700>! --------------- !<a name='895'></font>
    <font color=#447700>! Local Variables !<a name='896'></font>
    <font color=#447700>! --------------- !<a name='897'></font>
<a name='898'>
    integer               :: i                   <font color=#447700>! Longitude index<a name='899'></font>
    integer               :: k                   <font color=#447700>! Vertical index<a name='900'></font>
    integer               :: km1                 <font color=#447700>! k-1<a name='901'></font>
    integer               :: status              <font color=#447700>! Status returned by function calls<a name='902'></font>
    real(r8)              :: sltop, slbot        <font color=#447700>! sl at top/bot of grid layer<a name='903'></font>
    real(r8)              :: qttop, qtbot        <font color=#447700>! qt at top/bot of grid layer<a name='904'></font>
    real(r8)              :: tltop(1), tlbot(1)  <font color=#447700>! Liquid water temperature at top/bot of grid layer<a name='905'></font>
    real(r8)              :: qxtop, qxbot        <font color=#447700>! Sat excess at top/bot of grid layer<a name='906'></font>
    real(r8)              :: qxm                 <font color=#447700>! Sat excess at midpoint<a name='907'></font>
    real(r8)              :: es(1)               <font color=#447700>! Saturation vapor pressure<a name='908'></font>
    real(r8)              :: qs(1)               <font color=#447700>! Saturation spec. humidity<a name='909'></font>
    real(r8)              :: gam(1)              <font color=#447700>! (L/cp)*dqs/dT<a name='910'></font>
    real(r8)              :: cldeff(pcols,pver)  <font color=#447700>! Effective Cloud Fraction [ fraction ]<a name='911'></font>
<a name='912'>
    <font color=#447700>! ----------------------- !<a name='913'></font>
    <font color=#447700>! Main Computation Begins ! <a name='914'></font>
    <font color=#447700>! ----------------------- !<a name='915'></font>
<a name='916'>
    sfi(1:ncol,:)    = 0._r8<a name='917'>
    sfuh(1:ncol,:)   = 0._r8<a name='918'>
    sflh(1:ncol,:)   = 0._r8<a name='919'>
    cldeff(1:ncol,:) = 0._r8<a name='920'>
<a name='921'>
    select case (sftype)<a name='922'>
    case ('d')<a name='923'>
       <font color=#447700>! ----------------------------------------------------------------------- !<a name='924'></font>
       <font color=#447700>! Simply use the given stratus fraction ('horizontal' cloud partitioning) !<a name='925'></font>
       <font color=#447700>! ----------------------------------------------------------------------- !<a name='926'></font>
       do k = ntop_turb + 1, nbot_turb<a name='927'>
          km1 = k - 1<a name='928'>
          do i = 1, ncol<a name='929'>
             sfuh(i,k) = cld(i,k)<a name='930'>
             sflh(i,k) = cld(i,k)<a name='931'>
             sfi(i,k)  = 0.5_r8 * ( sflh(i,km1) + min( sflh(i,km1), sfuh(i,k) ) )<a name='932'>
          end do<a name='933'>
       end do<a name='934'>
       do i = 1, ncol<a name='935'>
          sfi(i,pver+1) = sflh(i,pver) <a name='936'>
       end do<a name='937'>
    case ('l')<a name='938'>
       <font color=#447700>! ------------------------------------------ !<a name='939'></font>
       <font color=#447700>! Use modified stratus fraction partitioning !<a name='940'></font>
       <font color=#447700>! ------------------------------------------ !<a name='941'></font>
       do k = ntop_turb + 1, nbot_turb<a name='942'>
          km1 = k - 1<a name='943'>
          do i = 1, ncol<a name='944'>
             cldeff(i,k) = cld(i,k)<a name='945'>
             sfuh(i,k)   = cld(i,k)<a name='946'>
             sflh(i,k)   = cld(i,k)<a name='947'>
             if( ql(i,k) .lt. qmin ) then<a name='948'>
                 sfuh(i,k) = 0._r8<a name='949'>
                 sflh(i,k) = 0._r8<a name='950'>
             end if<a name='951'>
           <font color=#447700>! Modification : The contribution of ice should be carefully considered.<a name='952'></font>
             if( choice_evhc .eq. 'ramp' .or. choice_radf .eq. 'ramp' ) then <a name='953'>
                 cldeff(i,k) = cld(i,k) * min( ql(i,k) / qmin, 1._r8 )<a name='954'>
                 sfuh(i,k)   = cldeff(i,k)<a name='955'>
                 sflh(i,k)   = cldeff(i,k)<a name='956'>
             elseif( choice_evhc .eq. 'maxi' .or. choice_radf .eq. 'maxi' ) then <a name='957'>
                 cldeff(i,k) = cld(i,k)<a name='958'>
                 sfuh(i,k)   = cldeff(i,k)<a name='959'>
                 sflh(i,k)   = cldeff(i,k)<a name='960'>
             endif<a name='961'>
           <font color=#447700>! At the stratus top, take the minimum interfacial saturation fraction<a name='962'></font>
             sfi(i,k) = 0.5_r8 * ( sflh(i,km1) + min( sfuh(i,k), sflh(i,km1) ) )<a name='963'>
           <font color=#447700>! Modification : Currently sfi at the top and surface interfaces are set to be zero.<a name='964'></font>
           <font color=#447700>!                Also, sfuh and sflh in the top model layer is set to be zero.<a name='965'></font>
           <font color=#447700>!                However, I may need to set <a name='966'></font>
           <font color=#447700>!                         do i = 1, ncol<a name='967'></font>
           <font color=#447700>!                            sfi(i,pver+1) = sflh(i,pver) <a name='968'></font>
           <font color=#447700>!                         end do<a name='969'></font>
           <font color=#447700>!                for treating surface-based fog. <a name='970'></font>
           <font color=#447700>! OK. I added below block similar to the other cases.<a name='971'></font>
          end do<a name='972'>
       end do<a name='973'>
       do i = 1, ncol<a name='974'>
          sfi(i,pver+1) = sflh(i,pver)<a name='975'>
       end do<a name='976'>
    case ('u')<a name='977'>
       <font color=#447700>! ------------------------------------------------------------------------- !<a name='978'></font>
       <font color=#447700>! Use unsaturated buoyancy - since sfi, sfuh, sflh have already been zeroed !<a name='979'></font>
       <font color=#447700>! nothing more need be done for this case.                                  !<a name='980'></font>
       <font color=#447700>! ------------------------------------------------------------------------- !<a name='981'></font>
    case ('z')<a name='982'>
       <font color=#447700>! ------------------------------------------------------------------------- !<a name='983'></font>
       <font color=#447700>! Calculate saturation fraction based on whether the air just above or just !<a name='984'></font>
       <font color=#447700>! below the interface is saturated, i.e. with vertical cloud partitioning.  !<a name='985'></font>
       <font color=#447700>! The saturation fraction of the interfacial layer between mid-points k and !<a name='986'></font>
       <font color=#447700>! k+1 is computed by averaging the saturation fraction   of the half-layers !<a name='987'></font>
       <font color=#447700>! above and below the interface,  with a special provision   for cloud tops !<a name='988'></font>
       <font color=#447700>! (more cloud in the half-layer below than in the half-layer above).In each !<a name='989'></font>
       <font color=#447700>! half-layer, vertical partitioning of  cloud based on the slopes diagnosed !<a name='990'></font>
       <font color=#447700>! above is used.     Loop down through the layers, computing the saturation !<a name='991'></font>
       <font color=#447700>! fraction in each half-layer (sfuh for upper half, sflh for lower half).   !<a name='992'></font>
       <font color=#447700>! Once sfuh(i,k) is computed, use with sflh(i,k-1) to determine  saturation !<a name='993'></font>
       <font color=#447700>! fraction sfi(i,k) for interfacial layer k-0.5.                            !<a name='994'></font>
       <font color=#447700>! This is 'not' chosen for full consistent treatment of stratus fraction in !<a name='995'></font>
       <font color=#447700>! all physics schemes.                                                      !<a name='996'></font>
       <font color=#447700>! ------------------------------------------------------------------------- !<a name='997'></font>
       do k = ntop_turb + 1, nbot_turb<a name='998'>
          km1 = k - 1<a name='999'>
          do i = 1, ncol<a name='1000'>
           <font color=#447700>! Compute saturation excess at the mid-point of layer k<a name='1001'></font>
             sltop    = sl(i,k) + slslope(i,k) * ( pi(i,k) - pm(i,k) )      <a name='1002'>
             qttop    = qt(i,k) + qtslope(i,k) * ( pi(i,k) - pm(i,k) )<a name='1003'>
             tltop(1) = ( sltop - g * zi(i,k) ) / cpair <a name='1004'>
             status   = <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>qsat</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#SFDIAG' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_3">( tltop(1), pi(i,k), es(1), qs(1), gam(1), 1 )<a name='1005'>
             qxtop    = qttop - qs(1) <a name='1006'>
             slbot    = sl(i,k) + slslope(i,k) * ( pi(i,k+1) - pm(i,k) )      <a name='1007'>
             qtbot    = qt(i,k) + qtslope(i,k) * ( pi(i,k+1) - pm(i,k) )<a name='1008'>
             tlbot(1) = ( slbot - g * zi(i,k+1) ) / cpair <a name='1009'>
             status   = <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>qsat</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#SFDIAG' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_4">( tlbot(1), pi(i,k+1), es(1), qs(1), gam(1), 1 )<a name='1010'>
             qxbot    = qtbot - qs(1) <a name='1011'>
             qxm      = qxtop + ( qxbot - qxtop ) * ( pm(i,k) - pi(i,k) ) / ( pi(i,k+1) - pi(i,k) )<a name='1012'>
           <font color=#447700>! Find the saturation fraction sfuh(i,k) of the upper half of layer k.<a name='1013'></font>
             if( ( qxtop .lt. 0._r8 ) .and. ( qxm .lt. 0._r8 ) ) then<a name='1014'>
                   sfuh(i,k) = 0._r8 <a name='1015'>
             else if( ( qxtop .gt. 0._r8 ) .and. ( qxm .gt. 0._r8 ) ) then<a name='1016'>
                   sfuh(i,k) = 1._r8  <a name='1017'>
             else <font color=#447700>! Either qxm &lt; 0 and qxtop &gt; 0 or vice versa<a name='1018'></font>
                   sfuh(i,k) = max( qxtop, qxm ) / abs( qxtop - qxm )<a name='1019'>
             end if<a name='1020'>
           <font color=#447700>! Combine with sflh(i) (still for layer k-1) to get interfac layer saturation fraction<a name='1021'></font>
             sfi(i,k) = 0.5_r8 * ( sflh(i,k-1) + min( sflh(i,k-1), sfuh(i,k) ) )<a name='1022'>
           <font color=#447700>! Update sflh to be for the lower half of layer k.             <a name='1023'></font>
             if( ( qxbot .lt. 0._r8 ) .and. ( qxm .lt. 0._r8 ) ) then<a name='1024'>
                   sflh(i,k) = 0._r8 <a name='1025'>
             else if( ( qxbot .gt. 0._r8 ) .and. ( qxm .gt. 0._r8 ) ) then<a name='1026'>
                   sflh(i,k) = 1._r8 <a name='1027'>
             else <font color=#447700>! Either qxm &lt; 0 and qxbot &gt; 0 or vice versa<a name='1028'></font>
                   sflh(i,k) = max( qxbot, qxm ) / abs( qxbot - qxm )<a name='1029'>
             end if<a name='1030'>
          end do  <font color=#447700>! i<a name='1031'></font>
       end do <font color=#447700>! k<a name='1032'></font>
       do i = 1, ncol<a name='1033'>
          sfi(i,pver+1) = sflh(i,pver)  <font color=#447700>! Saturation fraction in the lowest half-layer. <a name='1034'></font>
       end do<a name='1035'>
    end select<a name='1036'>
<a name='1037'>
  return<a name='1038'>
  end subroutine sfdiag<a name='1039'>
  <a name='1040'>
  <font color=#447700>!=============================================================================== !<a name='1041'></font>
  <font color=#447700>!                                                                                !<a name='1042'></font>
  <font color=#447700>!=============================================================================== !<a name='1043'></font>
 <a name='1044'>
<A NAME='TRBINTD'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#TRBINTD' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1045'>
  <font color=#993300>subroutine </font><font color=#cc0000>trbintd</font>( pcols   , pver    , ncol    ,                               &amp; <A href='../../call_to/TRBINTD.html' TARGET='index'>1</A>,<A href='../../call_from/TRBINTD.html' TARGET='index'>2</A><a name='1046'>
                      z       , u       , v       ,                               &amp;<a name='1047'>
                      t       , pmid    , taux    ,                               &amp;<a name='1048'>
                      tauy    , ustar   , rrho    ,                               &amp;<a name='1049'>
                      s2      , n2      , ri      ,                               &amp;<a name='1050'>
                      zi      , pi      , cld     ,                               &amp;<a name='1051'>
                      qt      , qv      , ql      , qi      , sfi     , sfuh    , &amp;<a name='1052'>
                      sflh    , sl      , slv     , slslope , qtslope ,           &amp;<a name='1053'>
                      chs     , chu     , cms     , cmu     , minpblh , qsat )<a name='1054'>
    <font color=#447700>!----------------------------------------------------------------------- !<a name='1055'></font>
    <font color=#447700>! Purpose: Calculate buoyancy coefficients at all interfaces including   !<a name='1056'></font>
    <font color=#447700>!          surface. Also, computes the profiles of ( sl,qt,n2,s2,ri ).   !<a name='1057'></font>
    <font color=#447700>!          Note that (n2,s2,ri) are defined at each interfaces except    !<a name='1058'></font>
    <font color=#447700>!          surface.                                                      !<a name='1059'></font>
    <font color=#447700>!                                                                        !<a name='1060'></font>
    <font color=#447700>! Author: B. Stevens  ( Extracted from pbldiff, August, 2000 )           !<a name='1061'></font>
    <font color=#447700>!         Sungsu Park ( August 2006, May. 2008 )                         !<a name='1062'></font>
    <font color=#447700>!----------------------------------------------------------------------- !<a name='1063'></font>
<a name='1064'>
    implicit none<a name='1065'>
<a name='1066'>
    <font color=#447700>! --------------- !<a name='1067'></font>
    <font color=#447700>! Input arguments !<a name='1068'></font>
    <font color=#447700>! --------------- !<a name='1069'></font>
<a name='1070'>
    integer,  intent(in)  :: pcols                            <font color=#447700>! Number of atmospheric columns   <a name='1071'></font>
    integer,  intent(in)  :: pver                             <font color=#447700>! Number of atmospheric layers   <a name='1072'></font>
    integer,  intent(in)  :: ncol                             <font color=#447700>! Number of atmospheric columns<a name='1073'></font>
    real(r8), intent(in)  :: z(pcols,pver)                    <font color=#447700>! Layer mid-point height above surface [ m ]<a name='1074'></font>
    real(r8), intent(in)  :: u(pcols,pver)                    <font color=#447700>! Layer mid-point u [ m/s ]<a name='1075'></font>
    real(r8), intent(in)  :: v(pcols,pver)                    <font color=#447700>! Layer mid-point v [ m/s ]<a name='1076'></font>
    real(r8), intent(in)  :: t(pcols,pver)                    <font color=#447700>! Layer mid-point temperature [ K ]<a name='1077'></font>
    real(r8), intent(in)  :: pmid(pcols,pver)                 <font color=#447700>! Layer mid-point pressure [ Pa ]<a name='1078'></font>
    real(r8), intent(in)  :: taux(pcols)                      <font color=#447700>! Surface u stress [ N/m2 ]<a name='1079'></font>
    real(r8), intent(in)  :: tauy(pcols)                      <font color=#447700>! Surface v stress [ N/m2 ]<a name='1080'></font>
    real(r8), intent(in)  :: zi(pcols,pver+1)                 <font color=#447700>! Interface height [ m ]<a name='1081'></font>
    real(r8), intent(in)  :: pi(pcols,pver+1)                 <font color=#447700>! Interface pressure [ Pa ]<a name='1082'></font>
    real(r8), intent(in)  :: cld(pcols,pver)                  <font color=#447700>! Stratus fraction<a name='1083'></font>
    real(r8), intent(in)  :: qv(pcols,pver)                   <font color=#447700>! Water vapor specific humidity [ kg/kg ]<a name='1084'></font>
    real(r8), intent(in)  :: ql(pcols,pver)                   <font color=#447700>! Liquid water specific humidity [ kg/kg ]<a name='1085'></font>
    real(r8), intent(in)  :: qi(pcols,pver)                   <font color=#447700>! Ice water specific humidity [ kg/kg ]<a name='1086'></font>
    integer,  external    :: qsat<a name='1087'>
<a name='1088'>
    <font color=#447700>! ---------------- !<a name='1089'></font>
    <font color=#447700>! Output arguments !<a name='1090'></font>
    <font color=#447700>! ---------------- !<a name='1091'></font>
<a name='1092'>
    real(r8), intent(out) :: ustar(pcols)                     <font color=#447700>! Surface friction velocity [ m/s ]<a name='1093'></font>
    real(r8), intent(out) :: s2(pcols,pver)                   <font color=#447700>! Interfacial ( except surface ) shear squared [ s-2 ]<a name='1094'></font>
    real(r8), intent(out) :: n2(pcols,pver)                   <font color=#447700>! Interfacial ( except surface ) buoyancy frequency [ s-2 ]<a name='1095'></font>
    real(r8), intent(out) :: ri(pcols,pver)                   <font color=#447700>! Interfacial ( except surface ) Richardson number, 'n2/s2'<a name='1096'></font>
 <a name='1097'>
    real(r8), intent(out) :: qt(pcols,pver)                   <font color=#447700>! Total specific humidity [ kg/kg ]<a name='1098'></font>
    real(r8), intent(out) :: sfi(pcols,pver+1)                <font color=#447700>! Interfacial layer saturation fraction [ fraction ]<a name='1099'></font>
    real(r8), intent(out) :: sfuh(pcols,pver)                 <font color=#447700>! Saturation fraction in upper half-layer [ fraction ]<a name='1100'></font>
    real(r8), intent(out) :: sflh(pcols,pver)                 <font color=#447700>! Saturation fraction in lower half-layer [ fraction ]<a name='1101'></font>
    real(r8), intent(out) :: sl(pcols,pver)                   <font color=#447700>! Liquid water static energy [ J/kg ] <a name='1102'></font>
    real(r8), intent(out) :: slv(pcols,pver)                  <font color=#447700>! Liquid water virtual static energy [ J/kg ]<a name='1103'></font>
   <a name='1104'>
    real(r8), intent(out) :: chu(pcols,pver+1)                <font color=#447700>! Heat buoyancy coef for dry states at all interfaces, finally. [ unit ? ]<a name='1105'></font>
    real(r8), intent(out) :: chs(pcols,pver+1)                <font color=#447700>! heat buoyancy coef for sat states at all interfaces, finally. [ unit ? ]<a name='1106'></font>
    real(r8), intent(out) :: cmu(pcols,pver+1)                <font color=#447700>! Moisture buoyancy coef for dry states at all interfaces, finally. [ unit ? ]<a name='1107'></font>
    real(r8), intent(out) :: cms(pcols,pver+1)                <font color=#447700>! Moisture buoyancy coef for sat states at all interfaces, finally. [ unit ? ]<a name='1108'></font>
    real(r8), intent(out) :: slslope(pcols,pver)              <font color=#447700>! Slope of 'sl' in each layer<a name='1109'></font>
    real(r8), intent(out) :: qtslope(pcols,pver)              <font color=#447700>! Slope of 'qt' in each layer<a name='1110'></font>
    real(r8), intent(out) :: rrho(pcols)                      <font color=#447700>! 1./bottom level density [ m3/kg ]<a name='1111'></font>
    real(r8), intent(out) :: minpblh(pcols)                   <font color=#447700>! Minimum PBL height based on surface stress [ m ]<a name='1112'></font>
 <a name='1113'>
    <font color=#447700>! --------------- !<a name='1114'></font>
    <font color=#447700>! Local Variables !<a name='1115'></font>
    <font color=#447700>! --------------- ! <a name='1116'></font>
<a name='1117'>
    integer               :: i                                <font color=#447700>! Longitude index<a name='1118'></font>
    integer               :: k, km1                           <font color=#447700>! Level index<a name='1119'></font>
    integer               :: status                           <font color=#447700>! Status returned by function calls<a name='1120'></font>
<a name='1121'>
    real(r8)              :: qs(pcols,pver)                   <font color=#447700>! Saturation specific humidity<a name='1122'></font>
    real(r8)              :: es(pcols,pver)                   <font color=#447700>! Saturation vapor pressure<a name='1123'></font>
    real(r8)              :: gam(pcols,pver)                  <font color=#447700>! (l/cp)*(d(qs)/dT)<a name='1124'></font>
    real(r8)              :: rdz                              <font color=#447700>! 1 / (delta z) between midpoints<a name='1125'></font>
    real(r8)              :: dsldz                            <font color=#447700>! 'delta sl / delta z' at interface<a name='1126'></font>
    real(r8)              :: dqtdz                            <font color=#447700>! 'delta qt / delta z' at interface<a name='1127'></font>
    real(r8)              :: ch                               <font color=#447700>! 'sfi' weighted ch at the interface<a name='1128'></font>
    real(r8)              :: cm                               <font color=#447700>! 'sfi' weighted cm at the interface<a name='1129'></font>
    real(r8)              :: bfact                            <font color=#447700>! Buoyancy factor in n2 calculations<a name='1130'></font>
    real(r8)              :: product                          <font color=#447700>! Intermediate vars used to find slopes<a name='1131'></font>
    real(r8)              :: dsldp_a, dqtdp_a                 <font color=#447700>! Slopes across interface above <a name='1132'></font>
    real(r8)              :: dsldp_b(pcols), dqtdp_b(pcols)   <font color=#447700>! Slopes across interface below<a name='1133'></font>
<a name='1134'>
    <font color=#447700>! ----------------------- !<a name='1135'></font>
    <font color=#447700>! Main Computation Begins !<a name='1136'></font>
    <font color=#447700>! ----------------------- !<a name='1137'></font>
<a name='1138'>
    <font color=#447700>! Compute ustar, and kinematic surface fluxes from surface energy fluxes<a name='1139'></font>
<a name='1140'>
    do i = 1, ncol<a name='1141'>
       rrho(i)    = rair * t(i,pver) / pmid(i,pver)<a name='1142'>
       ustar(i)   = max( sqrt( sqrt( taux(i)**2 + tauy(i)**2 ) * rrho(i) ), ustar_min )<a name='1143'>
       minpblh(i) = 100.0_r8 * ustar(i)                       <font color=#447700>! By construction, 'minpblh' is larger than 1 [m] when 'ustar_min = 0.01'. <a name='1144'></font>
    end do<a name='1145'>
<a name='1146'>
    <font color=#447700>! Calculate conservative scalars (qt,sl,slv) and buoyancy coefficients at the layer mid-points.<a name='1147'></font>
    <font color=#447700>! Note that 'ntop_turb = 1', 'nbot_turb = pver'<a name='1148'></font>
<a name='1149'>
    do k = ntop_turb, nbot_turb<a name='1150'>
       status = <A href='../../html_code/phys/module_mp_milbrandt2mom.F.html#QSAT'>qsat</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#TRBINTD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="QSAT_5">( t(1,k), pmid(1,k), es(1,k), qs(1,k), gam(1,k), ncol )<a name='1151'>
       do i = 1, ncol<a name='1152'>
          qt(i,k)  = qv(i,k) + ql(i,k) + qi(i,k) <a name='1153'>
          sl(i,k)  = cpair * t(i,k) + g * z(i,k) - latvap * ql(i,k) - latsub * qi(i,k)<a name='1154'>
          slv(i,k) = sl(i,k) * ( 1._r8 + zvir * qt(i,k) )<a name='1155'>
        <font color=#447700>! Thermodynamic coefficients for buoyancy flux - in this loop these are<a name='1156'></font>
        <font color=#447700>! calculated at mid-points; later,  they will be averaged to interfaces,<a name='1157'></font>
        <font color=#447700>! where they will ultimately be used.  At the surface, the coefficients<a name='1158'></font>
        <font color=#447700>! are taken from the lowest mid point.<a name='1159'></font>
          bfact    = g / ( t(i,k) * ( 1._r8 + zvir * qv(i,k) - ql(i,k) - qi(i,k) ) )<a name='1160'>
          chu(i,k) = ( 1._r8 + zvir * qt(i,k) ) * bfact / cpair<a name='1161'>
          chs(i,k) = ( ( 1._r8 + ( 1._r8 + zvir ) * gam(i,k) * cpair * t(i,k) / latvap ) / ( 1._r8 + gam(i,k) ) ) * bfact / cpair<a name='1162'>
          cmu(i,k) = zvir * bfact * t(i,k)<a name='1163'>
          cms(i,k) = latvap * chs(i,k)  -  bfact * t(i,k)<a name='1164'>
       end do<a name='1165'>
    end do<a name='1166'>
<a name='1167'>
    do i = 1, ncol<a name='1168'>
       chu(i,pver+1) = chu(i,pver)<a name='1169'>
       chs(i,pver+1) = chs(i,pver)<a name='1170'>
       cmu(i,pver+1) = cmu(i,pver)<a name='1171'>
       cms(i,pver+1) = cms(i,pver)<a name='1172'>
    end do<a name='1173'>
<a name='1174'>
    <font color=#447700>! Compute slopes of conserved variables sl, qt within each layer k. <a name='1175'></font>
    <font color=#447700>! 'a' indicates the 'above' gradient from layer k-1 to layer k and <a name='1176'></font>
    <font color=#447700>! 'b' indicates the 'below' gradient from layer k   to layer k+1.<a name='1177'></font>
    <font color=#447700>! We take a smaller (in absolute value)  of these gradients as the<a name='1178'></font>
    <font color=#447700>! slope within layer k. If they have opposite signs,   gradient in <a name='1179'></font>
    <font color=#447700>! layer k is taken to be zero. I should re-consider whether   this<a name='1180'></font>
    <font color=#447700>! profile reconstruction is the best or not.<a name='1181'></font>
    <font color=#447700>! This is similar to the profile reconstruction used in the UWShCu. <a name='1182'></font>
<a name='1183'>
    do i = 1, ncol<a name='1184'>
     <font color=#447700>! Slopes at endpoints determined by extrapolation<a name='1185'></font>
       slslope(i,pver) = ( sl(i,pver) - sl(i,pver-1) ) / ( pmid(i,pver) - pmid(i,pver-1) )<a name='1186'>
       qtslope(i,pver) = ( qt(i,pver) - qt(i,pver-1) ) / ( pmid(i,pver) - pmid(i,pver-1) )<a name='1187'>
       slslope(i,1)    = ( sl(i,2) - sl(i,1) ) / ( pmid(i,2) - pmid(i,1) )<a name='1188'>
       qtslope(i,1)    = ( qt(i,2) - qt(i,1) ) / ( pmid(i,2) - pmid(i,1) )<a name='1189'>
       dsldp_b(i)      = slslope(i,1)<a name='1190'>
       dqtdp_b(i)      = qtslope(i,1)<a name='1191'>
    end do<a name='1192'>
<a name='1193'>
    do k = 2, pver - 1<a name='1194'>
       do i = 1, ncol<a name='1195'>
          dsldp_a    = dsldp_b(i)<a name='1196'>
          dqtdp_a    = dqtdp_b(i)<a name='1197'>
          dsldp_b(i) = ( sl(i,k+1) - sl(i,k) ) / ( pmid(i,k+1) - pmid(i,k) )<a name='1198'>
          dqtdp_b(i) = ( qt(i,k+1) - qt(i,k) ) / ( pmid(i,k+1) - pmid(i,k) )<a name='1199'>
          product    = dsldp_a * dsldp_b(i)<a name='1200'>
          if( product .le. 0._r8 ) then <a name='1201'>
              slslope(i,k) = 0._r8<a name='1202'>
          else if( product .gt. 0._r8 .and. dsldp_a .lt. 0._r8 ) then <a name='1203'>
              slslope(i,k) = max( dsldp_a, dsldp_b(i) )<a name='1204'>
          else if( product .gt. 0._r8 .and. dsldp_a .gt. 0._r8 ) then <a name='1205'>
              slslope(i,k) = min( dsldp_a, dsldp_b(i) )<a name='1206'>
          end if<a name='1207'>
          product = dqtdp_a*dqtdp_b(i)<a name='1208'>
          if( product .le. 0._r8 ) then <a name='1209'>
              qtslope(i,k) = 0._r8<a name='1210'>
          else if( product .gt. 0._r8 .and. dqtdp_a .lt. 0._r8 ) then <a name='1211'>
              qtslope(i,k) = max( dqtdp_a, dqtdp_b(i) )<a name='1212'>
          else if( product .gt. 0._r8 .and. dqtdp_a .gt. 0._r8 ) then <a name='1213'>
              qtslope(i,k) = min( dqtdp_a, dqtdp_b(i) )<a name='1214'>
          end if<a name='1215'>
       end do <font color=#447700>! i<a name='1216'></font>
    end do <font color=#447700>! k<a name='1217'></font>
<a name='1218'>
    <font color=#447700>!  Compute saturation fraction at the interfacial layers for use in buoyancy<a name='1219'></font>
    <font color=#447700>!  flux computation.<a name='1220'></font>
<a name='1221'>
    call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#SFDIAG'>sfdiag</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#TRBINTD' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="SFDIAG_1">( pcols  , pver    , ncol    , qt      , ql      , sl      , &amp; <a name='1222'>
                 pi     , pmid    , zi      , cld     , sfi     , sfuh    , &amp;<a name='1223'>
                 sflh   , slslope , qtslope , qsat )<a name='1224'>
<a name='1225'>
    <font color=#447700>! Calculate buoyancy coefficients at all interfaces (1:pver+1) and (n2,s2,ri) <a name='1226'></font>
    <font color=#447700>! at all interfaces except surface. Note 'nbot_turb = pver', 'ntop_turb = 1'.<a name='1227'></font>
    <font color=#447700>! With the previous definition of buoyancy coefficients at the surface, the <a name='1228'></font>
    <font color=#447700>! resulting buoyancy coefficients at the top and surface interfaces becomes <a name='1229'></font>
    <font color=#447700>! identical to the buoyancy coefficients at the top and bottom layers. Note <a name='1230'></font>
    <font color=#447700>! that even though the dimension of (s2,n2,ri) is 'pver',  they are defined<a name='1231'></font>
    <font color=#447700>! at interfaces ( not at the layer mid-points ) except the surface. <a name='1232'></font>
<a name='1233'>
    do k = nbot_turb, ntop_turb + 1, -1<a name='1234'>
       km1 = k - 1<a name='1235'>
       do i = 1, ncol<a name='1236'>
          rdz      = 1._r8 / ( z(i,km1) - z(i,k) )<a name='1237'>
          dsldz    = ( sl(i,km1) - sl(i,k) ) * rdz<a name='1238'>
          dqtdz    = ( qt(i,km1) - qt(i,k) ) * rdz <a name='1239'>
          chu(i,k) = ( chu(i,km1) + chu(i,k) ) * 0.5_r8<a name='1240'>
          chs(i,k) = ( chs(i,km1) + chs(i,k) ) * 0.5_r8<a name='1241'>
          cmu(i,k) = ( cmu(i,km1) + cmu(i,k) ) * 0.5_r8<a name='1242'>
          cms(i,k) = ( cms(i,km1) + cms(i,k) ) * 0.5_r8<a name='1243'>
          ch       = chu(i,k) * ( 1._r8 - sfi(i,k) ) + chs(i,k) * sfi(i,k)<a name='1244'>
          cm       = cmu(i,k) * ( 1._r8 - sfi(i,k) ) + cms(i,k) * sfi(i,k)<a name='1245'>
          n2(i,k)  = ch * dsldz +  cm * dqtdz<a name='1246'>
          s2(i,k)  = ( ( u(i,km1) - u(i,k) )**2 + ( v(i,km1) - v(i,k) )**2) * rdz**2<a name='1247'>
          s2(i,k)  = max( ntzero, s2(i,k) )<a name='1248'>
          ri(i,k)  = n2(i,k) / s2(i,k)<a name='1249'>
       end do<a name='1250'>
    end do <a name='1251'>
    do i = 1, ncol<a name='1252'>
       n2(i,1) = n2(i,2)<a name='1253'>
       s2(i,1) = s2(i,2)<a name='1254'>
       ri(i,1) = ri(i,2)<a name='1255'>
    end do<a name='1256'>
<a name='1257'>
  return<a name='1258'>
<a name='1259'>
  end subroutine trbintd<a name='1260'>
<a name='1261'>
  <font color=#447700>!=============================================================================== !<a name='1262'></font>
  <font color=#447700>!                                                                                !<a name='1263'></font>
  <font color=#447700>!=============================================================================== !<a name='1264'></font>
  <a name='1265'>
<A NAME='AUSTAUSCH_ATM'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#AUSTAUSCH_ATM' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1266'>
  <font color=#993300>subroutine </font><font color=#cc0000>austausch_atm</font>( pcols, pver, ncol, ri, s2, kvf ) <A href='../../call_to/AUSTAUSCH_ATM.html' TARGET='index'>2</A><a name='1267'>
<a name='1268'>
    <font color=#447700>!---------------------------------------------------------------------- ! <a name='1269'></font>
    <font color=#447700>!                                                                       !<a name='1270'></font>
    <font color=#447700>! Purpose: Computes exchange coefficients for free turbulent flows.     !<a name='1271'></font>
    <font color=#447700>!          This is not used in the UW moist turbulence scheme.          !<a name='1272'></font>
    <font color=#447700>!                                                                       !<a name='1273'></font>
    <font color=#447700>! Method:                                                               !<a name='1274'></font>
    <font color=#447700>!                                                                       !<a name='1275'></font>
    <font color=#447700>! The free atmosphere diffusivities are based on standard mixing length !<a name='1276'></font>
    <font color=#447700>! forms for the neutral diffusivity multiplied by functns of Richardson !<a name='1277'></font>
    <font color=#447700>! number. K = l^2 * |dV/dz| * f(Ri). The same functions are used for    !<a name='1278'></font>
    <font color=#447700>! momentum, potential temperature, and constitutents.                   !<a name='1279'></font>
    <font color=#447700>!                                                                       !<a name='1280'></font>
    <font color=#447700>! The stable Richardson num function (Ri&gt;0) is taken from Holtslag and  !<a name='1281'></font>
    <font color=#447700>! Beljaars (1989), ECMWF proceedings. f = 1 / (1 + 10*Ri*(1 + 8*Ri))    !<a name='1282'></font>
    <font color=#447700>! The unstable Richardson number function (Ri&lt;0) is taken from  CCM1.   !<a name='1283'></font>
    <font color=#447700>! f = sqrt(1 - 18*Ri)                                                   !<a name='1284'></font>
    <font color=#447700>!                                                                       !<a name='1285'></font>
    <font color=#447700>! Author: B. Stevens (rewrite, August 2000)                             !<a name='1286'></font>
    <font color=#447700>!                                                                       !<a name='1287'></font>
    <font color=#447700>!---------------------------------------------------------------------- !<a name='1288'></font>
    implicit none<a name='1289'>
    <a name='1290'>
    <font color=#447700>! --------------- ! <a name='1291'></font>
    <font color=#447700>! Input arguments !<a name='1292'></font>
    <font color=#447700>! --------------- !<a name='1293'></font>
<a name='1294'>
    integer,  intent(in)  :: pcols                <font color=#447700>! Number of atmospheric columns   <a name='1295'></font>
    integer,  intent(in)  :: pver                 <font color=#447700>! Number of atmospheric layers   <a name='1296'></font>
    integer,  intent(in)  :: ncol                 <font color=#447700>! Number of atmospheric columns<a name='1297'></font>
<a name='1298'>
    real(r8), intent(in)  :: s2(pcols,pver)       <font color=#447700>! Shear squared<a name='1299'></font>
    real(r8), intent(in)  :: ri(pcols,pver)       <font color=#447700>! Richardson no<a name='1300'></font>
<a name='1301'>
    <font color=#447700>! ---------------- !<a name='1302'></font>
    <font color=#447700>! Output arguments !<a name='1303'></font>
    <font color=#447700>! ---------------- !<a name='1304'></font>
<a name='1305'>
    real(r8), intent(out) :: kvf(pcols,pver+1)    <font color=#447700>! Eddy diffusivity for heat and tracers<a name='1306'></font>
<a name='1307'>
    <font color=#447700>! --------------- !<a name='1308'></font>
    <font color=#447700>! Local Variables !<a name='1309'></font>
    <font color=#447700>! --------------- !<a name='1310'></font>
<a name='1311'>
    real(r8)              :: fofri                <font color=#447700>! f(ri)<a name='1312'></font>
    real(r8)              :: kvn                  <font color=#447700>! Neutral Kv<a name='1313'></font>
<a name='1314'>
    integer               :: i                    <font color=#447700>! Longitude index<a name='1315'></font>
    integer               :: k                    <font color=#447700>! Vertical index<a name='1316'></font>
<a name='1317'>
    <font color=#447700>! ----------------------- !<a name='1318'></font>
    <font color=#447700>! Main Computation Begins !<a name='1319'></font>
    <font color=#447700>! ----------------------- !<a name='1320'></font>
<a name='1321'>
    kvf(:ncol,:)           = 0.0_r8<a name='1322'>
    kvf(:ncol,pver+1)      = 0.0_r8<a name='1323'>
    kvf(:ncol,1:ntop_turb) = 0.0_r8<a name='1324'>
<a name='1325'>
    <font color=#447700>! Compute the free atmosphere vertical diffusion coefficients: kvh = kvq = kvm. <a name='1326'></font>
<a name='1327'>
    do k = ntop_turb + 1, nbot_turb<a name='1328'>
       do i = 1, ncol<a name='1329'>
          if( ri(i,k) &lt; 0.0_r8 ) then<a name='1330'>
              fofri = sqrt( max( 1._r8 - 18._r8 * ri(i,k), 0._r8 ) )<a name='1331'>
          else <a name='1332'>
              fofri = 1.0_r8 / ( 1.0_r8 + 10.0_r8 * ri(i,k) * ( 1.0_r8 + 8.0_r8 * ri(i,k) ) )    <a name='1333'>
          end if<a name='1334'>
          kvn = ml2(k) * sqrt(s2(i,k))<a name='1335'>
          kvf(i,k) = max( zkmin, kvn * fofri )<a name='1336'>
       end do<a name='1337'>
    end do<a name='1338'>
<a name='1339'>
    return<a name='1340'>
<a name='1341'>
    end subroutine austausch_atm<a name='1342'>
<a name='1343'>
    <font color=#447700>! ---------------------------------------------------------------------------- !<a name='1344'></font>
    <font color=#447700>!                                                                              !<a name='1345'></font>
    <font color=#447700>! The University of Washington Moist Turbulence Scheme                         !<a name='1346'></font>
    <font color=#447700>!                                                                              !<a name='1347'></font>
    <font color=#447700>! Authors : Chris Bretherton at the University of Washington, Seattle, WA      ! <a name='1348'></font>
    <font color=#447700>!           Sungsu Park at the CGD/NCAR, Boulder, CO                           !<a name='1349'></font>
    <font color=#447700>!                                                                              !<a name='1350'></font>
    <font color=#447700>! ---------------------------------------------------------------------------- !<a name='1351'></font>
<a name='1352'>
<A NAME='CALEDDY'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='1353'>
    <font color=#993300>subroutine </font><font color=#cc0000>caleddy</font>( pcols        , pver         , ncol        ,                             &amp; <A href='../../call_to/CALEDDY.html' TARGET='index'>1</A>,<A href='../../call_from/CALEDDY.html' TARGET='index'>13</A><a name='1354'>
                        sl           , qt           , ql          , slv        , u            , &amp;<a name='1355'>
                        v            , pi           , z           , zi         ,                &amp;<a name='1356'>
                        qflx         , shflx        , slslope     , qtslope    ,                &amp;<a name='1357'>
                        chu          , chs          , cmu         , cms        , sfuh         , &amp;<a name='1358'>
                        sflh         , n2           , s2          , ri         , rrho         , &amp;<a name='1359'>
                        pblh         , ustar        ,                                           &amp;<a name='1360'>
                        kvh_in       , kvm_in       , kvh         , kvm        ,                &amp;<a name='1361'>
                        tpert        , qpert        , qrlin       , kvf        , tke          , &amp; <a name='1362'>
                        wstarent     , bprod        , sprod       , minpblh    , wpert        , &amp;<a name='1363'>
                        tkes         , turbtype_f   , sm_aw       ,                             &amp;<a name='1364'>
                        kbase_o      , ktop_o       , ncvfin_o    ,                             &amp; <a name='1365'>
                        kbase_mg     , ktop_mg      , ncvfin_mg   ,                             &amp; <a name='1366'>
                        kbase_f      , ktop_f       , ncvfin_f    ,                             &amp; <a name='1367'>
                        wet_CL       , web_CL       , jtbu_CL     , jbbu_CL    ,                &amp;<a name='1368'>
                        evhc_CL      , jt2slv_CL    , n2ht_CL     , n2hb_CL    , lwp_CL       , &amp;<a name='1369'>
                        opt_depth_CL , radinvfrac_CL, radf_CL     , wstar_CL   , wstar3fact_CL, &amp;<a name='1370'>
                        ebrk         , wbrk         , lbrk        , ricl       , ghcl         , &amp; <a name='1371'>
                        shcl         , smcl         ,                                           &amp;<a name='1372'>
                        gh_a         , sh_a         , sm_a        , ri_a       , leng         , &amp; <a name='1373'>
                        wcap         , pblhp        , cld         , ipbl       , kpblh        , &amp;<a name='1374'>
                        wsedl        )<a name='1375'>
<a name='1376'>
    <font color=#447700>!--------------------------------------------------------------------------------- !<a name='1377'></font>
    <font color=#447700>!                                                                                  !<a name='1378'></font>
    <font color=#447700>! Purpose : This is a driver routine to compute eddy diffusion coefficients        !<a name='1379'></font>
    <font color=#447700>!           for heat (sl), momentum (u, v), moisture (qt), and other  trace        !<a name='1380'></font>
    <font color=#447700>!           constituents.   This scheme uses first order closure for stable        !<a name='1381'></font>
    <font color=#447700>!           turbulent layers (STL). For convective layers (CL), entrainment        !<a name='1382'></font>
    <font color=#447700>!           closure is used at the CL external interfaces, which is coupled        !<a name='1383'></font>
    <font color=#447700>!           to the diagnosis of a CL regime mean TKE from the instantaneous        !<a name='1384'></font>
    <font color=#447700>!           thermodynamic and velocity profiles.   The CLs are diagnosed by        !<a name='1385'></font>
    <font color=#447700>!           extending original CL layers of moist static instability   into        !<a name='1386'></font>
    <font color=#447700>!           adjacent weakly stably stratified interfaces,   stopping if the        !<a name='1387'></font>
    <font color=#447700>!           stability is too strong.   This allows a realistic depiction of        !<a name='1388'></font>
    <font color=#447700>!           dry convective boundary layers with a downgradient approach.           !<a name='1389'></font>
    <font color=#447700>!                                                                                  !   <a name='1390'></font>
    <font color=#447700>! NOTE:     This routine currently assumes ntop_turb = 1, nbot_turb = pver         !<a name='1391'></font>
    <font color=#447700>!           ( turbulent diffusivities computed at all interior interfaces )        !<a name='1392'></font>
    <font color=#447700>!           and will require modification to handle a different ntop_turb.         ! <a name='1393'></font>
    <font color=#447700>!                                                                                  !<a name='1394'></font>
    <font color=#447700>! Authors:  Sungsu Park and Chris Bretherton. 08/2006, 05/2008.                    !<a name='1395'></font>
    <font color=#447700>!                                                                                  ! <a name='1396'></font>
    <font color=#447700>! For details, see                                                                 !<a name='1397'></font>
    <font color=#447700>!                                                                                  !<a name='1398'></font>
    <font color=#447700>! 1. 'A new moist turbulence parametrization in the Community Atmosphere Model'    !<a name='1399'></font>
    <font color=#447700>!     by Christopher S. Bretherton &amp; Sungsu Park. J. Climate. 22. 3422-3448. 2009. !<a name='1400'></font>
    <font color=#447700>!                                                                                  !<a name='1401'></font>
    <font color=#447700>! 2. 'The University of Washington shallow convection and moist turbulence schemes !<a name='1402'></font>
    <font color=#447700>!     and their impact on climate simulations with the Community Atmosphere Model' !<a name='1403'></font>
    <font color=#447700>!     by Sungsu Park &amp; Christopher S. Bretherton. J. Climate. 22. 3449-3469. 2009. !<a name='1404'></font>
    <font color=#447700>!                                                                                  !<a name='1405'></font>
    <font color=#447700>! For questions on the scheme and code, send an email to                           !<a name='1406'></font>
    <font color=#447700>!     sungsup@ucar.edu or breth@washington.edu                                     !<a name='1407'></font>
    <font color=#447700>!                                                                                  !<a name='1408'></font>
    <font color=#447700>!--------------------------------------------------------------------------------- !<a name='1409'></font>
<a name='1410'>
    <font color=#447700>! ---------------- !<a name='1411'></font>
    <font color=#447700>! Inputs variables !<a name='1412'></font>
    <font color=#447700>! ---------------- !<a name='1413'></font>
<a name='1414'>
    implicit none<a name='1415'>
<a name='1416'>
    integer,  intent(in) :: pcols                     <font color=#447700>! Number of atmospheric columns   <a name='1417'></font>
    integer,  intent(in) :: pver                      <font color=#447700>! Number of atmospheric layers   <a name='1418'></font>
    integer,  intent(in) :: ncol                      <font color=#447700>! Number of atmospheric columns   <a name='1419'></font>
    real(r8), intent(in) :: u(pcols,pver)             <font color=#447700>! U wind [ m/s ]<a name='1420'></font>
    real(r8), intent(in) :: v(pcols,pver)             <font color=#447700>! V wind [ m/s ]<a name='1421'></font>
    real(r8), intent(in) :: sl(pcols,pver)            <font color=#447700>! Liquid water static energy, cp * T + g * z - Lv * ql - Ls * qi [ J/kg ]<a name='1422'></font>
    real(r8), intent(in) :: slv(pcols,pver)           <font color=#447700>! Liquid water virtual static energy, sl * ( 1 + 0.608 * qt ) [ J/kg ]<a name='1423'></font>
    real(r8), intent(in) :: qt(pcols,pver)            <font color=#447700>! Total speccific humidity  qv + ql + qi [ kg/kg ] <a name='1424'></font>
    real(r8), intent(in) :: ql(pcols,pver)            <font color=#447700>! Liquid water specific humidity [ kg/kg ]<a name='1425'></font>
    real(r8), intent(in) :: pi(pcols,pver+1)          <font color=#447700>! Interface pressures [ Pa ]<a name='1426'></font>
    real(r8), intent(in) :: z(pcols,pver)             <font color=#447700>! Layer midpoint height above surface [ m ]<a name='1427'></font>
    real(r8), intent(in) :: zi(pcols,pver+1)          <font color=#447700>! Interface height above surface, i.e., zi(pver+1) = 0 all over the globe [ m ]<a name='1428'></font>
    real(r8), intent(in) :: chu(pcols,pver+1)         <font color=#447700>! Buoyancy coeffi. unsaturated sl (heat) coef. at all interfaces. [ unit ? ]<a name='1429'></font>
    real(r8), intent(in) :: chs(pcols,pver+1)         <font color=#447700>! Buoyancy coeffi. saturated sl (heat) coef. at all interfaces. [ unit ? ]<a name='1430'></font>
    real(r8), intent(in) :: cmu(pcols,pver+1)         <font color=#447700>! Buoyancy coeffi. unsaturated qt (moisture) coef. at all interfaces [ unit ? ]<a name='1431'></font>
    real(r8), intent(in) :: cms(pcols,pver+1)         <font color=#447700>! Buoyancy coeffi. saturated qt (moisture) coef. at all interfaces [ unit ? ]<a name='1432'></font>
    real(r8), intent(in) :: sfuh(pcols,pver)          <font color=#447700>! Saturation fraction in upper half-layer [ fraction ]<a name='1433'></font>
    real(r8), intent(in) :: sflh(pcols,pver)          <font color=#447700>! Saturation fraction in lower half-layer [ fraction ]<a name='1434'></font>
    real(r8), intent(in) :: n2(pcols,pver)            <font color=#447700>! Interfacial (except surface) moist buoyancy frequency [ s-2 ]<a name='1435'></font>
    real(r8), intent(in) :: s2(pcols,pver)            <font color=#447700>! Interfacial (except surface) shear frequency [ s-2 ]<a name='1436'></font>
    real(r8), intent(in) :: ri(pcols,pver)            <font color=#447700>! Interfacial (except surface) Richardson number<a name='1437'></font>
    real(r8), intent(in) :: qflx(pcols)               <font color=#447700>! Kinematic surface constituent ( water vapor ) flux [ kg/m2/s ]<a name='1438'></font>
    real(r8), intent(in) :: shflx(pcols)              <font color=#447700>! Kinematic surface heat flux [ unit ? ] <a name='1439'></font>
    real(r8), intent(in) :: slslope(pcols,pver)       <font color=#447700>! Slope of 'sl' in each layer [ J/kg/Pa ]<a name='1440'></font>
    real(r8), intent(in) :: qtslope(pcols,pver)       <font color=#447700>! Slope of 'qt' in each layer [ kg/kg/Pa ]<a name='1441'></font>
    real(r8), intent(in) :: qrlin(pcols,pver)         <font color=#447700>! Input grid-mean LW heating rate : [ K/s ] * cpair * dp = [ W/kg*Pa ]<a name='1442'></font>
    real(r8), intent(in) :: wsedl(pcols,pver)         <font color=#447700>! Sedimentation velocity of liquid stratus cloud droplet [ m/s ]<a name='1443'></font>
    real(r8), intent(in) :: ustar(pcols)              <font color=#447700>! Surface friction velocity [ m/s ]<a name='1444'></font>
    real(r8), intent(in) :: rrho(pcols)               <font color=#447700>! 1./bottom mid-point density. Specific volume [ m3/kg ]<a name='1445'></font>
    real(r8), intent(in) :: kvf(pcols,pver+1)         <font color=#447700>! Free atmosphere eddy diffusivity [ m2/s ]<a name='1446'></font>
    logical,  intent(in) :: wstarent                  <font color=#447700>! Switch for choosing wstar3 entrainment parameterization<a name='1447'></font>
    real(r8), intent(in) :: minpblh(pcols)            <font color=#447700>! Minimum PBL height based on surface stress [ m ]<a name='1448'></font>
    real(r8), intent(in) :: kvh_in(pcols,pver+1)      <font color=#447700>! kvh saved from last timestep or last iterative step [ m2/s ] <a name='1449'></font>
    real(r8), intent(in) :: kvm_in(pcols,pver+1)      <font color=#447700>! kvm saved from last timestep or last iterative step [ m2/s ]<a name='1450'></font>
    real(r8), intent(in) :: cld(pcols,pver)           <font color=#447700>! Stratus Cloud Fraction [ fraction ]<a name='1451'></font>
<a name='1452'>
    <font color=#447700>! ---------------- !<a name='1453'></font>
    <font color=#447700>! Output variables !<a name='1454'></font>
    <font color=#447700>! ---------------- !<a name='1455'></font>
<a name='1456'>
    real(r8), intent(out) :: kvh(pcols,pver+1)        <font color=#447700>! Eddy diffusivity for heat, moisture, and tracers [ m2/s ]<a name='1457'></font>
    real(r8), intent(out) :: kvm(pcols,pver+1)        <font color=#447700>! Eddy diffusivity for momentum [ m2/s ]<a name='1458'></font>
    real(r8), intent(out) :: pblh(pcols)              <font color=#447700>! PBL top height [ m ]<a name='1459'></font>
    real(r8), intent(out) :: pblhp(pcols)             <font color=#447700>! PBL top height pressure [ Pa ]<a name='1460'></font>
    real(r8), intent(out) :: tpert(pcols)             <font color=#447700>! Convective temperature excess [ K ]<a name='1461'></font>
    real(r8), intent(out) :: qpert(pcols)             <font color=#447700>! Convective humidity excess [ kg/kg ]<a name='1462'></font>
    real(r8), intent(out) :: wpert(pcols)             <font color=#447700>! Turbulent velocity excess [ m/s ]<a name='1463'></font>
    real(r8), intent(out) :: tke(pcols,pver+1)        <font color=#447700>! Turbulent kinetic energy [ m2/s2 ], 'tkes' at surface, pver+1.<a name='1464'></font>
    real(r8), intent(out) :: bprod(pcols,pver+1)      <font color=#447700>! Buoyancy production [ m2/s3 ],     'bflxs' at surface, pver+1.<a name='1465'></font>
    real(r8), intent(out) :: sprod(pcols,pver+1)      <font color=#447700>! Shear production [ m2/s3 ], (ustar(i)**3)/(vk*z(i,pver))  at surface, pver+1.<a name='1466'></font>
    real(r8), intent(out) :: turbtype_f(pcols,pver+1) <font color=#447700>! Turbulence type at each interface:<a name='1467'></font>
                                                      <font color=#447700>! 0. = Non turbulence interface<a name='1468'></font>
                                                      <font color=#447700>! 1. = Stable turbulence interface<a name='1469'></font>
                                                      <font color=#447700>! 2. = CL interior interface ( if bflxs &gt; 0, surface is this )<a name='1470'></font>
                                                      <font color=#447700>! 3. = Bottom external interface of CL<a name='1471'></font>
                                                      <font color=#447700>! 4. = Top external interface of CL.<a name='1472'></font>
                                                      <font color=#447700>! 5. = Double entraining CL external interface <a name='1473'></font>
    real(r8), intent(out) :: sm_aw(pcols,pver+1)      <font color=#447700>! Galperin instability function of momentum for use in the microphysics [ no unit ]<a name='1474'></font>
    real(r8), intent(out) :: ipbl(pcols)              <font color=#447700>! If 1, PBL is CL, while if 0, PBL is STL.<a name='1475'></font>
    real(r8), intent(out) :: kpblh(pcols)             <font color=#447700>! Layer index containing PBL within or at the base interface<a name='1476'></font>
<a name='1477'>
    <font color=#447700>! --------------------------- !<a name='1478'></font>
    <font color=#447700>! Diagnostic output variables !<a name='1479'></font>
    <font color=#447700>! --------------------------- !<a name='1480'></font>
<a name='1481'>
    real(r8) :: tkes(pcols)                           <font color=#447700>! TKE at surface [ m2/s2 ] <a name='1482'></font>
    real(r8) :: kbase_o(pcols,ncvmax)                 <font color=#447700>! Original external base interface index of CL just after 'exacol'<a name='1483'></font>
    real(r8) :: ktop_o(pcols,ncvmax)                  <font color=#447700>! Original external top  interface index of CL just after 'exacol'<a name='1484'></font>
    real(r8) :: ncvfin_o(pcols)                       <font color=#447700>! Original number of CLs just after 'exacol'<a name='1485'></font>
    real(r8) :: kbase_mg(pcols,ncvmax)                <font color=#447700>! kbase  just after extending-merging (after 'zisocl') but without SRCL<a name='1486'></font>
    real(r8) :: ktop_mg(pcols,ncvmax)                 <font color=#447700>! ktop   just after extending-merging (after 'zisocl') but without SRCL<a name='1487'></font>
    real(r8) :: ncvfin_mg(pcols)                      <font color=#447700>! ncvfin just after extending-merging (after 'zisocl') but without SRCL<a name='1488'></font>
    real(r8) :: kbase_f(pcols,ncvmax)                 <font color=#447700>! Final kbase  after adding SRCL<a name='1489'></font>
    real(r8) :: ktop_f(pcols,ncvmax)                  <font color=#447700>! Final ktop   after adding SRCL<a name='1490'></font>
    real(r8) :: ncvfin_f(pcols)                       <font color=#447700>! Final ncvfin after adding SRCL<a name='1491'></font>
    real(r8) :: wet_CL(pcols,ncvmax)                  <font color=#447700>! Entrainment rate at the CL top [ m/s ] <a name='1492'></font>
    real(r8) :: web_CL(pcols,ncvmax)                  <font color=#447700>! Entrainment rate at the CL base [ m/s ]<a name='1493'></font>
    real(r8) :: jtbu_CL(pcols,ncvmax)                 <font color=#447700>! Buoyancy jump across the CL top [ m/s2 ]  <a name='1494'></font>
    real(r8) :: jbbu_CL(pcols,ncvmax)                 <font color=#447700>! Buoyancy jump across the CL base [ m/s2 ]  <a name='1495'></font>
    real(r8) :: evhc_CL(pcols,ncvmax)                 <font color=#447700>! Evaporative enhancement factor at the CL top<a name='1496'></font>
    real(r8) :: jt2slv_CL(pcols,ncvmax)               <font color=#447700>! Jump of slv ( across two layers ) at CL top for use only in evhc [ J/kg ]<a name='1497'></font>
    real(r8) :: n2ht_CL(pcols,ncvmax)                 <font color=#447700>! n2 defined at the CL top  interface but using sfuh(kt)   instead of sfi(kt) [ s-2 ]<a name='1498'></font>
    real(r8) :: n2hb_CL(pcols,ncvmax)                 <font color=#447700>! n2 defined at the CL base interface but using sflh(kb-1) instead of sfi(kb) [ s-2 ]<a name='1499'></font>
    real(r8) :: lwp_CL(pcols,ncvmax)                  <font color=#447700>! LWP in the CL top layer [ kg/m2 ]<a name='1500'></font>
    real(r8) :: opt_depth_CL(pcols,ncvmax)            <font color=#447700>! Optical depth of the CL top layer<a name='1501'></font>
    real(r8) :: radinvfrac_CL(pcols,ncvmax)           <font color=#447700>! Fraction of LW radiative cooling confined in the top portion of CL<a name='1502'></font>
    real(r8) :: radf_CL(pcols,ncvmax)                 <font color=#447700>! Buoyancy production at the CL top due to radiative cooling [ m2/s3 ]<a name='1503'></font>
    real(r8) :: wstar_CL(pcols,ncvmax)                <font color=#447700>! Convective velocity of CL including entrainment contribution finally [ m/s ]<a name='1504'></font>
    real(r8) :: wstar3fact_CL(pcols,ncvmax)           <font color=#447700>! "wstar3fact" of CL. Entrainment enhancement of wstar3 (inverse)<a name='1505'></font>
<a name='1506'>
    real(r8) :: gh_a(pcols,pver+1)                    <font color=#447700>! Half of normalized buoyancy production, -l2n2/2e. [ no unit ]<a name='1507'></font>
    real(r8) :: sh_a(pcols,pver+1)                    <font color=#447700>! Galperin instability function of heat-moisture at all interfaces [ no unit ]<a name='1508'></font>
    real(r8) :: sm_a(pcols,pver+1)                    <font color=#447700>! Galperin instability function of momentum      at all interfaces [ no unit ]<a name='1509'></font>
    real(r8) :: ri_a(pcols,pver+1)                    <font color=#447700>! Interfacial Richardson number                  at all interfaces [ no unit ]<a name='1510'></font>
<a name='1511'>
    real(r8) :: ebrk(pcols,ncvmax)                    <font color=#447700>! Net CL mean TKE [ m2/s2 ]<a name='1512'></font>
    real(r8) :: wbrk(pcols,ncvmax)                    <font color=#447700>! Net CL mean normalized TKE [ m2/s2 ]<a name='1513'></font>
    real(r8) :: lbrk(pcols,ncvmax)                    <font color=#447700>! Net energetic integral thickness of CL [ m ]<a name='1514'></font>
    real(r8) :: ricl(pcols,ncvmax)                    <font color=#447700>! Mean Richardson number of CL ( l2n2/l2s2 )<a name='1515'></font>
    real(r8) :: ghcl(pcols,ncvmax)                    <font color=#447700>! Half of normalized buoyancy production of CL                 <a name='1516'></font>
    real(r8) :: shcl(pcols,ncvmax)                    <font color=#447700>! Instability function of heat and moisture of CL<a name='1517'></font>
    real(r8) :: smcl(pcols,ncvmax)                    <font color=#447700>! Instability function of momentum of CL<a name='1518'></font>
<a name='1519'>
    real(r8) :: leng(pcols,pver+1)                    <font color=#447700>! Turbulent length scale [ m ], 0 at the surface.<a name='1520'></font>
    real(r8) :: wcap(pcols,pver+1)                    <font color=#447700>! Normalized TKE [m2/s2], 'tkes/b1' at the surface and 'tke/b1' at<a name='1521'></font>
                                                      <font color=#447700>! the top/bottom entrainment interfaces of CL assuming no transport.<a name='1522'></font>
    <font color=#447700>! ------------------------ !<a name='1523'></font>
    <font color=#447700>! Local Internal Variables !<a name='1524'></font>
    <font color=#447700>! ------------------------ !<a name='1525'></font>
<a name='1526'>
    logical :: belongcv(pcols,pver+1)                 <font color=#447700>! True for interfaces in a CL (both interior and exterior are included)<a name='1527'></font>
    logical :: belongst(pcols,pver+1)                 <font color=#447700>! True for stable turbulent layer interfaces (STL)<a name='1528'></font>
    logical :: in_CL                                  <font color=#447700>! True if interfaces k,k+1 both in same CL.<a name='1529'></font>
    logical :: extend                                 <font color=#447700>! True when CL is extended in zisocl<a name='1530'></font>
    logical :: extend_up                              <font color=#447700>! True when CL is extended upward in zisocl<a name='1531'></font>
    logical :: extend_dn                              <font color=#447700>! True when CL is extended downward in zisocl<a name='1532'></font>
<a name='1533'>
    integer :: i                                      <font color=#447700>! Longitude index<a name='1534'></font>
    integer :: k                                      <font color=#447700>! Vertical index<a name='1535'></font>
    integer :: ks                                     <font color=#447700>! Vertical index<a name='1536'></font>
    integer :: ncvfin(pcols)                          <font color=#447700>! Total number of CL in column<a name='1537'></font>
    integer :: ncvf                                   <font color=#447700>! Total number of CL in column prior to adding SRCL<a name='1538'></font>
    integer :: ncv                                    <font color=#447700>! Index of current CL<a name='1539'></font>
    integer :: ncvnew                                 <font color=#447700>! Index of added SRCL appended after regular CLs from 'zisocl'<a name='1540'></font>
    integer :: ncvsurf                                <font color=#447700>! If nonzero, CL index based on surface (usually 1, but can be &gt; 1 when SRCL is based at sfc)<a name='1541'></font>
    integer :: kbase(pcols,ncvmax)                    <font color=#447700>! Vertical index of CL base interface<a name='1542'></font>
    integer :: ktop(pcols,ncvmax)                     <font color=#447700>! Vertical index of CL top interface<a name='1543'></font>
    integer :: kb, kt                                 <font color=#447700>! kbase and ktop for current CL<a name='1544'></font>
    integer :: ktblw                                  <font color=#447700>! ktop of the CL located at just below the current CL<a name='1545'></font>
    integer :: turbtype(pcols,pver+1)                 <font color=#447700>! Interface turbulence type :<a name='1546'></font>
                                                      <font color=#447700>! 0 = Non turbulence interface<a name='1547'></font>
                                                      <font color=#447700>! 1 = Stable turbulence interface<a name='1548'></font>
                                                      <font color=#447700>! 2 = CL interior interface ( if bflxs &gt; 0, sfc is this )<a name='1549'></font>
                                                      <font color=#447700>! 3 = Bottom external interface of CL<a name='1550'></font>
                                                      <font color=#447700>! 4 = Top external interface of CL<a name='1551'></font>
                                                      <font color=#447700>! 5 = Double entraining CL external interface<a name='1552'></font>
    integer  :: ktopbl(pcols)                         <font color=#447700>! PBL top height or interface index <a name='1553'></font>
    real(r8) :: bflxs(pcols)                          <font color=#447700>! Surface buoyancy flux [ m2/s3 ]<a name='1554'></font>
    real(r8) :: rcap                                  <font color=#447700>! 'tke/ebrk' at all interfaces of CL. Set to 1 at the CL entrainment interfaces<a name='1555'></font>
    real(r8) :: jtzm                                  <font color=#447700>! Interface layer thickness of CL top interface [ m ]<a name='1556'></font>
    real(r8) :: jtsl                                  <font color=#447700>! Jump of s_l across CL top interface [ J/kg ]<a name='1557'></font>
    real(r8) :: jtqt                                  <font color=#447700>! Jump of q_t across CL top interface [ kg/kg ]<a name='1558'></font>
    real(r8) :: jtbu                                  <font color=#447700>! Jump of buoyancy across CL top interface [ m/s2 ]<a name='1559'></font>
    real(r8) :: jtu                                   <font color=#447700>! Jump of u across CL top interface [ m/s ]<a name='1560'></font>
    real(r8) :: jtv                                   <font color=#447700>! Jump of v across CL top interface [ m/s ]<a name='1561'></font>
    real(r8) :: jt2slv                                <font color=#447700>! Jump of slv ( across two layers ) at CL top for use only in evhc [ J/kg ]<a name='1562'></font>
    real(r8) :: radf                                  <font color=#447700>! Buoyancy production at the CL top due to radiative cooling [ m2/s3 ]<a name='1563'></font>
    real(r8) :: jbzm                                  <font color=#447700>! Interface layer thickness of CL base interface [ m ]<a name='1564'></font>
    real(r8) :: jbsl                                  <font color=#447700>! Jump of s_l across CL base interface [ J/kg ]<a name='1565'></font>
    real(r8) :: jbqt                                  <font color=#447700>! Jump of q_t across CL top interface [ kg/kg ]<a name='1566'></font>
    real(r8) :: jbbu                                  <font color=#447700>! Jump of buoyancy across CL base interface [ m/s2 ]<a name='1567'></font>
    real(r8) :: jbu                                   <font color=#447700>! Jump of u across CL base interface [ m/s ]<a name='1568'></font>
    real(r8) :: jbv                                   <font color=#447700>! Jump of v across CL base interface [ m/s ]<a name='1569'></font>
    real(r8) :: ch                                    <font color=#447700>! Buoyancy coefficients defined at the CL top and base interfaces using CL internal<a name='1570'></font>
    real(r8) :: cm                                    <font color=#447700>! sfuh(kt) and sflh(kb-1) instead of sfi(kt) and sfi(kb), respectively. These are <a name='1571'></font>
                                                      <font color=#447700>! used for entrainment calculation at CL external interfaces and SRCL identification.<a name='1572'></font>
    real(r8) :: n2ht                                  <font color=#447700>! n2 defined at the CL top  interface but using sfuh(kt)   instead of sfi(kt) [ s-2 ]<a name='1573'></font>
    real(r8) :: n2hb                                  <font color=#447700>! n2 defined at the CL base interface but using sflh(kb-1) instead of sfi(kb) [ s-2 ]<a name='1574'></font>
    real(r8) :: n2htSRCL                              <font color=#447700>! n2 defined at the upper-half layer of SRCL. This is used only for identifying SRCL.<a name='1575'></font>
                                                      <font color=#447700>! n2htSRCL use SRCL internal slope sl and qt as well as sfuh(kt) instead of sfi(kt) [ s-2 ]<a name='1576'></font>
    real(r8) :: gh                                    <font color=#447700>! Half of normalized buoyancy production ( -l2n2/2e ) [ no unit ]<a name='1577'></font>
    real(r8) :: sh                                    <font color=#447700>! Galperin instability function for heat and moisture<a name='1578'></font>
    real(r8) :: sm                                    <font color=#447700>! Galperin instability function for momentum<a name='1579'></font>
    real(r8) :: lbulk                                 <font color=#447700>! Depth of turbulent layer, Master length scale (not energetic length)<a name='1580'></font>
    real(r8) :: dzht                                  <font color=#447700>! Thickness of top    half-layer [ m ]<a name='1581'></font>
    real(r8) :: dzhb                                  <font color=#447700>! Thickness of bottom half-layer [ m ]<a name='1582'></font>
    real(r8) :: rootp                                 <font color=#447700>! Sqrt(net CL-mean TKE including entrainment contribution) [ m/s ]     <a name='1583'></font>
    real(r8) :: evhc                                  <font color=#447700>! Evaporative enhancement factor: (1+E) with E = evap. cool. efficiency [ no unit ]<a name='1584'></font>
    real(r8) :: kentr                                 <font color=#447700>! Effective entrainment diffusivity 'wet*dz', 'web*dz' [ m2/s ]<a name='1585'></font>
    real(r8) :: lwp                                   <font color=#447700>! Liquid water path in the layer kt [ kg/m2 ]<a name='1586'></font>
    real(r8) :: opt_depth                             <font color=#447700>! Optical depth of the layer kt [ no unit ]<a name='1587'></font>
    real(r8) :: radinvfrac                            <font color=#447700>! Fraction of LW cooling in the layer kt concentrated at the CL top [ no unit ]<a name='1588'></font>
    real(r8) :: wet                                   <font color=#447700>! CL top entrainment rate [ m/s ]<a name='1589'></font>
    real(r8) :: web                                   <font color=#447700>! CL bot entrainment rate [ m/s ]. Set to zero if CL is based at surface.<a name='1590'></font>
    real(r8) :: vyt                                   <font color=#447700>! n2ht/n2 at the CL top  interface<a name='1591'></font>
    real(r8) :: vyb                                   <font color=#447700>! n2hb/n2 at the CL base interface<a name='1592'></font>
    real(r8) :: vut                                   <font color=#447700>! Inverse Ri (=s2/n2) at the CL top  interface<a name='1593'></font>
    real(r8) :: vub                                   <font color=#447700>! Inverse Ri (=s2/n2) at the CL base interface<a name='1594'></font>
    real(r8) :: fact                                  <font color=#447700>! Factor relating TKE generation to entrainment [ no unit ]<a name='1595'></font>
    real(r8) :: trma                                  <font color=#447700>! Intermediate variables used for solving quadratic ( for gh from ri )<a name='1596'></font>
    real(r8) :: trmb                                  <font color=#447700>! and cubic equations ( for ebrk: the net CL mean TKE )<a name='1597'></font>
    real(r8) :: trmc                                  <font color=#447700>!<a name='1598'></font>
    real(r8) :: trmp                                  <font color=#447700>!<a name='1599'></font>
    real(r8) :: trmq                                  <font color=#447700>!<a name='1600'></font>
    real(r8) :: qq                                    <font color=#447700>! <a name='1601'></font>
    real(r8) :: det                                   <font color=#447700>!<a name='1602'></font>
    real(r8) :: gg                                    <font color=#447700>! Intermediate variable used for calculating stability functions of<a name='1603'></font>
                                                      <font color=#447700>! SRCL or SBCL based at the surface with bflxs &gt; 0.<a name='1604'></font>
    real(r8) :: dzhb5                                 <font color=#447700>! Half thickness of the bottom-most layer of current CL regime<a name='1605'></font>
    real(r8) :: dzht5                                 <font color=#447700>! Half thickness of the top-most layer of adjacent CL regime just below current CL<a name='1606'></font>
    real(r8) :: qrlw(pcols,pver)                      <font color=#447700>! Local grid-mean LW heating rate : [K/s] * cpair * dp = [ W/kg*Pa ]<a name='1607'></font>
<a name='1608'>
    real(r8) :: cldeff(pcols,pver)                    <font color=#447700>! Effective stratus fraction<a name='1609'></font>
    real(r8) :: qleff                                 <font color=#447700>! Used for computing evhc<a name='1610'></font>
    real(r8) :: tunlramp                              <font color=#447700>! Ramping tunl<a name='1611'></font>
    real(r8) :: leng_imsi                             <font color=#447700>! For Kv = max(Kv_STL, Kv_entrain)<a name='1612'></font>
    real(r8) :: tke_imsi                              <font color=#447700>!<a name='1613'></font>
    real(r8) :: kvh_imsi                              <font color=#447700>!<a name='1614'></font>
    real(r8) :: kvm_imsi                              <font color=#447700>!<a name='1615'></font>
    real(r8) :: alph4exs                              <font color=#447700>! For extended stability function in the stable regime<a name='1616'></font>
    real(r8) :: ghmin                                 <font color=#447700>!   <a name='1617'></font>
<a name='1618'>
    real(r8) :: sedfact                               <font color=#447700>! For 'sedimentation-entrainment feedback' <a name='1619'></font>
<a name='1620'>
    <font color=#447700>! Local variables specific for 'wstar' entrainment closure<a name='1621'></font>
<a name='1622'>
    real(r8) :: cet                                   <font color=#447700>! Proportionality coefficient between wet and wstar3<a name='1623'></font>
    real(r8) :: ceb                                   <font color=#447700>! Proportionality coefficient between web and wstar3<a name='1624'></font>
    real(r8) :: wstar                                 <font color=#447700>! Convective velocity for CL [ m/s ]<a name='1625'></font>
    real(r8) :: wstar3                                <font color=#447700>! Cubed convective velocity for CL [ m3/s3 ]<a name='1626'></font>
    real(r8) :: wstar3fact                            <font color=#447700>! 1/(relative change of wstar^3 by entrainment)<a name='1627'></font>
    real(r8) :: rmin                                  <font color=#447700>! sqrt(p)<a name='1628'></font>
    real(r8) :: fmin                                  <font color=#447700>! f(rmin), where f(r) = r^3 - 3*p*r - 2q<a name='1629'></font>
    real(r8) :: rcrit                                 <font color=#447700>! ccrit*wstar<a name='1630'></font>
    real(r8) :: fcrit                                 <font color=#447700>! f(rcrit)<a name='1631'></font>
    logical     noroot                                <font color=#447700>! True if f(r) has no root r &gt; rcrit<a name='1632'></font>
<a name='1633'>
    <font color=#447700>!-----------------------!<a name='1634'></font>
    <font color=#447700>! Start of Main Program !<a name='1635'></font>
    <font color=#447700>!-----------------------!<a name='1636'></font>
    <a name='1637'>
    <font color=#447700>! Option: Turn-off LW radiative-turbulence interaction in PBL scheme<a name='1638'></font>
    <font color=#447700>!         by setting qrlw = 0.  Logical parameter 'set_qrlzero'  was<a name='1639'></font>
    <font color=#447700>!         defined in the first part of 'eddy_diff.F90' module. <a name='1640'></font>
<a name='1641'>
    if( set_qrlzero ) then<a name='1642'>
        qrlw(:,:) = 0._r8<a name='1643'>
    else<a name='1644'>
        qrlw(:ncol,:pver) = qrlin(:ncol,:pver)<a name='1645'>
    endif<a name='1646'>
<a name='1647'>
    <font color=#447700>! Define effective stratus fraction using the grid-mean ql.<a name='1648'></font>
    <font color=#447700>! Modification : The contribution of ice should be carefully considered.<a name='1649'></font>
    <font color=#447700>!                This should be done in combination with the 'qrlw' and<a name='1650'></font>
    <font color=#447700>!                overlapping assumption of liquid and ice stratus. <a name='1651'></font>
<a name='1652'>
    do k = 1, pver<a name='1653'>
       do i = 1, ncol<a name='1654'>
          if( choice_evhc .eq. 'ramp' .or. choice_radf .eq. 'ramp' ) then <a name='1655'>
              cldeff(i,k) = cld(i,k) * min( ql(i,k) / qmin, 1._r8 )<a name='1656'>
          else<a name='1657'>
              cldeff(i,k) = cld(i,k)<a name='1658'>
          endif<a name='1659'>
       end do<a name='1660'>
    end do<a name='1661'>
<a name='1662'>
    <font color=#447700>! For an extended stability function in the stable regime, re-define<a name='1663'></font>
    <font color=#447700>! alph4exe and ghmin. This is for future work.<a name='1664'></font>
<a name='1665'>
    if( ricrit .eq. 0.19_r8 ) then<a name='1666'>
        alph4exs = alph4<a name='1667'>
        ghmin    = -3.5334_r8<a name='1668'>
    elseif( ricrit .gt. 0.19_r8 ) then<a name='1669'>
        alph4exs = -2._r8 * b1 * alph2 / ( alph3 - 2._r8 * b1 * alph5 ) / ricrit<a name='1670'>
        ghmin    = -1.e10_r8<a name='1671'>
    else<a name='1672'>
        write(iulog,*) 'Error : ricrit should be larger than 0.19 in UW PBL'       <a name='1673'>
#ifdef WRF_PORT<a name='1674'>
        call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_543">(iulog)<a name='1675'>
#endif <a name='1676'>
        stop<a name='1677'>
    endif<a name='1678'>
<a name='1679'>
    <font color=#447700>!<a name='1680'></font>
    <font color=#447700>! Initialization of Diagnostic Output<a name='1681'></font>
    <font color=#447700>!<a name='1682'></font>
<a name='1683'>
    do i = 1, ncol<a name='1684'>
       wet_CL(i,:ncvmax)        = 0._r8<a name='1685'>
       web_CL(i,:ncvmax)        = 0._r8<a name='1686'>
       jtbu_CL(i,:ncvmax)       = 0._r8<a name='1687'>
       jbbu_CL(i,:ncvmax)       = 0._r8<a name='1688'>
       evhc_CL(i,:ncvmax)       = 0._r8<a name='1689'>
       jt2slv_CL(i,:ncvmax)     = 0._r8<a name='1690'>
       n2ht_CL(i,:ncvmax)       = 0._r8<a name='1691'>
       n2hb_CL(i,:ncvmax)       = 0._r8                    <a name='1692'>
       lwp_CL(i,:ncvmax)        = 0._r8<a name='1693'>
       opt_depth_CL(i,:ncvmax)  = 0._r8<a name='1694'>
       radinvfrac_CL(i,:ncvmax) = 0._r8<a name='1695'>
       radf_CL(i,:ncvmax)       = 0._r8<a name='1696'>
       wstar_CL(i,:ncvmax)      = 0._r8          <a name='1697'>
       wstar3fact_CL(i,:ncvmax) = 0._r8<a name='1698'>
       ricl(i,:ncvmax)          = 0._r8<a name='1699'>
       ghcl(i,:ncvmax)          = 0._r8<a name='1700'>
       shcl(i,:ncvmax)          = 0._r8<a name='1701'>
       smcl(i,:ncvmax)          = 0._r8<a name='1702'>
       ebrk(i,:ncvmax)          = 0._r8<a name='1703'>
       wbrk(i,:ncvmax)          = 0._r8<a name='1704'>
       lbrk(i,:ncvmax)          = 0._r8<a name='1705'>
       gh_a(i,:pver+1)          = 0._r8<a name='1706'>
       sh_a(i,:pver+1)          = 0._r8<a name='1707'>
       sm_a(i,:pver+1)          = 0._r8<a name='1708'>
       ri_a(i,:pver+1)          = 0._r8<a name='1709'>
       sm_aw(i,:pver+1)         = 0._r8<a name='1710'>
       ipbl(i)                  = 0._r8<a name='1711'>
       kpblh(i)                 = real(pver,r8)<a name='1712'>
    end do  <a name='1713'>
<a name='1714'>
    <font color=#447700>! kvh and kvm are stored over timesteps in 'vertical_diffusion.F90' and <a name='1715'></font>
    <font color=#447700>! passed in as kvh_in and kvm_in.  However,  at the first timestep they<a name='1716'></font>
    <font color=#447700>! need to be computed and these are done just before calling 'caleddy'.   <a name='1717'></font>
    <font color=#447700>! kvm and kvh are also stored over iterative time step in the first part<a name='1718'></font>
    <font color=#447700>! of 'eddy_diff.F90'<a name='1719'></font>
<a name='1720'>
    do k = 1, pver + 1<a name='1721'>
       do i = 1, ncol<a name='1722'>
        <font color=#447700>! Initialize kvh and kvm to zero or kvf<a name='1723'></font>
          if( use_kvf ) then<a name='1724'>
              kvh(i,k) = kvf(i,k)<a name='1725'>
              kvm(i,k) = kvf(i,k)<a name='1726'>
          else<a name='1727'>
              kvh(i,k) = 0._r8<a name='1728'>
              kvm(i,k) = 0._r8<a name='1729'>
          end if<a name='1730'>
        <font color=#447700>! Zero diagnostic quantities for the new diffusion step.<a name='1731'></font>
          wcap(i,k) = 0._r8<a name='1732'>
          leng(i,k) = 0._r8<a name='1733'>
          tke(i,k)  = 0._r8<a name='1734'>
          turbtype(i,k) = 0<a name='1735'>
       end do<a name='1736'>
    end do<a name='1737'>
<a name='1738'>
    <font color=#447700>! Initialize 'bprod' [ m2/s3 ] and 'sprod' [ m2/s3 ] at all interfaces.<a name='1739'></font>
    <font color=#447700>! Note this initialization is a hybrid initialization since 'n2' [s-2] and 's2' [s-2]<a name='1740'></font>
    <font color=#447700>! are calculated from the given current initial profile, while 'kvh_in' [m2/s] and <a name='1741'></font>
    <font color=#447700>! 'kvm_in' [m2/s] are from the previous iteration or previous time step.<a name='1742'></font>
    <font color=#447700>! This initially guessed 'bprod' and 'sprod' will be updated at the end of this <a name='1743'></font>
    <font color=#447700>! 'caleddy' subroutine for diagnostic output.<a name='1744'></font>
    <font color=#447700>! This computation of 'brpod,sprod' below is necessary for wstar-based entrainment closure.<a name='1745'></font>
<a name='1746'>
    do k = 2, pver<a name='1747'>
       do i = 1, ncol<a name='1748'>
            bprod(i,k) = -kvh_in(i,k) * n2(i,k)<a name='1749'>
            sprod(i,k) =  kvm_in(i,k) * s2(i,k)<a name='1750'>
       end do<a name='1751'>
    end do<a name='1752'>
<a name='1753'>
    <font color=#447700>! Set 'bprod' and 'sprod' at top and bottom interface.<a name='1754'></font>
    <font color=#447700>! In calculating 'surface' (actually lowest half-layer) buoyancy flux,<a name='1755'></font>
    <font color=#447700>! 'chu' at surface is defined to be the same as 'chu' at the mid-point<a name='1756'></font>
    <font color=#447700>! of lowest model layer (pver) at the end of 'trbind'. The same is for<a name='1757'></font>
    <font color=#447700>! the other buoyancy coefficients.  'sprod(i,pver+1)'  is defined in a<a name='1758'></font>
    <font color=#447700>! consistent way as the definition of 'tkes' in the original code.<a name='1759'></font>
    <font color=#447700>! ( Important Option ) If I want to isolate surface buoyancy flux from<a name='1760'></font>
    <font color=#447700>! the other parts of CL regimes energetically even though bflxs &gt; 0,<a name='1761'></font>
    <font color=#447700>! all I should do is to re-define 'bprod(i,pver+1)=0' in the below 'do'<a name='1762'></font>
    <font color=#447700>! block. Additionally for merging test of extending SBCL based on 'l2n2'<a name='1763'></font>
    <font color=#447700>! in 'zisocl', I should use 'l2n2 = - wint / sh'  for similar treatment<a name='1764'></font>
    <font color=#447700>! as previous code. All other parts of the code  are fully consistently<a name='1765'></font>
    <font color=#447700>! treated by these change only.<a name='1766'></font>
    <font color=#447700>! My future general convection scheme will use bflxs(i).<a name='1767'></font>
<a name='1768'>
    do i = 1, ncol<a name='1769'>
       bprod(i,1) = 0._r8 <font color=#447700>! Top interface<a name='1770'></font>
       sprod(i,1) = 0._r8 <font color=#447700>! Top interface<a name='1771'></font>
       ch = chu(i,pver+1) * ( 1._r8 - sflh(i,pver) ) + chs(i,pver+1) * sflh(i,pver)   <a name='1772'>
       cm = cmu(i,pver+1) * ( 1._r8 - sflh(i,pver) ) + cms(i,pver+1) * sflh(i,pver)   <a name='1773'>
       bflxs(i) = ch * shflx(i) * rrho(i) + cm * qflx(i) * rrho(i)<a name='1774'>
       if( choice_tkes .eq. 'ibprod' ) then<a name='1775'>
           bprod(i,pver+1) = bflxs(i)<a name='1776'>
       else<a name='1777'>
           bprod(i,pver+1) = 0._r8<a name='1778'>
       endif<a name='1779'>
       sprod(i,pver+1) = (ustar(i)**3)/(vk*z(i,pver))<a name='1780'>
    end do<a name='1781'>
<a name='1782'>
    <font color=#447700>! Initially identify CL regimes in 'exacol'<a name='1783'></font>
    <font color=#447700>!    ktop  : Interface index of the CL top  external interface<a name='1784'></font>
    <font color=#447700>!    kbase : Interface index of the CL base external interface<a name='1785'></font>
    <font color=#447700>!    ncvfin: Number of total CLs<a name='1786'></font>
    <font color=#447700>! Note that if surface buoyancy flux is positive ( bflxs = bprod(i,pver+1) &gt; 0 ),<a name='1787'></font>
    <font color=#447700>! surface interface is identified as an internal interface of CL. However, even<a name='1788'></font>
    <font color=#447700>! though bflxs &lt;= 0, if 'pver' interface is a CL internal interface (ri(pver)&lt;0),<a name='1789'></font>
    <font color=#447700>! surface interface is identified as an external interface of CL. If bflxs =&lt; 0 <a name='1790'></font>
    <font color=#447700>! and ri(pver) &gt;= 0, then surface interface is identified as a stable turbulent<a name='1791'></font>
    <font color=#447700>! intereface (STL) as shown at the end of 'caleddy'. Even though a 'minpblh' is<a name='1792'></font>
    <font color=#447700>! passed into 'exacol', it is not used in the 'exacol'.<a name='1793'></font>
<a name='1794'>
    call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#EXACOL'>exacol</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="EXACOL_1">( pcols, pver, ncol, ri, bflxs, minpblh, zi, ktop, kbase, ncvfin )<a name='1795'>
<a name='1796'>
    <font color=#447700>! Diagnostic output of CL interface indices before performing 'extending-merging'<a name='1797'></font>
    <font color=#447700>! of CL regimes in 'zisocl'<a name='1798'></font>
    do i = 1, ncol<a name='1799'>
    do k = 1, ncvmax<a name='1800'>
       kbase_o(i,k) = real(kbase(i,k),r8)<a name='1801'>
       ktop_o(i,k)  = real(ktop(i,k),r8) <a name='1802'>
       ncvfin_o(i)  = real(ncvfin(i),r8)<a name='1803'>
    end do<a name='1804'>
    end do <a name='1805'>
<a name='1806'>
    <font color=#447700>! ----------------------------------- !<a name='1807'></font>
    <font color=#447700>! Perform calculation for each column !<a name='1808'></font>
    <font color=#447700>! ----------------------------------- !<a name='1809'></font>
<a name='1810'>
    do i = 1, ncol<a name='1811'>
<a name='1812'>
       <font color=#447700>! Define Surface Interfacial Layer TKE, 'tkes'.<a name='1813'></font>
       <font color=#447700>! In the current code, 'tkes' is used as representing TKE of surface interfacial<a name='1814'></font>
       <font color=#447700>! layer (low half-layer of surface-based grid layer). In the code, when bflxs&gt;0,<a name='1815'></font>
       <font color=#447700>! surface interfacial layer is assumed to be energetically  coupled to the other<a name='1816'></font>
       <font color=#447700>! parts of the CL regime based at the surface. In this sense, it is conceptually<a name='1817'></font>
       <font color=#447700>! more reasonable to include both 'bprod' and 'sprod' in the definition of 'tkes'.<a name='1818'></font>
       <font color=#447700>! Since 'tkes' cannot be negative, it is lower bounded by small positive number. <a name='1819'></font>
       <font color=#447700>! Note that inclusion of 'bprod' in the definition of 'tkes' may increase 'ebrk'<a name='1820'></font>
       <font color=#447700>! and 'wstar3', and eventually, 'wet' at the CL top, especially when 'bflxs&gt;0'.<a name='1821'></font>
       <font color=#447700>! This might help to solve the problem of too shallow PBLH over the overcast Sc<a name='1822'></font>
       <font color=#447700>! regime. If I want to exclude 'bprod(i,pver+1)' in calculating 'tkes' even when<a name='1823'></font>
       <font color=#447700>! bflxs &gt; 0, all I should to do is to set 'bprod(i,pver+1) = 0' in the above <a name='1824'></font>
       <font color=#447700>! initialization 'do' loop (explained above), NOT changing the formulation of<a name='1825'></font>
       <font color=#447700>! tkes(i) in the below block. This is because for consistent treatment in the <a name='1826'></font>
       <font color=#447700>! other parts of the code also.<a name='1827'></font>
  <a name='1828'>
     <font color=#447700>! tkes(i) = (b1*vk*z(i,pver)*sprod(i,pver+1))**(2._r8/3._r8)<a name='1829'></font>
       tkes(i) = max(b1*vk*z(i,pver)*(bprod(i,pver+1)+sprod(i,pver+1)), 1.e-7_r8)**(2._r8/3._r8)<a name='1830'>
       tkes(i) = min(tkes(i), tkemax)<a name='1831'>
       tke(i,pver+1)  = tkes(i)<a name='1832'>
       wcap(i,pver+1) = tkes(i)/b1<a name='1833'>
<a name='1834'>
       <font color=#447700>! Extend and merge the initially identified CLs, relabel the CLs, and calculate<a name='1835'></font>
       <font color=#447700>! CL internal mean energetics and stability functions in 'zisocl'. <a name='1836'></font>
       <font color=#447700>! The CL nearest to the surface is CL(1) and the CL index, ncv, increases <a name='1837'></font>
       <font color=#447700>! with height. The following outputs are from 'zisocl'. Here, the dimension<a name='1838'></font>
       <font color=#447700>! of below outputs are (pcols,ncvmax) (except the 'ncvfin(pcols)' and <a name='1839'></font>
       <font color=#447700>! 'belongcv(pcols,pver+1)) and 'ncv' goes from 1 to 'ncvfin'. <a name='1840'></font>
       <font color=#447700>! For 'ncv = ncvfin+1, ncvmax', below output are already initialized to be zero. <a name='1841'></font>
       <font color=#447700>!      ncvfin       : Total number of CLs<a name='1842'></font>
       <font color=#447700>!      kbase(ncv)   : Base external interface index of CL<a name='1843'></font>
       <font color=#447700>!      ktop         : Top  external interface index of CL<a name='1844'></font>
       <font color=#447700>!      belongcv     : True if the interface (either internal or external) is CL  <a name='1845'></font>
       <font color=#447700>!      ricl         : Mean Richardson number of internal CL<a name='1846'></font>
       <font color=#447700>!      ghcl         : Normalized buoyancy production '-l2n2/2e' [no unit] of internal CL<a name='1847'></font>
       <font color=#447700>!      shcl         : Galperin instability function of heat-moisture of internal CL<a name='1848'></font>
       <font color=#447700>!      smcl         : Galperin instability function of momentum of internal CL<a name='1849'></font>
       <font color=#447700>!      lbrk, &lt;l&gt;int : Thickness of (energetically) internal CL (lint, [m])<a name='1850'></font>
       <font color=#447700>!      wbrk, &lt;W&gt;int : Mean normalized TKE of internal CL  ([m2/s2])<a name='1851'></font>
       <font color=#447700>!      ebrk, &lt;e&gt;int : Mean TKE of internal CL (b1*wbrk,[m2/s2])<a name='1852'></font>
       <font color=#447700>! The ncvsurf is an identifier saying which CL regime is based at the surface.<a name='1853'></font>
       <font color=#447700>! If 'ncvsurf=1', then the first CL regime is based at the surface. If surface<a name='1854'></font>
       <font color=#447700>! interface is not a part of CL (neither internal nor external), 'ncvsurf = 0'.<a name='1855'></font>
       <font color=#447700>! After identifying and including SRCLs into the normal CL regimes (where newly<a name='1856'></font>
       <font color=#447700>! identified SRCLs are simply appended to the normal CL regimes using regime <a name='1857'></font>
       <font color=#447700>! indices of 'ncvfin+1','ncvfin+2' (as will be shown in the below SRCL part),..<a name='1858'></font>
       <font color=#447700>! where 'ncvfin' is the final CL regime index produced after extending-merging <a name='1859'></font>
       <font color=#447700>! in 'zisocl' but before adding SRCLs), if any newly identified SRCL (e.g., <a name='1860'></font>
       <font color=#447700>! 'ncvfin+1') is based at surface, then 'ncvsurf = ncvfin+1'. Thus 'ncvsurf' can<a name='1861'></font>
       <font color=#447700>! be 0, 1, or &gt;1. 'ncvsurf' can be a useful diagnostic output.   <a name='1862'></font>
<a name='1863'>
       ncvsurf = 0<a name='1864'>
       if( ncvfin(i) .gt. 0 ) then <a name='1865'>
           call <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#ZISOCL'>zisocl</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="ZISOCL_1">( pcols  , pver     , i        ,           &amp;<a name='1866'>
                        z      , zi       , n2       , s2      , &amp; <a name='1867'>
                        bprod  , sprod    , bflxs    , tkes    , &amp;<a name='1868'>
                        ncvfin , kbase    , ktop     , belongcv, &amp;<a name='1869'>
                        ricl   , ghcl     , shcl     , smcl    , &amp; <a name='1870'>
                        lbrk   , wbrk     , ebrk     ,           &amp; <a name='1871'>
                        extend , extend_up, extend_dn )<a name='1872'>
           if( kbase(i,1) .eq. pver + 1 ) ncvsurf = 1<a name='1873'>
       else<a name='1874'>
           belongcv(i,:) = .false.<a name='1875'>
       endif<a name='1876'>
<a name='1877'>
       <font color=#447700>! Diagnostic output after finishing extending-merging process in 'zisocl'<a name='1878'></font>
       <font color=#447700>! Since we are adding SRCL additionally, we need to print out these here.<a name='1879'></font>
<a name='1880'>
       do k = 1, ncvmax<a name='1881'>
          kbase_mg(i,k) = real(kbase(i,k))<a name='1882'>
          ktop_mg(i,k)  = real(ktop(i,k)) <a name='1883'>
          ncvfin_mg(i)  = real(ncvfin(i))<a name='1884'>
       end do <a name='1885'>
<a name='1886'>
       <font color=#447700>! ----------------------- !<a name='1887'></font>
       <font color=#447700>! Identification of SRCLs !<a name='1888'></font>
       <font color=#447700>! ----------------------- !<a name='1889'></font>
<a name='1890'>
     <font color=#447700>! Modification : This cannot identify the 'cirrus' layer due to the condition of<a name='1891'></font>
     <font color=#447700>!                ql(i,k) .gt. qmin. This should be modified in future to identify<a name='1892'></font>
     <font color=#447700>!                a single thin cirrus layer.  <a name='1893'></font>
     <font color=#447700>!                Instead of ql, we may use cldn in future, including ice <a name='1894'></font>
     <font color=#447700>!                contribution.<a name='1895'></font>
<a name='1896'>
       <font color=#447700>! ------------------------------------------------------------------------------ !<a name='1897'></font>
       <font color=#447700>! Find single-layer radiatively-driven cloud-topped convective layers (SRCLs).   !<a name='1898'></font>
       <font color=#447700>! SRCLs extend through a single model layer k, with entrainment at the top and   !<a name='1899'></font>
       <font color=#447700>! bottom interfaces, unless bottom interface is the surface.                     !<a name='1900'></font>
       <font color=#447700>! The conditions for an SRCL is identified are:                                  ! <a name='1901'></font>
       <font color=#447700>!                                                                                !<a name='1902'></font>
       <font color=#447700>!   1. Cloud in the layer, k : ql(i,k) .gt. qmin = 1.e-5 [ kg/kg ]               !<a name='1903'></font>
       <font color=#447700>!   2. No cloud in the above layer (else assuming that some fraction of the LW   !<a name='1904'></font>
       <font color=#447700>!      flux divergence in layer k is concentrated at just below top interface    !<a name='1905'></font>
       <font color=#447700>!      of layer k is invalid). Then, this condition might be sensitive to the    !<a name='1906'></font>
       <font color=#447700>!      vertical resolution of grid.                                              !<a name='1907'></font>
       <font color=#447700>!   3. LW radiative cooling (SW heating is assumed uniformly distributed through !<a name='1908'></font>
       <font color=#447700>!      layer k, so not relevant to buoyancy production) in the layer k. However, !<a name='1909'></font>
       <font color=#447700>!      SW production might also contribute, which may be considered in a future. !<a name='1910'></font>
       <font color=#447700>!   4. Internal stratification 'n2ht' of upper-half layer should be unstable.    !<a name='1911'></font>
       <font color=#447700>!      The 'n2ht' is pure internal stratification of upper half layer, obtained  !<a name='1912'></font>
       <font color=#447700>!      using internal slopes of sl, qt in layer k (in contrast to conventional   !<a name='1913'></font>
       <font color=#447700>!      interfacial slope) and saturation fraction in the upper-half layer,       !<a name='1914'></font>
       <font color=#447700>!      sfuh(k) (in contrast to sfi(k)).                                          !<a name='1915'></font>
       <font color=#447700>!   5. Top and bottom interfaces not both in the same existing convective layer. !<a name='1916'></font>
       <font color=#447700>!      If SRCL is within the previouisly identified CL regimes, we don't define  !<a name='1917'></font>
       <font color=#447700>!      a new SRCL.                                                               !<a name='1918'></font>
       <font color=#447700>!   6. k &gt;= ntop_turb + 1 = 2                                                    !<a name='1919'></font>
       <font color=#447700>!   7. Ri at the top interface &gt; ricrit = 0.19 (otherwise turbulent mixing will  !<a name='1920'></font>
       <font color=#447700>!      broadly distribute the cloud top in the vertical, preventing localized    !<a name='1921'></font>
       <font color=#447700>!      radiative destabilization at the top interface).                          !<a name='1922'></font>
       <font color=#447700>!                                                                                !<a name='1923'></font>
       <font color=#447700>! Note if 'k = pver', it identifies a surface-based single fog layer, possibly,  !<a name='1924'></font>
       <font color=#447700>! warm advection fog. Note also the CL regime index of SRCLs itself increases    !<a name='1925'></font>
       <font color=#447700>! with height similar to the regular CLs indices identified from 'zisocl'.       !<a name='1926'></font>
       <font color=#447700>! ------------------------------------------------------------------------------ !<a name='1927'></font>
<a name='1928'>
       ncv  = 1<a name='1929'>
       ncvf = ncvfin(i)<a name='1930'>
<a name='1931'>
       if( choice_SRCL .eq. 'remove' ) goto 222 <a name='1932'>
<a name='1933'>
       do k = nbot_turb, ntop_turb + 1, -1 <font color=#447700>! 'k = pver, 2, -1' is a layer index.<a name='1934'></font>
<a name='1935'>
          if( ql(i,k) .gt. qmin .and. ql(i,k-1) .lt. qmin .and. qrlw(i,k) .lt. 0._r8 &amp;<a name='1936'>
                                .and. ri(i,k) .ge. ricrit ) then<a name='1937'>
<a name='1938'>
              <font color=#447700>! In order to avoid any confliction with the treatment of ambiguous layer,<a name='1939'></font>
              <font color=#447700>! I need to impose an additional constraint that ambiguous layer cannot be<a name='1940'></font>
              <font color=#447700>! SRCL. So, I added constraint that 'k+1' interface (base interface of k<a name='1941'></font>
              <font color=#447700>! layer) should not be a part of previously identified CL. Since 'belongcv'<a name='1942'></font>
              <font color=#447700>! is even true for external entrainment interfaces, below constraint is<a name='1943'></font>
              <font color=#447700>! fully sufficient.<a name='1944'></font>
 <a name='1945'>
              if( choice_SRCL .eq. 'nonamb' .and. belongcv(i,k+1) ) then<a name='1946'>
                  go to 220 <a name='1947'>
              endif<a name='1948'>
<a name='1949'>
              ch = ( 1._r8 - sfuh(i,k) ) * chu(i,k) + sfuh(i,k) * chs(i,k)<a name='1950'>
              cm = ( 1._r8 - sfuh(i,k) ) * cmu(i,k) + sfuh(i,k) * cms(i,k)<a name='1951'>
<a name='1952'>
              n2htSRCL = ch * slslope(i,k) + cm * qtslope(i,k)<a name='1953'>
<a name='1954'>
              if( n2htSRCL .le. 0._r8 ) then<a name='1955'>
<a name='1956'>
                  <font color=#447700>! Test if bottom and top interfaces are part of the pre-existing CL. <a name='1957'></font>
                  <font color=#447700>! If not, find appropriate index for the new SRCL. Note that this<a name='1958'></font>
                  <font color=#447700>! calculation makes use of 'ncv set' obtained from 'zisocl'. The <a name='1959'></font>
                  <font color=#447700>! 'in_CL' is a parameter testing whether the new SRCL is already <a name='1960'></font>
                  <font color=#447700>! within the pre-existing CLs (.true.) or not (.false.). <a name='1961'></font>
<a name='1962'>
                  in_CL = .false.<a name='1963'>
<a name='1964'>
                  do while ( ncv .le. ncvf )<a name='1965'>
                     if( ktop(i,ncv) .le. k ) then<a name='1966'>
                        if( kbase(i,ncv) .gt. k ) then <a name='1967'>
                            in_CL = .true.<a name='1968'>
                        endif<a name='1969'>
                        exit             <font color=#447700>! Exit from 'do while' loop if SRCL is within the CLs.<a name='1970'></font>
                     else<a name='1971'>
                        ncv = ncv + 1    <font color=#447700>! Go up one CL<a name='1972'></font>
                     end if<a name='1973'>
                  end do <font color=#447700>! ncv<a name='1974'></font>
<a name='1975'>
                  if( .not. in_CL ) then <font color=#447700>! SRCL is not within the pre-existing CLs.<a name='1976'></font>
<a name='1977'>
                     <font color=#447700>! Identify a new SRCL and add it to the pre-existing CL regime group.<a name='1978'></font>
<a name='1979'>
                     ncvfin(i)       =  ncvfin(i) + 1<a name='1980'>
                     ncvnew          =  ncvfin(i)<a name='1981'>
                     ktop(i,ncvnew)  =  k<a name='1982'>
                     kbase(i,ncvnew) =  k+1<a name='1983'>
                     belongcv(i,k)   = .true.<a name='1984'>
                     belongcv(i,k+1) = .true.<a name='1985'>
<a name='1986'>
                     <font color=#447700>! Calculate internal energy of SRCL. There is no internal energy if<a name='1987'></font>
                     <font color=#447700>! SRCL is elevated from the surface. Also, we simply assume neutral <a name='1988'></font>
                     <font color=#447700>! stability function. Note that this assumption of neutral stability<a name='1989'></font>
                     <font color=#447700>! does not influence numerical calculation- stability functions here<a name='1990'></font>
                     <font color=#447700>! are just for diagnostic output. In general SRCLs other than a SRCL <a name='1991'></font>
                     <font color=#447700>! based at surface with bflxs &lt;= 0, there is no other way but to use<a name='1992'></font>
                     <font color=#447700>! neutral stability function.  However, in case of SRCL based at the<a name='1993'></font>
                     <font color=#447700>! surface,  we can explicitly calculate non-zero stability functions            <a name='1994'></font>
                     <font color=#447700>! in a consistent way.   Even though stability functions of SRCL are<a name='1995'></font>
                     <font color=#447700>! just diagnostic outputs not influencing numerical calculations, it<a name='1996'></font>
                     <font color=#447700>! would be informative to write out correct reasonable values rather<a name='1997'></font>
                     <font color=#447700>! than simply assuming neutral stability. I am doing this right now.<a name='1998'></font>
                     <font color=#447700>! Similar calculations were done for the SBCL and when surface inter<a name='1999'></font>
                     <font color=#447700>! facial layer was merged by overlying CL in 'ziscol'.<a name='2000'></font>
<a name='2001'>
                     if( k .lt. pver ) then<a name='2002'>
<a name='2003'>
                         wbrk(i,ncvnew) = 0._r8<a name='2004'>
                         ebrk(i,ncvnew) = 0._r8<a name='2005'>
                         lbrk(i,ncvnew) = 0._r8<a name='2006'>
                         ghcl(i,ncvnew) = 0._r8<a name='2007'>
                         shcl(i,ncvnew) = 0._r8<a name='2008'>
                         smcl(i,ncvnew) = 0._r8<a name='2009'>
                         ricl(i,ncvnew) = 0._r8<a name='2010'>
<a name='2011'>
                     else <font color=#447700>! Surface-based fog<a name='2012'></font>
<a name='2013'>
                         if( bflxs(i) .gt. 0._r8 ) then    <font color=#447700>! Incorporate surface TKE into CL interior energy<a name='2014'></font>
                                                           <font color=#447700>! It is likely that this case cannot exist  since<a name='2015'></font>
                                                           <font color=#447700>! if surface buoyancy flux is positive,  it would<a name='2016'></font>
                                                           <font color=#447700>! have been identified as SBCL in 'zisocl' ahead. <a name='2017'></font>
                             ebrk(i,ncvnew) = tkes(i)<a name='2018'>
                             lbrk(i,ncvnew) = z(i,pver)<a name='2019'>
                             wbrk(i,ncvnew) = tkes(i) / b1    <a name='2020'>
        <a name='2021'>
                             write(iulog,*) 'Major mistake in SRCL: bflxs &gt; 0 for surface-based SRCL'<a name='2022'>
#ifdef WRF_PORT<a name='2023'>
                             call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_544">(iulog)<a name='2024'>
#endif <a name='2025'>
                             write(iulog,*) 'bflxs = ', bflxs(i)<a name='2026'>
#ifdef WRF_PORT<a name='2027'>
                             call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_545">(iulog)<a name='2028'>
#endif                              <a name='2029'>
                             write(iulog,*) 'ncvfin_o = ', ncvfin_o(i)<a name='2030'>
#ifdef WRF_PORT<a name='2031'>
                             call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_546">(iulog)<a name='2032'>
#endif <a name='2033'>
                             write(iulog,*) 'ncvfin_mg = ', ncvfin_mg(i)<a name='2034'>
#ifdef WRF_PORT<a name='2035'>
                             call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_547">(iulog)<a name='2036'>
#endif <a name='2037'>
                             do ks = 1, ncvmax<a name='2038'>
                                write(iulog,*) 'ncv =', ks, ' ', kbase_o(i,ks), ktop_o(i,ks), kbase_mg(i,ks), ktop_mg(i,ks)<a name='2039'>
#ifdef WRF_PORT<a name='2040'>
                                call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_548">(iulog)<a name='2041'>
#endif <a name='2042'>
                             end do<a name='2043'>
                             stop<a name='2044'>
<a name='2045'>
                         else                              <font color=#447700>! Don't incorporate surface interfacial TKE into CL interior energy<a name='2046'></font>
<a name='2047'>
                             ebrk(i,ncvnew) = 0._r8<a name='2048'>
                             lbrk(i,ncvnew) = 0._r8<a name='2049'>
                             wbrk(i,ncvnew) = 0._r8<a name='2050'>
<a name='2051'>
                         endif<a name='2052'>
<a name='2053'>
                         <font color=#447700>! Calculate stability functions (ghcl, shcl, smcl, ricl) explicitly<a name='2054'></font>
                         <font color=#447700>! using an reverse procedure starting from tkes(i). Note that it is<a name='2055'></font>
                         <font color=#447700>! possible to calculate stability functions even when bflxs &lt; 0.<a name='2056'></font>
                         <font color=#447700>! Previous code just assumed neutral stability functions. Note that<a name='2057'></font>
                         <font color=#447700>! since alph5 = 0.7 &gt; 0, alph3 = -35 &lt; 0, the denominator of gh  is<a name='2058'></font>
                         <font color=#447700>! always positive if bflxs &gt; 0. However, if bflxs &lt; 0,  denominator<a name='2059'></font>
                         <font color=#447700>! can be zero. For this case, we provide a possible maximum negative<a name='2060'></font>
                         <font color=#447700>! value (the most stable state) to gh. Note also tkes(i) is always a<a name='2061'></font>
                         <font color=#447700>! positive value by a limiter. Also, sprod(i,pver+1) &gt; 0 by limiter.<a name='2062'></font>
                         <a name='2063'>
                         gg = 0.5_r8 * vk * z(i,pver) * bprod(i,pver+1) / ( tkes(i)**(3._r8/2._r8) )<a name='2064'>
                         if( abs(alph5-gg*alph3) .le. 1.e-7_r8 ) then<a name='2065'>
                           <font color=#447700>! gh = -0.28_r8<a name='2066'></font>
                           <font color=#447700>! gh = -3.5334_r8<a name='2067'></font>
                             gh = ghmin<a name='2068'>
                         else    <a name='2069'>
                             gh = gg / ( alph5 - gg * alph3 )<a name='2070'>
                         end if <a name='2071'>
                       <font color=#447700>! gh = min(max(gh,-0.28_r8),0.0233_r8)<a name='2072'></font>
                       <font color=#447700>! gh = min(max(gh,-3.5334_r8),0.0233_r8)<a name='2073'></font>
                         gh = min(max(gh,ghmin),0.0233_r8)<a name='2074'>
                         ghcl(i,ncvnew) =  gh<a name='2075'>
                         shcl(i,ncvnew) =  max(0._r8,alph5/(1._r8+alph3*gh))<a name='2076'>
                         smcl(i,ncvnew) =  max(0._r8,(alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4exs*gh))<a name='2077'>
                         ricl(i,ncvnew) = -(smcl(i,ncvnew)/shcl(i,ncvnew))*(bprod(i,pver+1)/sprod(i,pver+1))<a name='2078'>
<a name='2079'>
                       <font color=#447700>! 'ncvsurf' is CL regime index based at the surface. If there is no<a name='2080'></font>
                       <font color=#447700>! such regime, then 'ncvsurf = 0'.<a name='2081'></font>
    <a name='2082'>
                         ncvsurf = ncvnew<a name='2083'>
<a name='2084'>
                      end if<a name='2085'>
<a name='2086'>
                  end if<a name='2087'>
<a name='2088'>
              end if<a name='2089'>
<a name='2090'>
          end if<a name='2091'>
<a name='2092'>
   220 continue    <a name='2093'>
<a name='2094'>
       end do <font color=#447700>! End of 'k' loop where 'k' is a grid layer index running from 'pver' to 2<a name='2095'></font>
<a name='2096'>
   222 continue<a name='2097'>
<a name='2098'>
       <font color=#447700>! -------------------------------------------------------------------------- !<a name='2099'></font>
       <font color=#447700>! Up to this point, we identified all kinds of CL regimes :                  !<a name='2100'></font>
       <font color=#447700>!   1. A SBCL. By construction, 'bflxs &gt; 0' for SBCL.                        !<a name='2101'></font>
       <font color=#447700>!   2. Surface-based CL with multiple layers and 'bflxs =&lt; 0'                !<a name='2102'></font>
       <font color=#447700>!   3. Surface-based CL with multiple layers and 'bflxs &gt; 0'                 !<a name='2103'></font>
       <font color=#447700>!   4. Regular elevated CL with two entraining interfaces                    ! <a name='2104'></font>
       <font color=#447700>!   5. SRCLs. If SRCL is based at surface, it will be bflxs &lt; 0.             !<a name='2105'></font>
       <font color=#447700>! '1-4' were identified from 'zisocl' while '5' were identified separately   !<a name='2106'></font>
       <font color=#447700>! after performing 'zisocl'. CL regime index of '1-4' increases with height  !<a name='2107'></font>
       <font color=#447700>! ( e.g., CL = 1 is the CL regime nearest to the surface ) while CL regime   !<a name='2108'></font>
       <font color=#447700>! index of SRCL is simply appended after the final index of CL regimes from  !<a name='2109'></font>
       <font color=#447700>! 'zisocl'. However, CL regime indices of SRCLs itself increases with height !<a name='2110'></font>
       <font color=#447700>! when there are multiple SRCLs, similar to the regular CLs from 'zisocl'.   !<a name='2111'></font>
       <font color=#447700>! -------------------------------------------------------------------------- !<a name='2112'></font>
<a name='2113'>
       <font color=#447700>! Diagnostic output of final CL regimes indices<a name='2114'></font>
       <a name='2115'>
       do k = 1, ncvmax<a name='2116'>
          kbase_f(i,k) = real(kbase(i,k))<a name='2117'>
          ktop_f(i,k)  = real(ktop(i,k)) <a name='2118'>
          ncvfin_f(i)  = real(ncvfin(i))<a name='2119'>
       end do <a name='2120'>
<a name='2121'>
       <font color=#447700>! ---------------------------------------- !<a name='2122'></font>
       <font color=#447700>! Perform do loop for individual CL regime !<a name='2123'></font>
       <font color=#447700>! ---------------------------------------- ! -------------------------------- !<a name='2124'></font>
       <font color=#447700>! For individual CLs, compute                                                 !<a name='2125'></font>
       <font color=#447700>!   1. Entrainment rates at the CL top and (if any) base interfaces using     !<a name='2126'></font>
       <font color=#447700>!      appropriate entrainment closure (current code use 'wstar' closure).    !<a name='2127'></font>
       <font color=#447700>!   2. Net CL mean (i.e., including entrainment contribution) TKE (ebrk)      !<a name='2128'></font>
       <font color=#447700>!      and normalized TKE (wbrk).                                             ! <a name='2129'></font>
       <font color=#447700>!   3. TKE (tke) and normalized TKE (wcap) profiles at all CL interfaces.     !<a name='2130'></font>
       <font color=#447700>!   4. ( kvm, kvh ) profiles at all CL interfaces.                            !<a name='2131'></font>
       <font color=#447700>!   5. ( bprod, sprod ) profiles at all CL interfaces.                        !<a name='2132'></font>
       <font color=#447700>! Also calculate                                                              !<a name='2133'></font>
       <font color=#447700>!   1. PBL height as the top external interface of surface-based CL, if any.  !<a name='2134'></font>
       <font color=#447700>!   2. Characteristic excesses of convective 'updraft velocity (wpert)',      !<a name='2135'></font>
       <font color=#447700>!      'temperature (tpert)', and 'moisture (qpert)' in the surface-based CL, !<a name='2136'></font>
       <font color=#447700>!      if any, for use in the separate convection scheme.                     ! <a name='2137'></font>
       <font color=#447700>! If there is no surface-based CL, 'PBL height' and 'convective excesses' are !<a name='2138'></font>
       <font color=#447700>! calculated later from surface-based STL (Stable Turbulent Layer) properties.!<a name='2139'></font>
       <font color=#447700>! --------------------------------------------------------------------------- !<a name='2140'></font>
<a name='2141'>
       ktblw = 0<a name='2142'>
       do ncv = 1, ncvfin(i)<a name='2143'>
<a name='2144'>
          kt = ktop(i,ncv)<a name='2145'>
          kb = kbase(i,ncv)<a name='2146'>
          <font color=#447700>! Check whether surface interface is energetically interior or not.<a name='2147'></font>
          if( kb .eq. (pver+1) .and. bflxs(i) .le. 0._r8 ) then<a name='2148'>
              lbulk = zi(i,kt) - z(i,pver)<a name='2149'>
          else<a name='2150'>
              lbulk = zi(i,kt) - zi(i,kb)<a name='2151'>
          end if<a name='2152'>
<a name='2153'>
          <font color=#447700>! Calculate 'turbulent length scale (leng)' and 'normalized TKE (wcap)'<a name='2154'></font>
          <font color=#447700>! at all CL interfaces except the surface.  Note that below 'wcap' at <a name='2155'></font>
          <font color=#447700>! external interfaces are not correct. However, it does not influence <a name='2156'></font>
          <font color=#447700>! numerical calculation and correct normalized TKE at the entraining <a name='2157'></font>
          <font color=#447700>! interfaces will be re-calculated at the end of this 'do ncv' loop. <a name='2158'></font>
<a name='2159'>
          do k = min(kb,pver), kt, -1 <a name='2160'>
             if( choice_tunl .eq. 'rampcl' ) then<a name='2161'>
               <font color=#447700>! In order to treat the case of 'ricl(i,ncv) &gt;&gt; 0' of surface-based SRCL<a name='2162'></font>
               <font color=#447700>! with 'bflxs(i) &lt; 0._r8', I changed ricl(i,ncv) -&gt; min(0._r8,ricl(i,ncv))<a name='2163'></font>
               <font color=#447700>! in the below exponential. This is necessary to prevent the model crash<a name='2164'></font>
               <font color=#447700>! by too large values (e.g., 700) of ricl(i,ncv)   <a name='2165'></font>
                 tunlramp = ctunl*tunl*(1._r8-(1._r8-1._r8/ctunl)*exp(min(0._r8,ricl(i,ncv))))<a name='2166'>
                 tunlramp = min(max(tunlramp,tunl),ctunl*tunl)<a name='2167'>
             elseif( choice_tunl .eq. 'rampsl' ) then<a name='2168'>
                 tunlramp = ctunl*tunl<a name='2169'>
               <font color=#447700>! tunlramp = 0.765_r8<a name='2170'></font>
             else<a name='2171'>
                 tunlramp = tunl<a name='2172'>
             endif<a name='2173'>
             if( choice_leng .eq. 'origin' ) then<a name='2174'>
                 leng(i,k) = ( (vk*zi(i,k))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='2175'>
               <font color=#447700>! leng(i,k) = vk*zi(i,k) / (1._r8+vk*zi(i,k)/(tunlramp*lbulk))<a name='2176'></font>
             else<a name='2177'>
                 leng(i,k) = min( vk*zi(i,k), tunlramp*lbulk )              <a name='2178'>
             endif<a name='2179'>
             wcap(i,k) = (leng(i,k)**2) * (-shcl(i,ncv)*n2(i,k)+smcl(i,ncv)*s2(i,k))<a name='2180'>
          end do <font color=#447700>! k<a name='2181'></font>
<a name='2182'>
          <font color=#447700>! Calculate basic cross-interface variables ( jump condition ) across the <a name='2183'></font>
          <font color=#447700>! base external interface of CL.<a name='2184'></font>
<a name='2185'>
          if( kb .lt. pver+1 ) then <a name='2186'>
<a name='2187'>
              jbzm = z(i,kb-1) - z(i,kb)                                      <font color=#447700>! Interfacial layer thickness [m]<a name='2188'></font>
              jbsl = sl(i,kb-1) - sl(i,kb)                                    <font color=#447700>! Interfacial jump of 'sl' [J/kg]<a name='2189'></font>
              jbqt = qt(i,kb-1) - qt(i,kb)                                    <font color=#447700>! Interfacial jump of 'qt' [kg/kg]<a name='2190'></font>
              jbbu = n2(i,kb) * jbzm                                          <font color=#447700>! Interfacial buoyancy jump [m/s2] considering saturation ( &gt; 0 ) <a name='2191'></font>
              jbbu = max(jbbu,jbumin)                                         <font color=#447700>! Set minimum buoyancy jump, jbumin = 1.e-3<a name='2192'></font>
              jbu  = u(i,kb-1) - u(i,kb)                                      <font color=#447700>! Interfacial jump of 'u' [m/s]<a name='2193'></font>
              jbv  = v(i,kb-1) - v(i,kb)                                      <font color=#447700>! Interfacial jump of 'v' [m/s]<a name='2194'></font>
              ch   = (1._r8 -sflh(i,kb-1))*chu(i,kb) + sflh(i,kb-1)*chs(i,kb) <font color=#447700>! Buoyancy coefficient just above the base interface<a name='2195'></font>
              cm   = (1._r8 -sflh(i,kb-1))*cmu(i,kb) + sflh(i,kb-1)*cms(i,kb) <font color=#447700>! Buoyancy coefficient just above the base interface<a name='2196'></font>
              n2hb = (ch*jbsl + cm*jbqt)/jbzm                                 <font color=#447700>! Buoyancy frequency [s-2] just above the base interface<a name='2197'></font>
              vyb  = n2hb*jbzm/jbbu                                           <font color=#447700>! Ratio of 'n2hb/n2' at 'kb' interface<a name='2198'></font>
              vub  = min(1._r8,(jbu**2+jbv**2)/(jbbu*jbzm) )                  <font color=#447700>! Ratio of 's2/n2 = 1/Ri' at 'kb' interface<a name='2199'></font>
<a name='2200'>
          else <a name='2201'>
<a name='2202'>
            <font color=#447700>! Below setting is necessary for consistent treatment when 'kb' is at the surface.<a name='2203'></font>
              jbbu = 0._r8<a name='2204'>
              n2hb = 0._r8<a name='2205'>
              vyb  = 0._r8<a name='2206'>
              vub  = 0._r8<a name='2207'>
              web  = 0._r8<a name='2208'>
<a name='2209'>
          end if<a name='2210'>
<a name='2211'>
          <font color=#447700>! Calculate basic cross-interface variables ( jump condition ) across the <a name='2212'></font>
          <font color=#447700>! top external interface of CL. The meanings of variables are similar to<a name='2213'></font>
          <font color=#447700>! the ones at the base interface.<a name='2214'></font>
<a name='2215'>
          jtzm = z(i,kt-1) - z(i,kt)<a name='2216'>
          jtsl = sl(i,kt-1) - sl(i,kt)<a name='2217'>
          jtqt = qt(i,kt-1) - qt(i,kt)<a name='2218'>
          jtbu = n2(i,kt)*jtzm                                                <font color=#447700>! Note : 'jtbu' is guaranteed positive by definition of CL top.<a name='2219'></font>
          jtbu = max(jtbu,jbumin)                                             <font color=#447700>! But threshold it anyway to be sure.<a name='2220'></font>
          jtu  = u(i,kt-1) - u(i,kt)<a name='2221'>
          jtv  = v(i,kt-1) - v(i,kt)<a name='2222'>
          ch   = (1._r8 -sfuh(i,kt))*chu(i,kt) + sfuh(i,kt)*chs(i,kt) <a name='2223'>
          cm   = (1._r8 -sfuh(i,kt))*cmu(i,kt) + sfuh(i,kt)*cms(i,kt) <a name='2224'>
          n2ht = (ch*jtsl + cm*jtqt)/jtzm                       <a name='2225'>
          vyt  = n2ht*jtzm/jtbu                                  <a name='2226'>
          vut  = min(1._r8,(jtu**2+jtv**2)/(jtbu*jtzm))             <a name='2227'>
<a name='2228'>
          <font color=#447700>! Evaporative enhancement factor of entrainment rate at the CL top interface, evhc. <a name='2229'></font>
          <font color=#447700>! We take the full inversion strength to be 'jt2slv = slv(i,kt-2)-slv(i,kt)' <a name='2230'></font>
          <font color=#447700>! where 'kt-1' is in the ambiguous layer. However, for a cloud-topped CL overlain<a name='2231'></font>
          <font color=#447700>! by another CL, it is possible that 'slv(i,kt-2) &lt; slv(i,kt)'. To avoid negative<a name='2232'></font>
          <font color=#447700>! or excessive evhc, we lower-bound jt2slv and upper-bound evhc.  Note 'jtslv' is<a name='2233'></font>
          <font color=#447700>! used only for calculating 'evhc' : when calculating entrainment rate,   we will<a name='2234'></font>
          <font color=#447700>! use normal interfacial buoyancy jump across CL top interface.<a name='2235'></font>
<a name='2236'>
          evhc   = 1._r8<a name='2237'>
          jt2slv = 0._r8<a name='2238'>
<a name='2239'>
        <font color=#447700>! Modification : I should check whether below 'jbumin' produces reasonable limiting value.   <a name='2240'></font>
        <font color=#447700>!                In addition, our current formulation does not consider ice contribution. <a name='2241'></font>
<a name='2242'>
          if( choice_evhc .eq. 'orig' ) then<a name='2243'>
<a name='2244'>
              if( ql(i,kt) .gt. qmin .and. ql(i,kt-1) .lt. qmin ) then <a name='2245'>
                  jt2slv = slv(i,max(kt-2,1)) - slv(i,kt)<a name='2246'>
                  jt2slv = max( jt2slv, jbumin*slv(i,kt-1)/g )<a name='2247'>
                  evhc   = 1._r8 + a2l * a3l * latvap * ql(i,kt) / jt2slv<a name='2248'>
                  evhc   = min( evhc, evhcmax )<a name='2249'>
              end if<a name='2250'>
<a name='2251'>
          elseif( choice_evhc .eq. 'ramp' ) then<a name='2252'>
<a name='2253'>
              jt2slv = slv(i,max(kt-2,1)) - slv(i,kt)<a name='2254'>
              jt2slv = max( jt2slv, jbumin*slv(i,kt-1)/g )<a name='2255'>
              evhc   = 1._r8 + max(cldeff(i,kt)-cldeff(i,kt-1),0._r8) * a2l * a3l * latvap * ql(i,kt) / jt2slv<a name='2256'>
              evhc   = min( evhc, evhcmax )<a name='2257'>
<a name='2258'>
          elseif( choice_evhc .eq. 'maxi' ) then<a name='2259'>
<a name='2260'>
              qleff  = max( ql(i,kt-1), ql(i,kt) ) <a name='2261'>
              jt2slv = slv(i,max(kt-2,1)) - slv(i,kt)<a name='2262'>
              jt2slv = max( jt2slv, jbumin*slv(i,kt-1)/g )<a name='2263'>
              evhc   = 1._r8 + a2l * a3l * latvap * qleff / jt2slv<a name='2264'>
              evhc   = min( evhc, evhcmax )<a name='2265'>
<a name='2266'>
          endif<a name='2267'>
<a name='2268'>
          <font color=#447700>! Calculate cloud-top radiative cooling contribution to buoyancy production.<a name='2269'></font>
          <font color=#447700>! Here,  'radf' [m2/s3] is additional buoyancy flux at the CL top interface <a name='2270'></font>
          <font color=#447700>! associated with cloud-top LW cooling being mainly concentrated near the CL<a name='2271'></font>
          <font color=#447700>! top interface ( just below CL top interface ).  Contribution of SW heating<a name='2272'></font>
          <font color=#447700>! within the cloud is not included in this radiative buoyancy production <a name='2273'></font>
          <font color=#447700>! since SW heating is more broadly distributed throughout the CL top layer. <a name='2274'></font>
<a name='2275'>
          lwp        = 0._r8<a name='2276'>
          opt_depth  = 0._r8<a name='2277'>
          radinvfrac = 0._r8 <a name='2278'>
          radf       = 0._r8<a name='2279'>
<a name='2280'>
          if( choice_radf .eq. 'orig' ) then<a name='2281'>
<a name='2282'>
              if( ql(i,kt) .gt. qmin .and. ql(i,kt-1) .lt. qmin ) then <a name='2283'>
<a name='2284'>
                  lwp       = ql(i,kt) * ( pi(i,kt+1) - pi(i,kt) ) / g<a name='2285'>
                  opt_depth = 156._r8 * lwp  <font color=#447700>! Estimated LW optical depth in the CL top layer<a name='2286'></font>
<a name='2287'>
                  <font color=#447700>! Approximate LW cooling fraction concentrated at the inversion by using<a name='2288'></font>
                  <font color=#447700>! polynomial approx to exact formula 1-2/opt_depth+2/(exp(opt_depth)-1))<a name='2289'></font>
<a name='2290'>
                  radinvfrac  = opt_depth * ( 4._r8 + opt_depth ) / ( 6._r8 * ( 4._r8 + opt_depth ) + opt_depth**2 )<a name='2291'>
                  radf        = qrlw(i,kt) / ( pi(i,kt) - pi(i,kt+1) ) <font color=#447700>! Cp*radiative cooling = [ W/kg ] <a name='2292'></font>
                  radf        = max( radinvfrac * radf * ( zi(i,kt) - zi(i,kt+1) ), 0._r8 ) * chs(i,kt)<a name='2293'>
                <font color=#447700>! We can disable cloud LW cooling contribution to turbulence by uncommenting:<a name='2294'></font>
                <font color=#447700>! radf = 0._r8<a name='2295'></font>
<a name='2296'>
              end if<a name='2297'>
<a name='2298'>
          elseif( choice_radf .eq. 'ramp' ) then<a name='2299'>
<a name='2300'>
                  lwp         = ql(i,kt) * ( pi(i,kt+1) - pi(i,kt) ) / g<a name='2301'>
                  opt_depth   = 156._r8 * lwp  <font color=#447700>! Estimated LW optical depth in the CL top layer<a name='2302'></font>
                  radinvfrac  = opt_depth * ( 4._r8 + opt_depth ) / ( 6._r8 * ( 4._r8 + opt_depth ) + opt_depth**2 )<a name='2303'>
                  radinvfrac  = max(cldeff(i,kt)-cldeff(i,kt-1),0._r8) * radinvfrac <a name='2304'>
                  radf        = qrlw(i,kt) / ( pi(i,kt) - pi(i,kt+1) ) <font color=#447700>! Cp*radiative cooling [W/kg] <a name='2305'></font>
                  radf        = max( radinvfrac * radf * ( zi(i,kt) - zi(i,kt+1) ), 0._r8 ) * chs(i,kt)<a name='2306'>
<a name='2307'>
          elseif( choice_radf .eq. 'maxi' ) then<a name='2308'>
<a name='2309'>
                <font color=#447700>! Radiative flux divergence both in 'kt' and 'kt-1' layers are included <a name='2310'></font>
                <font color=#447700>! 1. From 'kt' layer<a name='2311'></font>
                  lwp         = ql(i,kt) * ( pi(i,kt+1) - pi(i,kt) ) / g<a name='2312'>
                  opt_depth   = 156._r8 * lwp  <font color=#447700>! Estimated LW optical depth in the CL top layer<a name='2313'></font>
                  radinvfrac  = opt_depth * ( 4._r8 + opt_depth ) / ( 6._r8 * ( 4._r8 + opt_depth ) + opt_depth**2 )<a name='2314'>
                  radf        = max( radinvfrac * qrlw(i,kt) / ( pi(i,kt) - pi(i,kt+1) ) * ( zi(i,kt) - zi(i,kt+1) ), 0._r8 )<a name='2315'>
                <font color=#447700>! 2. From 'kt-1' layer and add the contribution from 'kt' layer<a name='2316'></font>
                  lwp         = ql(i,kt-1) * ( pi(i,kt) - pi(i,kt-1) ) / g<a name='2317'>
                  opt_depth   = 156._r8 * lwp  <font color=#447700>! Estimated LW optical depth in the CL top layer<a name='2318'></font>
                  radinvfrac  = opt_depth * ( 4._r8 + opt_depth ) / ( 6._r8 * ( 4._r8 + opt_depth) + opt_depth**2 )<a name='2319'>
                  radf        = radf + max( radinvfrac * qrlw(i,kt-1) / ( pi(i,kt-1) - pi(i,kt) ) * ( zi(i,kt-1) - zi(i,kt) ), &amp;<a name='2320'>
                                            0._r8 )<a name='2321'>
                  radf        = max( radf, 0._r8 ) * chs(i,kt) <a name='2322'>
<a name='2323'>
          endif<a name='2324'>
<a name='2325'>
          <font color=#447700>! ------------------------------------------------------------------- !<a name='2326'></font>
          <font color=#447700>! Calculate 'wstar3' by summing buoyancy productions within CL from   !<a name='2327'></font>
          <font color=#447700>!   1. Interior buoyancy production ( bprod: fcn of TKE )             !<a name='2328'></font>
          <font color=#447700>!   2. Cloud-top radiative cooling                                    !<a name='2329'></font>
          <font color=#447700>!   3. Surface buoyancy flux contribution only when bflxs &gt; 0.        !<a name='2330'></font>
          <font color=#447700>!      Note that master length scale, lbulk, has already been         !<a name='2331'></font>
          <font color=#447700>!      corrctly defined at the first part of this 'do ncv' loop       !<a name='2332'></font>
          <font color=#447700>!      considering the sign of bflxs.                                 !<a name='2333'></font>
          <font color=#447700>! This 'wstar3' is used for calculation of entrainment rate.          !<a name='2334'></font>
          <font color=#447700>! Note that this 'wstar3' formula does not include shear production   !<a name='2335'></font>
          <font color=#447700>! and the effect of drizzle, which should be included later.          !<a name='2336'></font>
          <font color=#447700>! Q : Strictly speaking, in calculating interior buoyancy production, ! <a name='2337'></font>
          <font color=#447700>!     the use of 'bprod' is not correct, since 'bprod' is not correct !<a name='2338'></font>
          <font color=#447700>!     value but initially guessed value.   More reasonably, we should ! <a name='2339'></font>
          <font color=#447700>!     use '-leng(i,k)*sqrt(b1*wcap(i,k))*shcl(i,ncv)*n2(i,k)' instead !<a name='2340'></font>
          <font color=#447700>!     of 'bprod(i,k)', although this is still an  approximation since !<a name='2341'></font>
          <font color=#447700>!     tke(i,k) is not exactly 'b1*wcap(i,k)'  due to a transport term.! <a name='2342'></font>
          <font color=#447700>!     However since iterative calculation will be performed after all,! <a name='2343'></font>
          <font color=#447700>!     below might also be OK. But I should test this alternative.     !<a name='2344'></font>
          <font color=#447700>! ------------------------------------------------------------------- !      <a name='2345'></font>
<a name='2346'>
          dzht   = zi(i,kt)  - z(i,kt)     <font color=#447700>! Thickness of CL top half-layer<a name='2347'></font>
          dzhb   = z(i,kb-1) - zi(i,kb)    <font color=#447700>! Thickness of CL bot half-layer<a name='2348'></font>
          wstar3 = radf * dzht<a name='2349'>
          do k = kt + 1, kb - 1 <font color=#447700>! If 'kt = kb - 1', this loop will not be performed. <a name='2350'></font>
               wstar3 =  wstar3 + bprod(i,k) * ( z(i,k-1) - z(i,k) )<a name='2351'>
             <font color=#447700>! Below is an alternative which may speed up convergence.<a name='2352'></font>
             <font color=#447700>! However, for interfaces merged into original CL, it can<a name='2353'></font>
             <font color=#447700>! be 'wcap(i,k)&lt;0' since 'n2(i,k)&gt;0'.  Thus, I should use<a name='2354'></font>
             <font color=#447700>! the above original one.<a name='2355'></font>
             <font color=#447700>! wstar3 =  wstar3 - leng(i,k)*sqrt(b1*wcap(i,k))*shcl(i,ncv)*n2(i,k)* &amp;<a name='2356'></font>
             <font color=#447700>!                    (z(i,k-1) - z(i,k))<a name='2357'></font>
          end do      <a name='2358'>
          if( kb .eq. (pver+1) .and. bflxs(i) .gt. 0._r8 ) then<a name='2359'>
             wstar3 = wstar3 + bflxs(i) * dzhb<a name='2360'>
           <font color=#447700>! wstar3 = wstar3 + bprod(i,pver+1) * dzhb<a name='2361'></font>
          end if   <a name='2362'>
          wstar3 = max( 2.5_r8 * wstar3, 0._r8 )<a name='2363'>
   <a name='2364'>
          <font color=#447700>! -------------------------------------------------------------- !<a name='2365'></font>
          <font color=#447700>! Below single block is for 'sedimentation-entrainment feedback' !<a name='2366'></font>
          <font color=#447700>! -------------------------------------------------------------- !          <a name='2367'></font>
<a name='2368'>
          if( id_sedfact ) then<a name='2369'>
            <font color=#447700>! wsed    = 7.8e5_r8*(ql(i,kt)/ncliq(i,kt))**(2._r8/3._r8)<a name='2370'></font>
              sedfact = exp(-ased*wsedl(i,kt)/(wstar3**(1._r8/3._r8)+1.e-6))<a name='2371'>
              if( choice_evhc .eq. 'orig' ) then<a name='2372'>
                  if (ql(i,kt).gt.qmin .and. ql(i,kt-1).lt.qmin) then<a name='2373'>
                      jt2slv = slv(i,max(kt-2,1)) - slv(i,kt)<a name='2374'>
                      jt2slv = max(jt2slv, jbumin*slv(i,kt-1)/g)<a name='2375'>
                      evhc = 1._r8+sedfact*a2l*a3l*latvap*ql(i,kt) / jt2slv<a name='2376'>
                      evhc = min(evhc,evhcmax)<a name='2377'>
                  end if<a name='2378'>
              elseif( choice_evhc .eq. 'ramp' ) then<a name='2379'>
                  jt2slv = slv(i,max(kt-2,1)) - slv(i,kt)<a name='2380'>
                  jt2slv = max(jt2slv, jbumin*slv(i,kt-1)/g)<a name='2381'>
                  evhc = 1._r8+max(cldeff(i,kt)-cldeff(i,kt-1),0._r8)*sedfact*a2l*a3l*latvap*ql(i,kt) / jt2slv<a name='2382'>
                  evhc = min(evhc,evhcmax)<a name='2383'>
              elseif( choice_evhc .eq. 'maxi' ) then<a name='2384'>
                  qleff  = max(ql(i,kt-1),ql(i,kt))<a name='2385'>
                  jt2slv = slv(i,max(kt-2,1)) - slv(i,kt)<a name='2386'>
                  jt2slv = max(jt2slv, jbumin*slv(i,kt-1)/g)<a name='2387'>
                  evhc = 1._r8+sedfact*a2l*a3l*latvap*qleff / jt2slv<a name='2388'>
                  evhc = min(evhc,evhcmax)<a name='2389'>
              endif<a name='2390'>
          endif<a name='2391'>
<a name='2392'>
          <font color=#447700>! -------------------------------------------------------------------------- !<a name='2393'></font>
          <font color=#447700>! Now diagnose CL top and bottom entrainment rates (and the contribution of  !<a name='2394'></font>
          <font color=#447700>! top/bottom entrainments to wstar3) using entrainment closures of the form  !<a name='2395'></font>
          <font color=#447700>!                                                                            !        <a name='2396'></font>
          <font color=#447700>!                   wet = cet*wstar3, web = ceb*wstar3                       !<a name='2397'></font>
          <font color=#447700>!                                                                            !<a name='2398'></font>
          <font color=#447700>! where cet and ceb depend on the entrainment interface jumps, ql, etc.      !<a name='2399'></font>
          <font color=#447700>! No entrainment is diagnosed unless the wstar3 &gt; 0. Note '1/wstar3fact' is  !<a name='2400'></font>
          <font color=#447700>! a factor indicating the enhancement of wstar3 due to entrainment process.  !<a name='2401'></font>
          <font color=#447700>! Q : Below setting of 'wstar3fact = max(..,0.5)'might prevent the possible  !<a name='2402'></font>
          <font color=#447700>!     case when buoyancy consumption by entrainment is  stronger than cloud  !<a name='2403'></font>
          <font color=#447700>!     top radiative cooling production. Is that OK ? No.  According to bulk  !<a name='2404'></font>
          <font color=#447700>!     modeling study, entrainment buoyancy consumption was always a certain  !<a name='2405'></font>
          <font color=#447700>!     fraction of other net productions, rather than a separate sum.  Thus,  !<a name='2406'></font>
          <font color=#447700>!     below max limit of wstar3fact is correct.   'wstar3fact = max(.,0.5)'  !<a name='2407'></font>
          <font color=#447700>!     prevents unreasonable enhancement of CL entrainment rate by cloud-top  !<a name='2408'></font>
          <font color=#447700>!     entrainment instability, CTEI.                                         !<a name='2409'></font>
          <font color=#447700>! Q : Use of the same dry entrainment coefficient, 'a1i' both at the CL  top !<a name='2410'></font>
          <font color=#447700>!     and base interfaces may result in too small 'wstar3' and 'ebrk' below, !<a name='2411'></font>
          <font color=#447700>!     as was seen in my generalized bulk modeling study. This should be re-  !<a name='2412'></font>
          <font color=#447700>!     considered later                                                       !<a name='2413'></font>
          <font color=#447700>! -------------------------------------------------------------------------- !<a name='2414'></font>
          <a name='2415'>
          if( wstar3 .gt. 0._r8 ) then<a name='2416'>
              cet = a1i * evhc / ( jtbu * lbulk )<a name='2417'>
              if( kb .eq. pver + 1 ) then <a name='2418'>
                  wstar3fact = max( 1._r8 + 2.5_r8 * cet * n2ht * jtzm * dzht, wstar3factcrit )<a name='2419'>
              else    <a name='2420'>
                  ceb = a1i / ( jbbu * lbulk )<a name='2421'>
                  wstar3fact = max( 1._r8 + 2.5_r8 * cet * n2ht * jtzm * dzht &amp;<a name='2422'>
                                          + 2.5_r8 * ceb * n2hb * jbzm * dzhb, wstar3factcrit )<a name='2423'>
              end if<a name='2424'>
              wstar3 = wstar3 / wstar3fact       <a name='2425'>
          else <font color=#447700>! wstar3 == 0<a name='2426'></font>
              wstar3fact = 0._r8 <font color=#447700>! This is just for dianostic output<a name='2427'></font>
              cet        = 0._r8<a name='2428'>
              ceb        = 0._r8<a name='2429'>
          end if <a name='2430'>
<a name='2431'>
          <font color=#447700>! ---------------------------------------------------------------------------- !<a name='2432'></font>
          <font color=#447700>! Calculate net CL mean TKE including entrainment contribution by solving a    !<a name='2433'></font>
          <font color=#447700>! canonical cubic equation. The solution of cubic equ. is 'rootp**2 = ebrk'    !<a name='2434'></font>
          <font color=#447700>! where 'ebrk' originally (before solving cubic eq.) was interior CL mean TKE, !<a name='2435'></font>
          <font color=#447700>! but after solving cubic equation,  it is replaced by net CL mean TKE in the  !<a name='2436'></font>
          <font color=#447700>! same variable 'ebrk'.                                                        !<a name='2437'></font>
          <font color=#447700>! ---------------------------------------------------------------------------- !<a name='2438'></font>
          <font color=#447700>! Solve cubic equation (canonical form for analytic solution)                  !<a name='2439'></font>
          <font color=#447700>!   r^3 - 3*trmp*r - 2*trmq = 0,   r = sqrt&lt;e&gt;                                 ! <a name='2440'></font>
          <font color=#447700>! to estimate &lt;e&gt; for CL, derived from layer-mean TKE balance:                 !<a name='2441'></font>
          <font color=#447700>!                                                                              !<a name='2442'></font>
          <font color=#447700>!   &lt;e&gt;^(3/2)/(b_1*&lt;l&gt;) \approx &lt;B + S&gt;   (*)                                  !<a name='2443'></font>
          <font color=#447700>!   &lt;B+S&gt; = (&lt;B+S&gt;_int * l_int + &lt;B+S&gt;_et * dzt + &lt;B+S&gt;_eb * dzb)/lbulk        !<a name='2444'></font>
          <font color=#447700>!   &lt;B+S&gt;_int = &lt;e&gt;^(1/2)/(b_1*&lt;l&gt;)*&lt;e&gt;_int                                    !<a name='2445'></font>
          <font color=#447700>!   &lt;B+S&gt;_et  = (-vyt+vut)*wet*jtbu + radf                                     !<a name='2446'></font>
          <font color=#447700>!   &lt;B+S&gt;_eb  = (-vyb+vub)*web*jbbu                                            !<a name='2447'></font>
          <font color=#447700>!                                                                              !<a name='2448'></font>
          <font color=#447700>! where:                                                                       !<a name='2449'></font>
          <font color=#447700>!   &lt;&gt; denotes a vertical avg (over the whole CL unless indicated)             !<a name='2450'></font>
          <font color=#447700>!   l_int (called lbrk below) is aggregate thickness of interior CL layers     !<a name='2451'></font>
          <font color=#447700>!   dzt = zi(i,kt)-z(i,kt)   is thickness of top entrainment layer             !<a name='2452'></font>
          <font color=#447700>!   dzb = z(i,kb-1)-zi(i,kb) is thickness of bot entrainment layer             !<a name='2453'></font>
          <font color=#447700>!   &lt;e&gt;_int (called ebrk below) is the CL-mean TKE if only interior            !<a name='2454'></font>
          <font color=#447700>!                               interfaces contributed.                        !<a name='2455'></font>
          <font color=#447700>!   wet, web                  are top. bottom entrainment rates                !<a name='2456'></font>
          <font color=#447700>!                                                                              !<a name='2457'></font>
          <font color=#447700>! For a single-level radiatively-driven convective layer, there are no         ! <a name='2458'></font>
          <font color=#447700>! interior interfaces so 'ebrk' = 'lbrk' = 0. If the CL goes to the            !<a name='2459'></font>
          <font color=#447700>! surface, 'vyb' and 'vub' are set to zero before and 'ebrk' and 'lbrk'        !<a name='2460'></font>
          <font color=#447700>! have already incorporated the surface interfacial layer contribution,        !<a name='2461'></font>
          <font color=#447700>! so the same formulas still apply.                                            !<a name='2462'></font>
          <font color=#447700>!                                                                              !<a name='2463'></font>
          <font color=#447700>! In the original formulation based on TKE,                                    !<a name='2464'></font>
          <font color=#447700>!    wet*jtbu = a1l*evhc*&lt;e&gt;^3/2/leng(i,kt)                                    ! <a name='2465'></font>
          <font color=#447700>!    web*jbbu = a1l*&lt;e&gt;^3/2/leng(i,kt)                                         !<a name='2466'></font>
          <font color=#447700>!                                                                              !<a name='2467'></font>
          <font color=#447700>! In the wstar formulation                                                     !<a name='2468'></font>
          <font color=#447700>!    wet*jtbu = a1i*evhc*wstar3/lbulk                                          !<a name='2469'></font>
          <font color=#447700>!    web*jbbu = a1i*wstar3/lbulk,                                              !<a name='2470'></font>
          <font color=#447700>! ---------------------------------------------------------------------------- !<a name='2471'></font>
<a name='2472'>
          fact = ( evhc * ( -vyt + vut ) * dzht + ( -vyb + vub ) * dzhb * leng(i,kb) / leng(i,kt) ) / lbulk<a name='2473'>
<a name='2474'>
          if( wstarent ) then<a name='2475'>
<a name='2476'>
              <font color=#447700>! (Option 1) 'wstar' entrainment formulation <a name='2477'></font>
              <font color=#447700>! Here trmq can have either sign, and will usually be nonzero even for non-<a name='2478'></font>
              <font color=#447700>! cloud topped CLs.  If trmq &gt; 0, there will be two positive roots r; we take <a name='2479'></font>
              <font color=#447700>! the larger one. Why ? If necessary, we limit entrainment and wstar to prevent<a name='2480'></font>
              <font color=#447700>! a solution with r &lt; ccrit*wstar ( Why ? ) where we take ccrit = 0.5. <a name='2481'></font>
<a name='2482'>
              trma = 1._r8          <a name='2483'>
              trmp = ebrk(i,ncv) * ( lbrk(i,ncv) / lbulk ) / 3._r8 + ntzero<a name='2484'>
              trmq = 0.5_r8 * b1 * ( leng(i,kt)  / lbulk ) * ( radf * dzht + a1i * fact * wstar3 )<a name='2485'>
<a name='2486'>
              <font color=#447700>! Check if there is an acceptable root with r &gt; rcrit = ccrit*wstar. <a name='2487'></font>
              <font color=#447700>! To do this, first find local minimum fmin of the cubic f(r) at sqrt(p), <a name='2488'></font>
              <font color=#447700>! and value fcrit = f(rcrit).<a name='2489'></font>
<a name='2490'>
              rmin  = sqrt(trmp)<a name='2491'>
              fmin  = rmin * ( rmin * rmin - 3._r8 * trmp ) - 2._r8 * trmq<a name='2492'>
              wstar = wstar3**onet<a name='2493'>
              rcrit = ccrit * wstar<a name='2494'>
              fcrit = rcrit * ( rcrit * rcrit - 3._r8 * trmp ) - 2._r8 * trmq<a name='2495'>
<a name='2496'>
              <font color=#447700>! No acceptable root exists (noroot = .true.) if either:<a name='2497'></font>
              <font color=#447700>!    1) rmin &lt; rcrit (in which case cubic is monotone increasing for r &gt; rcrit)<a name='2498'></font>
              <font color=#447700>!       and f(rcrit) &gt; 0.<a name='2499'></font>
              <font color=#447700>! or 2) rmin &gt; rcrit (in which case min of f(r) in r &gt; rcrit is at rmin)<a name='2500'></font>
              <font color=#447700>!       and f(rmin) &gt; 0.  <a name='2501'></font>
              <font color=#447700>! In this case, we reduce entrainment and wstar3 such that r/wstar = ccrit;<a name='2502'></font>
              <font color=#447700>! this changes the coefficients of the cubic.   It might be informative to<a name='2503'></font>
              <font color=#447700>! check when and how many 'noroot' cases occur,  since when 'noroot',   we<a name='2504'></font>
              <font color=#447700>! will impose arbitrary limit on 'wstar3, wet, web, and ebrk' using ccrit.<a name='2505'></font>
<a name='2506'>
              noroot = ( ( rmin .lt. rcrit ) .and. ( fcrit .gt. 0._r8 ) ) &amp;<a name='2507'>
                  .or. ( ( rmin .ge. rcrit ) .and. ( fmin  .gt. 0._r8 ) )<a name='2508'>
              if( noroot ) then <font color=#447700>! Solve cubic for r<a name='2509'></font>
                  trma = 1._r8 - b1 * ( leng(i,kt) / lbulk ) * a1i * fact / ccrit**3<a name='2510'>
                  trma = max( trma, 0.5_r8 )  <font color=#447700>! Limit entrainment enhancement of ebrk<a name='2511'></font>
                  trmp = trmp / trma <a name='2512'>
                  trmq = 0.5_r8 * b1 * ( leng(i,kt) / lbulk ) * radf * dzht / trma<a name='2513'>
              end if   <font color=#447700>! noroot<a name='2514'></font>
<a name='2515'>
              <font color=#447700>! Solve the cubic equation<a name='2516'></font>
<a name='2517'>
              qq = trmq**2 - trmp**3<a name='2518'>
              if( qq .ge. 0._r8 ) then <a name='2519'>
                  rootp = ( trmq + sqrt(qq) )**(1._r8/3._r8) + ( max( trmq - sqrt(qq), 0._r8 ) )**(1._r8/3._r8)<a name='2520'>
              else<a name='2521'>
                  rootp = 2._r8 * sqrt(trmp) * cos( acos( trmq / sqrt(trmp**3) ) / 3._r8 )<a name='2522'>
              end if<a name='2523'>
 <a name='2524'>
              <font color=#447700>! Adjust 'wstar3' only if there is 'noroot'. <a name='2525'></font>
              <font color=#447700>! And calculate entrainment rates at the top and base interfaces.<a name='2526'></font>
<a name='2527'>
              if( noroot )  wstar3 = ( rootp / ccrit )**3     <font color=#447700>! Adjust wstar3 <a name='2528'></font>
              wet = cet * wstar3                              <font color=#447700>! Find entrainment rates<a name='2529'></font>
              if( kb .lt. pver + 1 ) web = ceb * wstar3       <font color=#447700>! When 'kb.eq.pver+1', it was set to web=0. <a name='2530'></font>
<a name='2531'>
          else <font color=#447700>!<a name='2532'></font>
<a name='2533'>
              <font color=#447700>! (Option.2) wstarentr = .false. Use original entrainment formulation.<a name='2534'></font>
              <font color=#447700>! trmp &gt; 0 if there are interior interfaces in CL, trmp = 0 otherwise.<a name='2535'></font>
              <font color=#447700>! trmq &gt; 0 if there is cloudtop radiative cooling, trmq = 0 otherwise.<a name='2536'></font>
             <a name='2537'>
              trma = 1._r8 - b1 * a1l * fact<a name='2538'>
              trma = max( trma, 0.5_r8 )  <font color=#447700>! Prevents runaway entrainment instability<a name='2539'></font>
              trmp = ebrk(i,ncv) * ( lbrk(i,ncv) / lbulk ) / ( 3._r8 * trma )<a name='2540'>
              trmq = 0.5_r8 * b1 * ( leng(i,kt)  / lbulk ) * radf * dzht / trma<a name='2541'>
<a name='2542'>
              qq = trmq**2 - trmp**3<a name='2543'>
              if( qq .ge. 0._r8 ) then <a name='2544'>
                  rootp = ( trmq + sqrt(qq) )**(1._r8/3._r8) + ( max( trmq - sqrt(qq), 0._r8 ) )**(1._r8/3._r8)<a name='2545'>
              else <font color=#447700>! Also part of case 3<a name='2546'></font>
                  rootp = 2._r8 * sqrt(trmp) * cos( acos( trmq / sqrt(trmp**3) ) / 3._r8 )<a name='2547'>
              end if   <font color=#447700>! qq<a name='2548'></font>
<a name='2549'>
             <font color=#447700>! Find entrainment rates and limit them by free-entrainment values a1l*sqrt(e)<a name='2550'></font>
<a name='2551'>
              wet = a1l * rootp * min( evhc * rootp**2 / ( leng(i,kt) * jtbu ), 1._r8 )   <a name='2552'>
              if( kb .lt. pver + 1 ) web = a1l * rootp * min( evhc * rootp**2 / ( leng(i,kb) * jbbu ), 1._r8 )<a name='2553'>
<a name='2554'>
          end if <font color=#447700>! wstarentr<a name='2555'></font>
<a name='2556'>
          <font color=#447700>! ---------------------------------------------------- !<a name='2557'></font>
          <font color=#447700>! Finally, get the net CL mean TKE and normalized TKE  ! <a name='2558'></font>
          <font color=#447700>! ---------------------------------------------------- !<a name='2559'></font>
<a name='2560'>
          ebrk(i,ncv) = rootp**2<a name='2561'>
          ebrk(i,ncv) = min(ebrk(i,ncv),tkemax) <font color=#447700>! Limit CL-avg TKE used for entrainment<a name='2562'></font>
          wbrk(i,ncv) = ebrk(i,ncv)/b1  <a name='2563'>
        <a name='2564'>
          <font color=#447700>! The only way ebrk = 0 is for SRCL which are actually radiatively cooled <a name='2565'></font>
          <font color=#447700>! at top interface. In this case, we remove 'convective' label from the <a name='2566'></font>
          <font color=#447700>! interfaces around this layer. This case should now be impossible, so <a name='2567'></font>
          <font color=#447700>! we flag it. Q: I can't understand why this case is impossible now. Maybe,<a name='2568'></font>
          <font color=#447700>! due to various limiting procedures used in solving cubic equation ? <a name='2569'></font>
          <font color=#447700>! In case of SRCL, 'ebrk' should be positive due to cloud top LW radiative<a name='2570'></font>
          <font color=#447700>! cooling contribution, although 'ebrk(internal)' of SRCL before including<a name='2571'></font>
          <font color=#447700>! entrainment contribution (which include LW cooling contribution also) is<a name='2572'></font>
          <font color=#447700>! zero. <a name='2573'></font>
<a name='2574'>
          if( ebrk(i,ncv) .le. 0._r8 ) then<a name='2575'>
              write(iulog,*) 'CALEDDY: Warning, CL with zero TKE, i, kt, kb ', i, kt, kb<a name='2576'>
#ifdef WRF_PORT<a name='2577'>
              call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_549">(iulog)<a name='2578'>
#endif               <a name='2579'>
              belongcv(i,kt) = .false.<a name='2580'>
              belongcv(i,kb) = .false. <a name='2581'>
          end if<a name='2582'>
          <a name='2583'>
          <font color=#447700>! ----------------------------------------------------------------------- !<a name='2584'></font>
          <font color=#447700>! Calculate complete TKE profiles at all CL interfaces, capped by tkemax. !<a name='2585'></font>
          <font color=#447700>! We approximate TKE = &lt;e&gt; at entrainment interfaces. However when CL is  !<a name='2586'></font>
          <font color=#447700>! based at surface, correct 'tkes' will be inserted to tke(i,pver+1).     !<a name='2587'></font>
          <font color=#447700>! Note that this approximation at CL external interfaces do not influence !<a name='2588'></font>
          <font color=#447700>! numerical calculation since 'e' at external interfaces are not used  in !<a name='2589'></font>
          <font color=#447700>! actual numerical calculation afterward. In addition in order to extract !<a name='2590'></font>
          <font color=#447700>! correct TKE averaged over the PBL in the cumulus scheme,it is necessary !<a name='2591'></font>
          <font color=#447700>! to set e = &lt;e&gt; at the top entrainment interface.  Since net CL mean TKE !<a name='2592'></font>
          <font color=#447700>! 'ebrk' obtained by solving cubic equation already includes tkes  ( tkes !<a name='2593'></font>
          <font color=#447700>! is included when bflxs &gt; 0 but not when bflxs &lt;= 0 into internal ebrk ),!<a name='2594'></font>
          <font color=#447700>! 'tkes' should be written to tke(i,pver+1)                               !<a name='2595'></font>
          <font color=#447700>! ----------------------------------------------------------------------- !<a name='2596'></font>
<a name='2597'>
          <font color=#447700>! 1. At internal interfaces          <a name='2598'></font>
          do k = kb - 1, kt + 1, -1<a name='2599'>
             rcap = ( b1 * ae + wcap(i,k) / wbrk(i,ncv) ) / ( b1 * ae + 1._r8 )<a name='2600'>
             rcap = min( max(rcap,rcapmin), rcapmax )<a name='2601'>
             tke(i,k) = ebrk(i,ncv) * rcap<a name='2602'>
             tke(i,k) = min( tke(i,k), tkemax )<a name='2603'>
             kvh(i,k) = leng(i,k) * sqrt(tke(i,k)) * shcl(i,ncv)<a name='2604'>
             kvm(i,k) = leng(i,k) * sqrt(tke(i,k)) * smcl(i,ncv)<a name='2605'>
             bprod(i,k) = -kvh(i,k) * n2(i,k)<a name='2606'>
             sprod(i,k) =  kvm(i,k) * s2(i,k)<a name='2607'>
             turbtype(i,k) = 2                     <font color=#447700>! CL interior interfaces.<a name='2608'></font>
             sm_aw(i,k) = smcl(i,ncv)/alph1        <font color=#447700>! Diagnostic output for microphysics<a name='2609'></font>
          end do<a name='2610'>
<a name='2611'>
          <font color=#447700>! 2. At CL top entrainment interface<a name='2612'></font>
          kentr = wet * jtzm<a name='2613'>
          kvh(i,kt) = kentr<a name='2614'>
          kvm(i,kt) = kentr<a name='2615'>
          bprod(i,kt) = -kentr * n2ht + radf       <font color=#447700>! I must use 'n2ht' not 'n2'<a name='2616'></font>
          sprod(i,kt) =  kentr * s2(i,kt)<a name='2617'>
          turbtype(i,kt) = 4                       <font color=#447700>! CL top entrainment interface<a name='2618'></font>
          trmp = -b1 * ae / ( 1._r8 + b1 * ae )<a name='2619'>
          trmq = -(bprod(i,kt)+sprod(i,kt))*b1*leng(i,kt)/(1._r8+b1*ae)/(ebrk(i,ncv)**(3._r8/2._r8))<a name='2620'>
          rcap = <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_CUBIC'>compute_cubic</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMPUTE_CUBIC_1">(0._r8,trmp,trmq)**2._r8<a name='2621'>
          rcap = min( max(rcap,rcapmin), rcapmax )<a name='2622'>
          tke(i,kt)  = ebrk(i,ncv) * rcap<a name='2623'>
          tke(i,kt)  = min( tke(i,kt), tkemax )<a name='2624'>
          sm_aw(i,kt) = smcl(i,ncv) / alph1        <font color=#447700>! Diagnostic output for microphysics<a name='2625'></font>
<a name='2626'>
          <font color=#447700>! 3. At CL base entrainment interface and double entraining interfaces<a name='2627'></font>
          <font color=#447700>! When current CL base is also the top interface of CL regime below,<a name='2628'></font>
          <font color=#447700>! simply add the two contributions for calculating eddy diffusivity<a name='2629'></font>
          <font color=#447700>! and buoyancy/shear production. Below code correctly works because<a name='2630'></font>
          <font color=#447700>! we (CL regime index) always go from surface upward.<a name='2631'></font>
<a name='2632'>
          if( kb .lt. pver + 1 ) then <a name='2633'>
<a name='2634'>
              kentr = web * jbzm<a name='2635'>
<a name='2636'>
              if( kb .ne. ktblw ) then<a name='2637'>
<a name='2638'>
                  kvh(i,kb) = kentr<a name='2639'>
                  kvm(i,kb) = kentr<a name='2640'>
                  bprod(i,kb) = -kvh(i,kb)*n2hb     <font color=#447700>! I must use 'n2hb' not 'n2'<a name='2641'></font>
                  sprod(i,kb) =  kvm(i,kb)*s2(i,kb)<a name='2642'>
                  turbtype(i,kb) = 3                <font color=#447700>! CL base entrainment interface<a name='2643'></font>
                  trmp = -b1*ae/(1._r8+b1*ae)<a name='2644'>
                  trmq = -(bprod(i,kb)+sprod(i,kb))*b1*leng(i,kb)/(1._r8+b1*ae)/(ebrk(i,ncv)**(3._r8/2._r8))<a name='2645'>
                  rcap = <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_CUBIC'>compute_cubic</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMPUTE_CUBIC_2">(0._r8,trmp,trmq)**2._r8<a name='2646'>
                  rcap = min( max(rcap,rcapmin), rcapmax )<a name='2647'>
                  tke(i,kb)  = ebrk(i,ncv) * rcap<a name='2648'>
                  tke(i,kb)  = min( tke(i,kb),tkemax )<a name='2649'>
<a name='2650'>
              else<a name='2651'>
                  <a name='2652'>
                  kvh(i,kb) = kvh(i,kb) + kentr <a name='2653'>
                  kvm(i,kb) = kvm(i,kb) + kentr<a name='2654'>
                <font color=#447700>! dzhb5 : Half thickness of the lowest  layer of  current CL regime<a name='2655'></font>
                <font color=#447700>! dzht5 : Half thickness of the highest layer of adjacent CL regime just below current CL. <a name='2656'></font>
                  dzhb5 = z(i,kb-1) - zi(i,kb)<a name='2657'>
                  dzht5 = zi(i,kb) - z(i,kb)<a name='2658'>
                  bprod(i,kb) = ( dzht5*bprod(i,kb) - dzhb5*kentr*n2hb )     / ( dzhb5 + dzht5 )<a name='2659'>
                  sprod(i,kb) = ( dzht5*sprod(i,kb) + dzhb5*kentr*s2(i,kb) ) / ( dzhb5 + dzht5 )<a name='2660'>
                  trmp = -b1*ae/(1._r8+b1*ae)<a name='2661'>
                  trmq = -kentr*(s2(i,kb)-n2hb)*b1*leng(i,kb)/(1._r8+b1*ae)/(ebrk(i,ncv)**(3._r8/2._r8))<a name='2662'>
                  rcap = <A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_CUBIC'>compute_cubic</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="COMPUTE_CUBIC_3">(0._r8,trmp,trmq)**2._r8<a name='2663'>
                  rcap = min( max(rcap,rcapmin), rcapmax )<a name='2664'>
                  tke_imsi = ebrk(i,ncv) * rcap<a name='2665'>
                  tke_imsi = min( tke_imsi, tkemax )<a name='2666'>
                  tke(i,kb)  = ( dzht5*tke(i,kb) + dzhb5*tke_imsi ) / ( dzhb5 + dzht5 )               <a name='2667'>
                  tke(i,kb)  = min(tke(i,kb),tkemax)<a name='2668'>
                  turbtype(i,kb) = 5                <font color=#447700>! CL double entraining interface      <a name='2669'></font>
                 <a name='2670'>
              end if<a name='2671'>
<a name='2672'>
           else<a name='2673'>
<a name='2674'>
             <font color=#447700>! If CL base interface is surface, compute similarly using wcap(i,kb)=tkes/b1    <a name='2675'></font>
             <font color=#447700>! Even when bflx &lt; 0, use the same formula in order to impose consistency of<a name='2676'></font>
             <font color=#447700>! tke(i,kb) at bflx = 0._r8<a name='2677'></font>
 <a name='2678'>
             rcap = (b1*ae + wcap(i,kb)/wbrk(i,ncv))/(b1*ae + 1._r8)<a name='2679'>
             rcap = min( max(rcap,rcapmin), rcapmax )<a name='2680'>
             tke(i,kb) = ebrk(i,ncv) * rcap<a name='2681'>
             tke(i,kb) = min( tke(i,kb),tkemax )<a name='2682'>
<a name='2683'>
          end if<a name='2684'>
<a name='2685'>
          <font color=#447700>! For double entraining interface, simply use smcl(i,ncv) of the overlying CL. <a name='2686'></font>
          <font color=#447700>! Below 'sm_aw' is a diagnostic output for use in the microphysics.<a name='2687'></font>
          <font color=#447700>! When 'kb' is surface, 'sm' will be over-written later below.<a name='2688'></font>
<a name='2689'>
          sm_aw(i,kb) = smcl(i,ncv)/alph1             <a name='2690'>
<a name='2691'>
          <font color=#447700>! Calculate wcap at all interfaces of CL. Put a  minimum threshold on TKE<a name='2692'></font>
          <font color=#447700>! to prevent possible division by zero.  'wcap' at CL internal interfaces<a name='2693'></font>
          <font color=#447700>! are already calculated in the first part of 'do ncv' loop correctly.<a name='2694'></font>
          <font color=#447700>! When 'kb.eq.pver+1', below formula produces the identical result to the<a name='2695'></font>
          <font color=#447700>! 'tkes(i)/b1' if leng(i,kb) is set to vk*z(i,pver). Note  wcap(i,pver+1)<a name='2696'></font>
          <font color=#447700>! is already defined as 'tkes(i)/b1' at the first part of caleddy.<a name='2697'></font>
          <a name='2698'>
          wcap(i,kt) = (bprod(i,kt)+sprod(i,kt))*leng(i,kt)/sqrt(max(tke(i,kt),1.e-6_r8))<a name='2699'>
          if( kb .lt. pver + 1 ) then<a name='2700'>
              wcap(i,kb) = (bprod(i,kb)+sprod(i,kb))*leng(i,kb)/sqrt(max(tke(i,kb),1.e-6_r8))<a name='2701'>
          end if<a name='2702'>
<a name='2703'>
          <font color=#447700>! Save the index of upper external interface of current CL-regime in order to<a name='2704'></font>
          <font color=#447700>! handle the case when this interface is also the lower external interface of <a name='2705'></font>
          <font color=#447700>! CL-regime located just above. <a name='2706'></font>
<a name='2707'>
          ktblw = kt <a name='2708'>
<a name='2709'>
          <font color=#447700>! Diagnostic Output<a name='2710'></font>
<a name='2711'>
          wet_CL(i,ncv)        = wet<a name='2712'>
          web_CL(i,ncv)        = web<a name='2713'>
          jtbu_CL(i,ncv)       = jtbu<a name='2714'>
          jbbu_CL(i,ncv)       = jbbu<a name='2715'>
          evhc_CL(i,ncv)       = evhc<a name='2716'>
          jt2slv_CL(i,ncv)     = jt2slv<a name='2717'>
          n2ht_CL(i,ncv)       = n2ht<a name='2718'>
          n2hb_CL(i,ncv)       = n2hb          <a name='2719'>
          lwp_CL(i,ncv)        = lwp<a name='2720'>
          opt_depth_CL(i,ncv)  = opt_depth<a name='2721'>
          radinvfrac_CL(i,ncv) = radinvfrac<a name='2722'>
          radf_CL(i,ncv)       = radf<a name='2723'>
          wstar_CL(i,ncv)      = wstar          <a name='2724'>
          wstar3fact_CL(i,ncv) = wstar3fact          <a name='2725'>
<a name='2726'>
       end do        <font color=#447700>! ncv<a name='2727'></font>
 <a name='2728'>
       <font color=#447700>! Calculate PBL height and characteristic cumulus excess for use in the<a name='2729'></font>
       <font color=#447700>! cumulus convection shceme. Also define turbulence type at the surface<a name='2730'></font>
       <font color=#447700>! when the lowest CL is based at the surface. These are just diagnostic<a name='2731'></font>
       <font color=#447700>! outputs, not influencing numerical calculation of current PBL scheme.<a name='2732'></font>
       <font color=#447700>! If the lowest CL is based at the surface, define the PBL depth as the<a name='2733'></font>
       <font color=#447700>! CL top interface. The same rule is applied for all CLs including SRCL.<a name='2734'></font>
<a name='2735'>
       if( ncvsurf .gt. 0 ) then<a name='2736'>
<a name='2737'>
           ktopbl(i) = ktop(i,ncvsurf)<a name='2738'>
           pblh(i)   = zi(i, ktopbl(i))<a name='2739'>
           pblhp(i)  = pi(i, ktopbl(i))<a name='2740'>
           wpert(i)  = max(wfac*sqrt(ebrk(i,ncvsurf)),wpertmin)<a name='2741'>
           tpert(i)  = max(abs(shflx(i)*rrho(i)/cpair)*tfac/wpert(i),0._r8)<a name='2742'>
           qpert(i)  = max(abs(qflx(i)*rrho(i))*tfac/wpert(i),0._r8)<a name='2743'>
<a name='2744'>
           if( bflxs(i) .gt. 0._r8 ) then<a name='2745'>
               turbtype(i,pver+1) = 2 <font color=#447700>! CL interior interface<a name='2746'></font>
           else<a name='2747'>
               turbtype(i,pver+1) = 3 <font color=#447700>! CL external base interface<a name='2748'></font>
           endif<a name='2749'>
<a name='2750'>
           ipbl(i)  = 1._r8<a name='2751'>
           kpblh(i) = ktopbl(i) - 1._r8<a name='2752'>
<a name='2753'>
       end if <font color=#447700>! End of the calculationf of te properties of surface-based CL.<a name='2754'></font>
<a name='2755'>
       <font color=#447700>! -------------------------------------------- !<a name='2756'></font>
       <font color=#447700>! Treatment of Stable Turbulent Regime ( STL ) !<a name='2757'></font>
       <font color=#447700>! -------------------------------------------- !<a name='2758'></font>
<a name='2759'>
       <font color=#447700>! Identify top and bottom most (internal) interfaces of STL except surface.<a name='2760'></font>
       <font color=#447700>! Also, calculate 'turbulent length scale (leng)' at each STL interfaces.     <a name='2761'></font>
<a name='2762'>
       belongst(i,1) = .false.   <font color=#447700>! k = 1 (top interface) is assumed non-turbulent<a name='2763'></font>
       do k = 2, pver            <font color=#447700>! k is an interface index<a name='2764'></font>
          belongst(i,k) = ( ri(i,k) .lt. ricrit ) .and. ( .not. belongcv(i,k) )<a name='2765'>
          if( belongst(i,k) .and. ( .not. belongst(i,k-1) ) ) then<a name='2766'>
              kt = k             <font color=#447700>! Top interface index of STL<a name='2767'></font>
          elseif( .not. belongst(i,k) .and. belongst(i,k-1) ) then<a name='2768'>
              kb = k - 1         <font color=#447700>! Base interface index of STL<a name='2769'></font>
              lbulk = z(i,kt-1) - z(i,kb)<a name='2770'>
              do ks = kt, kb<a name='2771'>
                 if( choice_tunl .eq. 'rampcl' ) then<a name='2772'>
                     tunlramp = tunl<a name='2773'>
                 elseif( choice_tunl .eq. 'rampsl' ) then<a name='2774'>
                    tunlramp = max( 1.e-3_r8, ctunl * tunl * exp(-log(ctunl)*ri(i,ks)/ricrit) )<a name='2775'>
                  <font color=#447700>! tunlramp = 0.065_r8 + 0.7_r8 * exp(-20._r8*ri(i,ks))<a name='2776'></font>
                 else<a name='2777'>
                    tunlramp = tunl<a name='2778'>
                 endif<a name='2779'>
                 if( choice_leng .eq. 'origin' ) then<a name='2780'>
                     leng(i,ks) = ( (vk*zi(i,ks))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='2781'>
                   <font color=#447700>! leng(i,ks) = vk*zi(i,ks) / (1._r8+vk*zi(i,ks)/(tunlramp*lbulk))<a name='2782'></font>
                 else<a name='2783'>
                     leng(i,ks) = min( vk*zi(i,ks), tunlramp*lbulk )              <a name='2784'>
                 endif<a name='2785'>
              end do<a name='2786'>
          end if<a name='2787'>
       end do <font color=#447700>! k<a name='2788'></font>
<a name='2789'>
       <font color=#447700>! Now look whether STL extends to ground.  If STL extends to surface,<a name='2790'></font>
       <font color=#447700>! re-define master length scale,'lbulk' including surface interfacial<a name='2791'></font>
       <font color=#447700>! layer thickness, and re-calculate turbulent length scale, 'leng' at<a name='2792'></font>
       <font color=#447700>! all STL interfaces again. Note that surface interface is assumed to<a name='2793'></font>
       <font color=#447700>! always be STL if it is not CL.   <a name='2794'></font>
       <a name='2795'>
       belongst(i,pver+1) = .not. belongcv(i,pver+1)<a name='2796'>
<a name='2797'>
       if( belongst(i,pver+1) ) then     <font color=#447700>! kb = pver+1 (surface  STL)<a name='2798'></font>
<a name='2799'>
           turbtype(i,pver+1) = 1        <font color=#447700>! Surface is STL interface<a name='2800'></font>
          <a name='2801'>
           if( belongst(i,pver) ) then   <font color=#447700>! STL includes interior<a name='2802'></font>
             <font color=#447700>! 'kt' already defined above as the top interface of STL<a name='2803'></font>
               lbulk = z(i,kt-1)          <a name='2804'>
           else                          <font color=#447700>! STL with no interior turbulence<a name='2805'></font>
               kt = pver+1<a name='2806'>
               lbulk = z(i,kt-1)<a name='2807'>
           end if<a name='2808'>
<a name='2809'>
           <font color=#447700>! PBL height : Layer mid-point just above the highest STL interface<a name='2810'></font>
           <font color=#447700>! Note in contrast to the surface based CL regime where  PBL height<a name='2811'></font>
           <font color=#447700>! was defined at the top external interface, PBL height of  surface<a name='2812'></font>
           <font color=#447700>! based STL is defined as the layer mid-point.<a name='2813'></font>
<a name='2814'>
           ktopbl(i) = kt - 1<a name='2815'>
           pblh(i)   = z(i,ktopbl(i))<a name='2816'>
           pblhp(i)  = 0.5_r8 * ( pi(i,ktopbl(i)) + pi(i,ktopbl(i)+1) )          <a name='2817'>
<a name='2818'>
           <font color=#447700>! Re-calculate turbulent length scale including surface interfacial<a name='2819'></font>
           <font color=#447700>! layer contribution to lbulk.<a name='2820'></font>
<a name='2821'>
           do ks = kt, pver<a name='2822'>
              if( choice_tunl .eq. 'rampcl' ) then<a name='2823'>
                  tunlramp = tunl<a name='2824'>
              elseif( choice_tunl .eq. 'rampsl' ) then<a name='2825'>
                  tunlramp = max(1.e-3_r8,ctunl*tunl*exp(-log(ctunl)*ri(i,ks)/ricrit))<a name='2826'>
                <font color=#447700>! tunlramp = 0.065_r8 + 0.7_r8 * exp(-20._r8*ri(i,ks))<a name='2827'></font>
              else<a name='2828'>
                  tunlramp = tunl<a name='2829'>
              endif<a name='2830'>
              if( choice_leng .eq. 'origin' ) then<a name='2831'>
                  leng(i,ks) = ( (vk*zi(i,ks))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='2832'>
                <font color=#447700>! leng(i,ks) = vk*zi(i,ks) / (1._r8+vk*zi(i,ks)/(tunlramp*lbulk))<a name='2833'></font>
              else<a name='2834'>
                  leng(i,ks) = min( vk*zi(i,ks), tunlramp*lbulk )              <a name='2835'>
              endif<a name='2836'>
           end do <font color=#447700>! ks<a name='2837'></font>
<a name='2838'>
           <font color=#447700>! Characteristic cumulus excess of surface-based STL.<a name='2839'></font>
           <font color=#447700>! We may be able to use ustar for wpert.<a name='2840'></font>
<a name='2841'>
           wpert(i) = 0._r8 <a name='2842'>
           tpert(i) = max(shflx(i)*rrho(i)/cpair*fak/ustar(i),0._r8) <font color=#447700>! CCM stable-layer forms<a name='2843'></font>
           qpert(i) = max(qflx(i)*rrho(i)*fak/ustar(i),0._r8)<a name='2844'>
<a name='2845'>
           ipbl(i)  = 0._r8<a name='2846'>
           kpblh(i) = ktopbl(i)<a name='2847'>
<a name='2848'>
       end if<a name='2849'>
<a name='2850'>
       <font color=#447700>! Calculate stability functions and energetics at the STL interfaces<a name='2851'></font>
       <font color=#447700>! except the surface. Note that tke(i,pver+1) and wcap(i,pver+1) are<a name='2852'></font>
       <font color=#447700>! already calculated in the first part of 'caleddy', kvm(i,pver+1) &amp;<a name='2853'></font>
       <font color=#447700>! kvh(i,pver+1) were already initialized to be zero, bprod(i,pver+1)<a name='2854'></font>
       <font color=#447700>! &amp; sprod(i,pver+1) were direcly calculated from the bflxs and ustar.<a name='2855'></font>
       <font color=#447700>! Note transport term is assumed to be negligible at STL interfaces.<a name='2856'></font>
           <a name='2857'>
       do k = 2, pver<a name='2858'>
<a name='2859'>
          if( belongst(i,k) ) then<a name='2860'>
<a name='2861'>
              turbtype(i,k) = 1    <font color=#447700>! STL interfaces<a name='2862'></font>
              trma = alph3*alph4exs*ri(i,k) + 2._r8*b1*(alph2-alph4exs*alph5*ri(i,k))<a name='2863'>
              trmb = (alph3+alph4exs)*ri(i,k) + 2._r8*b1*(-alph5*ri(i,k)+alph1)<a name='2864'>
              trmc = ri(i,k)<a name='2865'>
              det = max(trmb*trmb-4._r8*trma*trmc,0._r8)<a name='2866'>
              <font color=#447700>! Sanity Check<a name='2867'></font>
              if( det .lt. 0._r8 ) then<a name='2868'>
                  write(iulog,*) 'The det &lt; 0. for the STL in UW eddy_diff'             <a name='2869'>
#ifdef WRF_PORT<a name='2870'>
                  call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#CALEDDY' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_550">(iulog)<a name='2871'>
#endif                   <a name='2872'>
                  stop<a name='2873'>
              end if                  <a name='2874'>
              gh = (-trmb + sqrt(det))/(2._r8*trma)<a name='2875'>
            <font color=#447700>! gh = min(max(gh,-0.28_r8),0.0233_r8)<a name='2876'></font>
            <font color=#447700>! gh = min(max(gh,-3.5334_r8),0.0233_r8)<a name='2877'></font>
              gh = min(max(gh,ghmin),0.0233_r8)<a name='2878'>
              sh = max(0._r8,alph5/(1._r8+alph3*gh))<a name='2879'>
              sm = max(0._r8,(alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4exs*gh))<a name='2880'>
<a name='2881'>
              tke(i,k)   = b1*(leng(i,k)**2)*(-sh*n2(i,k)+sm*s2(i,k))<a name='2882'>
              tke(i,k)   = min(tke(i,k),tkemax)<a name='2883'>
              wcap(i,k)  = tke(i,k)/b1<a name='2884'>
              kvh(i,k)   = leng(i,k) * sqrt(tke(i,k)) * sh<a name='2885'>
              kvm(i,k)   = leng(i,k) * sqrt(tke(i,k)) * sm<a name='2886'>
              bprod(i,k) = -kvh(i,k) * n2(i,k)<a name='2887'>
              sprod(i,k) =  kvm(i,k) * s2(i,k)<a name='2888'>
<a name='2889'>
              sm_aw(i,k) = sm/alph1     <font color=#447700>! This is diagnostic output for use in the microphysics             <a name='2890'></font>
<a name='2891'>
          end if<a name='2892'>
<a name='2893'>
       end do  <font color=#447700>! k<a name='2894'></font>
<a name='2895'>
       <font color=#447700>! --------------------------------------------------- !<a name='2896'></font>
       <font color=#447700>! End of treatment of Stable Turbulent Regime ( STL ) !<a name='2897'></font>
       <font color=#447700>! --------------------------------------------------- !<a name='2898'></font>
<a name='2899'>
       <font color=#447700>! --------------------------------------------------------------- !<a name='2900'></font>
       <font color=#447700>! Re-computation of eddy diffusivity at the entrainment interface !<a name='2901'></font>
       <font color=#447700>! assuming that it is purely STL (0&lt;Ri&lt;0.19). Note even Ri&gt;0.19,  !<a name='2902'></font>
       <font color=#447700>! turbulent can exist at the entrainment interface since 'Sh,Sm'  !<a name='2903'></font>
       <font color=#447700>! do not necessarily go to zero even when Ri&gt;0.19. Since Ri can   !<a name='2904'></font>
       <font color=#447700>! be fairly larger than 0.19 at the entrainment interface, I      !<a name='2905'></font>
       <font color=#447700>! should set minimum value of 'tke' to be 0. in order to prevent  !<a name='2906'></font>
       <font color=#447700>! sqrt(tke) from being imaginary.                                 !<a name='2907'></font>
       <font color=#447700>! --------------------------------------------------------------- !<a name='2908'></font>
<a name='2909'>
       <font color=#447700>! goto 888<a name='2910'></font>
<a name='2911'>
         do k = 2, pver<a name='2912'>
<a name='2913'>
         if( ( turbtype(i,k) .eq. 3 ) .or. ( turbtype(i,k) .eq. 4 ) .or. &amp;<a name='2914'>
             ( turbtype(i,k) .eq. 5 ) ) then<a name='2915'>
<a name='2916'>
             trma = alph3*alph4exs*ri(i,k) + 2._r8*b1*(alph2-alph4exs*alph5*ri(i,k))<a name='2917'>
             trmb = (alph3+alph4exs)*ri(i,k) + 2._r8*b1*(-alph5*ri(i,k)+alph1)<a name='2918'>
             trmc = ri(i,k)<a name='2919'>
             det  = max(trmb*trmb-4._r8*trma*trmc,0._r8)<a name='2920'>
             gh   = (-trmb + sqrt(det))/(2._r8*trma)<a name='2921'>
           <font color=#447700>! gh   = min(max(gh,-0.28_r8),0.0233_r8)<a name='2922'></font>
           <font color=#447700>! gh   = min(max(gh,-3.5334_r8),0.0233_r8)<a name='2923'></font>
             gh   = min(max(gh,ghmin),0.0233_r8)<a name='2924'>
             sh   = max(0._r8,alph5/(1._r8+alph3*gh))<a name='2925'>
             sm   = max(0._r8,(alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4exs*gh))<a name='2926'>
<a name='2927'>
             lbulk = z(i,k-1) - z(i,k)<a name='2928'>
<a name='2929'>
             if( choice_tunl .eq. 'rampcl' ) then<a name='2930'>
                 tunlramp = tunl<a name='2931'>
             elseif( choice_tunl .eq. 'rampsl' ) then<a name='2932'>
                 tunlramp = max(1.e-3_r8,ctunl*tunl*exp(-log(ctunl)*ri(i,k)/ricrit))<a name='2933'>
               <font color=#447700>! tunlramp = 0.065_r8 + 0.7_r8*exp(-20._r8*ri(i,k))<a name='2934'></font>
             else<a name='2935'>
                 tunlramp = tunl<a name='2936'>
             endif<a name='2937'>
             if( choice_leng .eq. 'origin' ) then<a name='2938'>
                 leng_imsi = ( (vk*zi(i,k))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='2939'>
               <font color=#447700>! leng_imsi = vk*zi(i,k) / (1._r8+vk*zi(i,k)/(tunlramp*lbulk))<a name='2940'></font>
             else<a name='2941'>
                 leng_imsi = min( vk*zi(i,k), tunlramp*lbulk )              <a name='2942'>
             endif<a name='2943'>
<a name='2944'>
             tke_imsi = b1*(leng_imsi**2)*(-sh*n2(i,k)+sm*s2(i,k))<a name='2945'>
             tke_imsi = min(max(tke_imsi,0._r8),tkemax)<a name='2946'>
             kvh_imsi = leng_imsi * sqrt(tke_imsi) * sh<a name='2947'>
             kvm_imsi = leng_imsi * sqrt(tke_imsi) * sm<a name='2948'>
<a name='2949'>
             if( kvh(i,k) .lt. kvh_imsi ) then <a name='2950'>
                 kvh(i,k)   =  kvh_imsi<a name='2951'>
                 kvm(i,k)   =  kvm_imsi<a name='2952'>
                 leng(i,k)  = leng_imsi<a name='2953'>
                 tke(i,k)   =  tke_imsi<a name='2954'>
                 wcap(i,k)  =  tke_imsi / b1<a name='2955'>
                 bprod(i,k) = -kvh_imsi * n2(i,k)<a name='2956'>
                 sprod(i,k) =  kvm_imsi * s2(i,k)<a name='2957'>
                 sm_aw(i,k) =  sm/alph1     <font color=#447700>! This is diagnostic output for use in the microphysics             <a name='2958'></font>
                 turbtype(i,k) = 1          <font color=#447700>! This was added on Dec.10.2009 for use in microphysics.<a name='2959'></font>
             endif<a name='2960'>
<a name='2961'>
         end if<a name='2962'>
<a name='2963'>
         end do<a name='2964'>
<a name='2965'>
 <font color=#447700>! 888   continue <a name='2966'></font>
<a name='2967'>
       <font color=#447700>! ------------------------------------------------------------------ !<a name='2968'></font>
       <font color=#447700>! End of recomputation of eddy diffusivity at entrainment interfaces !<a name='2969'></font>
       <font color=#447700>! ------------------------------------------------------------------ !<a name='2970'></font>
<a name='2971'>
       <font color=#447700>! As an option, we can impose a certain minimum back-ground diffusivity.<a name='2972'></font>
<a name='2973'>
       <font color=#447700>! do k = 1, pver+1<a name='2974'></font>
       <font color=#447700>!    kvh(i,k) = max(0.01_r8,kvh(i,k))<a name='2975'></font>
       <font color=#447700>!    kvm(i,k) = max(0.01_r8,kvm(i,k))<a name='2976'></font>
       <font color=#447700>! enddo<a name='2977'></font>
 <a name='2978'>
       <font color=#447700>! --------------------------------------------------------------------- !<a name='2979'></font>
       <font color=#447700>! Diagnostic Output                                                     !<a name='2980'></font>
       <font color=#447700>! Just for diagnostic purpose, calculate stability functions at  each   !<a name='2981'></font>
       <font color=#447700>! interface including surface. Instead of assuming neutral stability,   !<a name='2982'></font>
       <font color=#447700>! explicitly calculate stability functions using an reverse procedure   !<a name='2983'></font>
       <font color=#447700>! starting from tkes(i) similar to the case of SRCL and SBCL in zisocl. !<a name='2984'></font>
       <font color=#447700>! Note that it is possible to calculate stability functions even when   !<a name='2985'></font>
       <font color=#447700>! bflxs &lt; 0. Note that this inverse method allows us to define Ri even  !<a name='2986'></font>
       <font color=#447700>! at the surface. Note also tkes(i) and sprod(i,pver+1) are always      !<a name='2987'></font>
       <font color=#447700>! positive values by limiters (e.g., ustar_min = 0.01).                 !<a name='2988'></font>
       <font color=#447700>! Dec.12.2006 : Also just for diagnostic output, re-set                 !<a name='2989'></font>
       <font color=#447700>! 'bprod(i,pver+1)= bflxs(i)' here. Note that this setting does not     !<a name='2990'></font>
       <font color=#447700>! influence numerical calculation at all - it is just for diagnostic    !<a name='2991'></font>
       <font color=#447700>! output.                                                               !<a name='2992'></font>
       <font color=#447700>! --------------------------------------------------------------------- !<a name='2993'></font>
<a name='2994'>
       bprod(i,pver+1) = bflxs(i)<a name='2995'>
              <a name='2996'>
       gg = 0.5_r8*vk*z(i,pver)*bprod(i,pver+1)/(tkes(i)**(3._r8/2._r8))<a name='2997'>
       if( abs(alph5-gg*alph3) .le. 1.e-7_r8 ) then<a name='2998'>
         <font color=#447700>! gh = -0.28_r8<a name='2999'></font>
           if( bprod(i,pver+1) .gt. 0._r8 ) then<a name='3000'>
               gh = -3.5334_r8<a name='3001'>
           else<a name='3002'>
               gh = ghmin<a name='3003'>
           endif<a name='3004'>
       else    <a name='3005'>
           gh = gg/(alph5-gg*alph3)<a name='3006'>
       end if <a name='3007'>
<a name='3008'>
     <font color=#447700>! gh = min(max(gh,-0.28_r8),0.0233_r8)<a name='3009'></font>
       if( bprod(i,pver+1) .gt. 0._r8 ) then<a name='3010'>
           gh = min(max(gh,-3.5334_r8),0.0233_r8)<a name='3011'>
       else<a name='3012'>
           gh = min(max(gh,ghmin),0.0233_r8)<a name='3013'>
       endif<a name='3014'>
<a name='3015'>
       gh_a(i,pver+1) = gh     <a name='3016'>
       sh_a(i,pver+1) = max(0._r8,alph5/(1._r8+alph3*gh))<a name='3017'>
       if( bprod(i,pver+1) .gt. 0._r8 ) then       <a name='3018'>
           sm_a(i,pver+1) = max(0._r8,(alph1+alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4*gh))<a name='3019'>
       else<a name='3020'>
           sm_a(i,pver+1) = max(0._r8,(alph1+alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4exs*gh))<a name='3021'>
       endif<a name='3022'>
       sm_aw(i,pver+1) = sm_a(i,pver+1)/alph1<a name='3023'>
       ri_a(i,pver+1)  = -(sm_a(i,pver+1)/sh_a(i,pver+1))*(bprod(i,pver+1)/sprod(i,pver+1))<a name='3024'>
<a name='3025'>
       do k = 1, pver<a name='3026'>
          if( ri(i,k) .lt. 0._r8 ) then<a name='3027'>
              trma = alph3*alph4*ri(i,k) + 2._r8*b1*(alph2-alph4*alph5*ri(i,k))<a name='3028'>
              trmb = (alph3+alph4)*ri(i,k) + 2._r8*b1*(-alph5*ri(i,k)+alph1)<a name='3029'>
              trmc = ri(i,k)<a name='3030'>
              det  = max(trmb*trmb-4._r8*trma*trmc,0._r8)<a name='3031'>
              gh   = (-trmb + sqrt(det))/(2._r8*trma)<a name='3032'>
              gh   = min(max(gh,-3.5334_r8),0.0233_r8)<a name='3033'>
              gh_a(i,k) = gh<a name='3034'>
              sh_a(i,k) = max(0._r8,alph5/(1._r8+alph3*gh))<a name='3035'>
              sm_a(i,k) = max(0._r8,(alph1+alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4*gh))<a name='3036'>
              ri_a(i,k) = ri(i,k)<a name='3037'>
          else<a name='3038'>
              if( ri(i,k) .gt. ricrit ) then<a name='3039'>
                  gh_a(i,k) = ghmin<a name='3040'>
                  sh_a(i,k) = 0._r8<a name='3041'>
                  sm_a(i,k) = 0._r8<a name='3042'>
                  ri_a(i,k) = ri(i,k)<a name='3043'>
              else<a name='3044'>
                  trma = alph3*alph4exs*ri(i,k) + 2._r8*b1*(alph2-alph4exs*alph5*ri(i,k))<a name='3045'>
                  trmb = (alph3+alph4exs)*ri(i,k) + 2._r8*b1*(-alph5*ri(i,k)+alph1)<a name='3046'>
                  trmc = ri(i,k)<a name='3047'>
                  det  = max(trmb*trmb-4._r8*trma*trmc,0._r8)<a name='3048'>
                  gh   = (-trmb + sqrt(det))/(2._r8*trma)<a name='3049'>
                  gh   = min(max(gh,ghmin),0.0233_r8)<a name='3050'>
                  gh_a(i,k) = gh<a name='3051'>
                  sh_a(i,k) = max(0._r8,alph5/(1._r8+alph3*gh))<a name='3052'>
                  sm_a(i,k) = max(0._r8,(alph1+alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4exs*gh))<a name='3053'>
                  ri_a(i,k) = ri(i,k)<a name='3054'>
              endif<a name='3055'>
          endif<a name='3056'>
<a name='3057'>
       end do<a name='3058'>
<a name='3059'>
       do k = 1, pver + 1<a name='3060'>
          turbtype_f(i,k) = real(turbtype(i,k))<a name='3061'>
       end do<a name='3062'>
<a name='3063'>
    end do   <font color=#447700>! End of column index loop, i <a name='3064'></font>
<a name='3065'>
    return<a name='3066'>
<a name='3067'>
    end subroutine caleddy<a name='3068'>
<a name='3069'>
    <font color=#447700>!============================================================================== !<a name='3070'></font>
    <font color=#447700>!                                                                               !<a name='3071'></font>
    <font color=#447700>!============================================================================== !<a name='3072'></font>
<a name='3073'>
<A NAME='EXACOL'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#EXACOL' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3074'>
    <font color=#993300>subroutine </font><font color=#cc0000>exacol</font>( pcols, pver, ncol, ri, bflxs, minpblh, zi, ktop, kbase, ncvfin )  <A href='../../call_to/EXACOL.html' TARGET='index'>1</A><a name='3075'>
<a name='3076'>
    <font color=#447700>! ---------------------------------------------------------------------------- !<a name='3077'></font>
    <font color=#447700>! Object : Find unstable CL regimes and determine the indices                  !<a name='3078'></font>
    <font color=#447700>!          kbase, ktop which delimit these unstable layers :                   !<a name='3079'></font>
    <font color=#447700>!          ri(kbase) &gt; 0 and ri(ktop) &gt; 0, but ri(k) &lt; 0 for ktop &lt; k &lt; kbase. ! <a name='3080'></font>
    <font color=#447700>! Author : Chris  Bretherton 08/2000,                                          !<a name='3081'></font>
    <font color=#447700>!          Sungsu Park       08/2006, 11/2008                                  !<a name='3082'></font>
    <font color=#447700>!----------------------------------------------------------------------------- !<a name='3083'></font>
<a name='3084'>
    implicit none<a name='3085'>
<a name='3086'>
    <font color=#447700>! --------------- !<a name='3087'></font>
    <font color=#447700>! Input variables !<a name='3088'></font>
    <font color=#447700>! --------------- !<a name='3089'></font>
<a name='3090'>
    integer,  intent(in) :: pcols                  <font color=#447700>! Number of atmospheric columns   <a name='3091'></font>
    integer,  intent(in) :: pver                   <font color=#447700>! Number of atmospheric vertical layers   <a name='3092'></font>
    integer,  intent(in) :: ncol                   <font color=#447700>! Number of atmospheric columns   <a name='3093'></font>
<a name='3094'>
    real(r8), intent(in) :: ri(pcols,pver)         <font color=#447700>! Moist gradient Richardson no.<a name='3095'></font>
    real(r8), intent(in) :: bflxs(pcols)           <font color=#447700>! Buoyancy flux at surface<a name='3096'></font>
    real(r8), intent(in) :: minpblh(pcols)         <font color=#447700>! Minimum PBL height based on surface stress<a name='3097'></font>
    real(r8), intent(in) :: zi(pcols,pver+1)       <font color=#447700>! Interface heights<a name='3098'></font>
<a name='3099'>
    <font color=#447700>! ---------------- !<a name='3100'></font>
    <font color=#447700>! Output variables !      <a name='3101'></font>
    <font color=#447700>! ---------------- !<a name='3102'></font>
<a name='3103'>
    integer, intent(out) :: kbase(pcols,ncvmax)    <font color=#447700>! External interface index of CL base<a name='3104'></font>
    integer, intent(out) :: ktop(pcols,ncvmax)     <font color=#447700>! External interface index of CL top<a name='3105'></font>
    integer, intent(out) :: ncvfin(pcols)          <font color=#447700>! Total number of CLs<a name='3106'></font>
<a name='3107'>
    <font color=#447700>! --------------- !<a name='3108'></font>
    <font color=#447700>! Local variables !<a name='3109'></font>
    <font color=#447700>! --------------- !<a name='3110'></font>
<a name='3111'>
    integer              :: i<a name='3112'>
    integer              :: k<a name='3113'>
    integer              :: ncv<a name='3114'>
    real(r8)             :: rimaxentr<a name='3115'>
    real(r8)             :: riex(pver+1)           <font color=#447700>! Column Ri profile extended to surface<a name='3116'></font>
<a name='3117'>
    <font color=#447700>! ----------------------- !<a name='3118'></font>
    <font color=#447700>! Main Computation Begins !<a name='3119'></font>
    <font color=#447700>! ----------------------- !<a name='3120'></font>
<a name='3121'>
    do i = 1, ncol<a name='3122'>
       ncvfin(i) = 0<a name='3123'>
       do ncv = 1, ncvmax<a name='3124'>
          ktop(i,ncv)  = 0<a name='3125'>
          kbase(i,ncv) = 0<a name='3126'>
       end do<a name='3127'>
    end do<a name='3128'>
<a name='3129'>
    <font color=#447700>! ------------------------------------------------------ !<a name='3130'></font>
    <font color=#447700>! Find CL regimes starting from the surface going upward !<a name='3131'></font>
    <font color=#447700>! ------------------------------------------------------ !<a name='3132'></font>
    <a name='3133'>
    rimaxentr = 0._r8   <a name='3134'>
    <a name='3135'>
    do i = 1, ncol<a name='3136'>
<a name='3137'>
       riex(2:pver) = ri(i,2:pver)<a name='3138'>
<a name='3139'>
       <font color=#447700>! Below allows consistent treatment of surface and other interfaces.<a name='3140'></font>
       <font color=#447700>! Simply, if surface buoyancy flux is positive, Ri of surface is set to be negative.<a name='3141'></font>
<a name='3142'>
       riex(pver+1) = rimaxentr - bflxs(i) <a name='3143'>
<a name='3144'>
       ncv = 0<a name='3145'>
       k   = pver + 1 <font color=#447700>! Work upward from surface interface<a name='3146'></font>
<a name='3147'>
       do while ( k .gt. ntop_turb + 1 )<a name='3148'>
<a name='3149'>
        <font color=#447700>! Below means that if 'bflxs &gt; 0' (do not contain '=' sign), surface<a name='3150'></font>
        <font color=#447700>! interface is energetically interior surface. <a name='3151'></font>
       <a name='3152'>
          if( riex(k) .lt. rimaxentr ) then <a name='3153'>
<a name='3154'>
              <font color=#447700>! Identify a new CL<a name='3155'></font>
<a name='3156'>
              ncv = ncv + 1<a name='3157'>
<a name='3158'>
              <font color=#447700>! First define 'kbase' as the first interface below the lower-most unstable interface<a name='3159'></font>
              <font color=#447700>! Thus, Richardson number at 'kbase' is positive.<a name='3160'></font>
<a name='3161'>
              kbase(i,ncv) = min(k+1,pver+1)<a name='3162'>
<a name='3163'>
              <font color=#447700>! Decrement k until top unstable level<a name='3164'></font>
<a name='3165'>
              do while( riex(k) .lt. rimaxentr .and. k .gt. ntop_turb + 1 )<a name='3166'>
                 k = k - 1<a name='3167'>
              end do<a name='3168'>
<a name='3169'>
              <font color=#447700>! ktop is the first interface above upper-most unstable interface<a name='3170'></font>
              <font color=#447700>! Thus, Richardson number at 'ktop' is positive. <a name='3171'></font>
<a name='3172'>
              ktop(i,ncv) = k<a name='3173'>
             <a name='3174'>
          else<a name='3175'>
<a name='3176'>
              <font color=#447700>! Search upward for a CL.<a name='3177'></font>
<a name='3178'>
              k = k - 1<a name='3179'>
<a name='3180'>
          end if<a name='3181'>
<a name='3182'>
       end do <font color=#447700>! End of CL regime finding for each atmospheric column<a name='3183'></font>
<a name='3184'>
       ncvfin(i) = ncv    <a name='3185'>
<a name='3186'>
    end do  <font color=#447700>! End of atmospheric column do loop<a name='3187'></font>
<a name='3188'>
    return <a name='3189'>
<a name='3190'>
    end subroutine exacol<a name='3191'>
<a name='3192'>
    <font color=#447700>!============================================================================== !<a name='3193'></font>
    <font color=#447700>!                                                                               !<a name='3194'></font>
    <font color=#447700>!============================================================================== !<a name='3195'></font>
    <a name='3196'>
<A NAME='ZISOCL'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#ZISOCL' TARGET='top_target'><IMG SRC="../../gif/bar_red.gif" border=0></A><a name='3197'>
    <font color=#993300>subroutine </font><font color=#cc0000>zisocl</font>( pcols  , pver  , long ,                                 &amp;  <A href='../../call_to/ZISOCL.html' TARGET='index'>1</A>,<A href='../../call_from/ZISOCL.html' TARGET='index'>2</A><a name='3198'>
                       z      , zi    , n2   ,  s2      ,                      &amp; <a name='3199'>
                       bprod  , sprod , bflxs,  tkes    ,                      &amp; <a name='3200'>
                       ncvfin , kbase , ktop ,  belongcv,                      &amp; <a name='3201'>
                       ricl   , ghcl  , shcl ,  smcl    ,                      &amp;<a name='3202'>
                       lbrk   , wbrk  , ebrk ,  extend  , extend_up, extend_dn )<a name='3203'>
<a name='3204'>
    <font color=#447700>!------------------------------------------------------------------------ !<a name='3205'></font>
    <font color=#447700>! Object : This 'zisocl' vertically extends original CLs identified from  !<a name='3206'></font>
    <font color=#447700>!          'exacol' using a merging test based on either 'wint' or 'l2n2' !<a name='3207'></font>
    <font color=#447700>!          and identify new CL regimes. Similar to the case of 'exacol',  !<a name='3208'></font>
    <font color=#447700>!          CL regime index increases with height.  After identifying new  !<a name='3209'></font>
    <font color=#447700>!          CL regimes ( kbase, ktop, ncvfin ),calculate CL internal mean  !<a name='3210'></font>
    <font color=#447700>!          energetics (lbrk : energetic thickness integral, wbrk, ebrk )  !<a name='3211'></font>
    <font color=#447700>!          and stability functions (ricl, ghcl, shcl, smcl) by including  !<a name='3212'></font>
    <font color=#447700>!          surface interfacial layer contribution when bflxs &gt; 0.   Note  !<a name='3213'></font>
    <font color=#447700>!          that there are two options in the treatment of the energetics  !<a name='3214'></font>
    <font color=#447700>!          of surface interfacial layer (use_dw_surf= 'true' or 'false')  !<a name='3215'></font>
    <font color=#447700>! Author : Sungsu Park 08/2006, 11/2008                                   !<a name='3216'></font>
    <font color=#447700>!------------------------------------------------------------------------ !<a name='3217'></font>
<a name='3218'>
    implicit none<a name='3219'>
<a name='3220'>
    <font color=#447700>! --------------- !    <a name='3221'></font>
    <font color=#447700>! Input variables !<a name='3222'></font>
    <font color=#447700>! --------------- !<a name='3223'></font>
<a name='3224'>
    integer,  intent(in)   :: long                    <font color=#447700>! Longitude of the column<a name='3225'></font>
    integer,  intent(in)   :: pcols                   <font color=#447700>! Number of atmospheric columns   <a name='3226'></font>
    integer,  intent(in)   :: pver                    <font color=#447700>! Number of atmospheric vertical layers   <a name='3227'></font>
    real(r8), intent(in)   :: z(pcols, pver)          <font color=#447700>! Layer mid-point height [ m ]<a name='3228'></font>
    real(r8), intent(in)   :: zi(pcols, pver+1)       <font color=#447700>! Interface height [ m ]<a name='3229'></font>
    real(r8), intent(in)   :: n2(pcols, pver)         <font color=#447700>! Buoyancy frequency at interfaces except surface [ s-2 ]<a name='3230'></font>
    real(r8), intent(in)   :: s2(pcols, pver)         <font color=#447700>! Shear frequency at interfaces except surface [ s-2 ]<a name='3231'></font>
    real(r8), intent(in)   :: bprod(pcols,pver+1)     <font color=#447700>! Buoyancy production [ m2/s3 ]. bprod(i,pver+1) = bflxs <a name='3232'></font>
    real(r8), intent(in)   :: sprod(pcols,pver+1)     <font color=#447700>! Shear production [ m2/s3 ]. sprod(i,pver+1) = usta**3/(vk*z(i,pver))<a name='3233'></font>
    real(r8), intent(in)   :: bflxs(pcols)            <font color=#447700>! Surface buoyancy flux [ m2/s3 ]. bprod(i,pver+1) = bflxs <a name='3234'></font>
    real(r8), intent(in)   :: tkes(pcols)             <font color=#447700>! TKE at the surface [ s2/s2 ]<a name='3235'></font>
<a name='3236'>
    <font color=#447700>! ---------------------- !<a name='3237'></font>
    <font color=#447700>! Input/output variables !<a name='3238'></font>
    <font color=#447700>! ---------------------- !<a name='3239'></font>
<a name='3240'>
    integer, intent(inout) :: kbase(pcols,ncvmax)     <font color=#447700>! Base external interface index of CL<a name='3241'></font>
    integer, intent(inout) :: ktop(pcols,ncvmax)      <font color=#447700>! Top external interface index of CL<a name='3242'></font>
    integer, intent(inout) :: ncvfin(pcols)           <font color=#447700>! Total number of CLs<a name='3243'></font>
<a name='3244'>
    <font color=#447700>! ---------------- !<a name='3245'></font>
    <font color=#447700>! Output variables !<a name='3246'></font>
    <font color=#447700>! ---------------- !<a name='3247'></font>
<a name='3248'>
    logical,  intent(out) :: belongcv(pcols,pver+1)   <font color=#447700>! True if interface is in a CL ( either internal or external )<a name='3249'></font>
    real(r8), intent(out) :: ricl(pcols,ncvmax)       <font color=#447700>! Mean Richardson number of internal CL<a name='3250'></font>
    real(r8), intent(out) :: ghcl(pcols,ncvmax)       <font color=#447700>! Half of normalized buoyancy production of internal CL<a name='3251'></font>
    real(r8), intent(out) :: shcl(pcols,ncvmax)       <font color=#447700>! Galperin instability function of heat-moisture of internal CL<a name='3252'></font>
    real(r8), intent(out) :: smcl(pcols,ncvmax)       <font color=#447700>! Galperin instability function of momentum of internal CL<a name='3253'></font>
    real(r8), intent(out) :: lbrk(pcols,ncvmax)       <font color=#447700>! Thickness of (energetically) internal CL ( lint, [m] )<a name='3254'></font>
    real(r8), intent(out) :: wbrk(pcols,ncvmax)       <font color=#447700>! Mean normalized TKE of internal CL  [ m2/s2 ]<a name='3255'></font>
    real(r8), intent(out) :: ebrk(pcols,ncvmax)       <font color=#447700>! Mean TKE of internal CL ( b1*wbrk, [m2/s2] )<a name='3256'></font>
<a name='3257'>
    <font color=#447700>! ------------------ !<a name='3258'></font>
    <font color=#447700>! Internal variables !<a name='3259'></font>
    <font color=#447700>! ------------------ !<a name='3260'></font>
<a name='3261'>
    logical               :: extend                   <font color=#447700>! True when CL is extended in zisocl<a name='3262'></font>
    logical               :: extend_up                <font color=#447700>! True when CL is extended upward in zisocl<a name='3263'></font>
    logical               :: extend_dn                <font color=#447700>! True when CL is extended downward in zisocl<a name='3264'></font>
    logical               :: bottom                   <font color=#447700>! True when CL base is at surface ( kb = pver + 1 )<a name='3265'></font>
<a name='3266'>
    integer               :: i                        <font color=#447700>! Local index for the longitude<a name='3267'></font>
    integer               :: ncv                      <font color=#447700>! CL Index increasing with height<a name='3268'></font>
    integer               :: incv<a name='3269'>
    integer               :: k<a name='3270'>
    integer               :: kb                       <font color=#447700>! Local index for kbase<a name='3271'></font>
    integer               :: kt                       <font color=#447700>! Local index for ktop<a name='3272'></font>
    integer               :: ncvinit                  <font color=#447700>! Value of ncv at routine entrance <a name='3273'></font>
    integer               :: cntu                     <font color=#447700>! Number of merged CLs during upward   extension of individual CL<a name='3274'></font>
    integer               :: cntd                     <font color=#447700>! Number of merged CLs during downward extension of individual CL<a name='3275'></font>
    integer               :: kbinc                    <font color=#447700>! Index for incorporating underlying CL<a name='3276'></font>
    integer               :: ktinc                    <font color=#447700>! Index for incorporating  overlying CL<a name='3277'></font>
<a name='3278'>
    real(r8)              :: wint                     <font color=#447700>! Normalized TKE of internal CL<a name='3279'></font>
    real(r8)              :: dwinc                    <font color=#447700>! Normalized TKE of CL external interfaces<a name='3280'></font>
    real(r8)              :: dw_surf                  <font color=#447700>! Normalized TKE of surface interfacial layer<a name='3281'></font>
    real(r8)              :: dzinc<a name='3282'>
    real(r8)              :: gh<a name='3283'>
    real(r8)              :: sh<a name='3284'>
    real(r8)              :: sm<a name='3285'>
    real(r8)              :: gh_surf                  <font color=#447700>! Half of normalized buoyancy production in surface interfacial layer <a name='3286'></font>
    real(r8)              :: sh_surf                  <font color=#447700>! Galperin instability function in surface interfacial layer  <a name='3287'></font>
    real(r8)              :: sm_surf                  <font color=#447700>! Galperin instability function in surface interfacial layer <a name='3288'></font>
    real(r8)              :: l2n2                     <font color=#447700>! Vertical integral of 'l^2N^2' over CL. Include thickness product<a name='3289'></font>
    real(r8)              :: l2s2                     <font color=#447700>! Vertical integral of 'l^2S^2' over CL. Include thickness product<a name='3290'></font>
    real(r8)              :: dl2n2                    <font color=#447700>! Vertical integration of 'l^2*N^2' of CL external interfaces<a name='3291'></font>
    real(r8)              :: dl2s2                    <font color=#447700>! Vertical integration of 'l^2*S^2' of CL external interfaces<a name='3292'></font>
    real(r8)              :: dl2n2_surf               <font color=#447700>! 'dl2n2' defined in the surface interfacial layer<a name='3293'></font>
    real(r8)              :: dl2s2_surf               <font color=#447700>! 'dl2s2' defined in the surface interfacial layer  <a name='3294'></font>
    real(r8)              :: lint                     <font color=#447700>! Thickness of (energetically) internal CL<a name='3295'></font>
    real(r8)              :: dlint                    <font color=#447700>! Interfacial layer thickness of CL external interfaces<a name='3296'></font>
    real(r8)              :: dlint_surf               <font color=#447700>! Surface interfacial layer thickness <a name='3297'></font>
    real(r8)              :: lbulk                    <font color=#447700>! Master Length Scale : Whole CL thickness from top to base external interface<a name='3298'></font>
    real(r8)              :: lz                       <font color=#447700>! Turbulent length scale<a name='3299'></font>
    real(r8)              :: ricll                    <font color=#447700>! Mean Richardson number of internal CL <a name='3300'></font>
    real(r8)              :: trma<a name='3301'>
    real(r8)              :: trmb<a name='3302'>
    real(r8)              :: trmc<a name='3303'>
    real(r8)              :: det<a name='3304'>
    real(r8)              :: zbot                     <font color=#447700>! Height of CL base<a name='3305'></font>
    real(r8)              :: l2rat                    <font color=#447700>! Square of ratio of actual to initial CL (not used)<a name='3306'></font>
    real(r8)              :: gg                       <font color=#447700>! Intermediate variable used for calculating stability functions of SBCL<a name='3307'></font>
    real(r8)              :: tunlramp                 <font color=#447700>! Ramping tunl<a name='3308'></font>
<a name='3309'>
    <font color=#447700>! ----------------------- !<a name='3310'></font>
    <font color=#447700>! Main Computation Begins !<a name='3311'></font>
    <font color=#447700>! ----------------------- ! <a name='3312'></font>
<a name='3313'>
    i = long<a name='3314'>
<a name='3315'>
    <font color=#447700>! Initialize main output variables<a name='3316'></font>
    <a name='3317'>
    do k = 1, ncvmax<a name='3318'>
       ricl(i,k) = 0._r8<a name='3319'>
       ghcl(i,k) = 0._r8<a name='3320'>
       shcl(i,k) = 0._r8<a name='3321'>
       smcl(i,k) = 0._r8<a name='3322'>
       lbrk(i,k) = 0._r8<a name='3323'>
       wbrk(i,k) = 0._r8<a name='3324'>
       ebrk(i,k) = 0._r8<a name='3325'>
    end do<a name='3326'>
    extend    = .false.<a name='3327'>
    extend_up = .false.<a name='3328'>
    extend_dn = .false.<a name='3329'>
<a name='3330'>
    <font color=#447700>! ----------------------------------------------------------- !<a name='3331'></font>
    <font color=#447700>! Loop over each CL to see if any of them need to be extended !<a name='3332'></font>
    <font color=#447700>! ----------------------------------------------------------- !<a name='3333'></font>
<a name='3334'>
    ncv = 1<a name='3335'>
<a name='3336'>
    do while( ncv .le. ncvfin(i) )<a name='3337'>
<a name='3338'>
       ncvinit = ncv<a name='3339'>
       cntu    = 0<a name='3340'>
       cntd    = 0<a name='3341'>
       kb      = kbase(i,ncv) <a name='3342'>
       kt      = ktop(i,ncv)<a name='3343'>
       <a name='3344'>
       <font color=#447700>! ---------------------------------------------------------------------------- !<a name='3345'></font>
       <font color=#447700>! Calculation of CL interior energetics including surface before extension     !<a name='3346'></font>
       <font color=#447700>! ---------------------------------------------------------------------------- !<a name='3347'></font>
       <font color=#447700>! Note that the contribution of interior interfaces (not surface) to 'wint' is !<a name='3348'></font>
       <font color=#447700>! accounted by using '-sh*l2n2 + sm*l2s2' while the contribution of surface is !<a name='3349'></font>
       <font color=#447700>! accounted by using 'dwsurf = tkes/b1' when bflxs &gt; 0. This approach is fully !<a name='3350'></font>
       <font color=#447700>! reasonable. Another possible alternative,  which seems to be also consistent !<a name='3351'></font>
       <font color=#447700>! is to calculate 'dl2n2_surf'  and  'dl2s2_surf' of surface interfacial layer !<a name='3352'></font>
       <font color=#447700>! separately, and this contribution is explicitly added by initializing 'l2n2' !<a name='3353'></font>
       <font color=#447700>! 'l2s2' not by zero, but by 'dl2n2_surf' and 'ds2n2_surf' below.  At the same !<a name='3354'></font>
       <font color=#447700>! time, 'dwsurf' should be excluded in 'wint' calculation below. The only diff.!<a name='3355'></font>
       <font color=#447700>! between two approaches is that in case of the latter approach, contributions !<a name='3356'></font>
       <font color=#447700>! of surface interfacial layer to the CL mean stability function (ri,gh,sh,sm) !<a name='3357'></font>
       <font color=#447700>! are explicitly included while the first approach is not. In this sense,  the !<a name='3358'></font>
       <font color=#447700>! second approach seems to be more conceptually consistent,   but currently, I !<a name='3359'></font>
       <font color=#447700>! (Sungsu) will keep the first default approach. There is a switch             !<a name='3360'></font>
       <font color=#447700>! 'use_dw_surf' at the first part of eddy_diff.F90 chosing one of              !<a name='3361'></font>
       <font color=#447700>! these two options.                                                           !<a name='3362'></font>
       <font color=#447700>! ---------------------------------------------------------------------------- !<a name='3363'></font>
       <a name='3364'>
       <font color=#447700>! ------------------------------------------------------ !   <a name='3365'></font>
       <font color=#447700>! Step 0: Calculate surface interfacial layer energetics !<a name='3366'></font>
       <font color=#447700>! ------------------------------------------------------ !<a name='3367'></font>
<a name='3368'>
       lbulk      = zi(i,kt) - zi(i,kb)<a name='3369'>
       dlint_surf = 0._r8<a name='3370'>
       dl2n2_surf = 0._r8<a name='3371'>
       dl2s2_surf = 0._r8<a name='3372'>
       dw_surf    = 0._r8<a name='3373'>
       if( kb .eq. pver+1 ) then<a name='3374'>
<a name='3375'>
           if( bflxs(i) .gt. 0._r8 ) then<a name='3376'>
<a name='3377'>
               <font color=#447700>! Calculate stability functions of surface interfacial layer<a name='3378'></font>
               <font color=#447700>! from the given 'bprod(i,pver+1)' and 'sprod(i,pver+1)' using<a name='3379'></font>
               <font color=#447700>! inverse approach. Since alph5&gt;0 and alph3&lt;0, denominator of<a name='3380'></font>
               <font color=#447700>! gg is always positive if bprod(i,pver+1)&gt;0.               <a name='3381'></font>
<a name='3382'>
               gg    = 0.5_r8*vk*z(i,pver)*bprod(i,pver+1)/(tkes(i)**(3._r8/2._r8))<a name='3383'>
               gh    = gg/(alph5-gg*alph3)<a name='3384'>
             <font color=#447700>! gh    = min(max(gh,-0.28_r8),0.0233_r8)<a name='3385'></font>
               gh    = min(max(gh,-3.5334_r8),0.0233_r8)<a name='3386'>
               sh    = alph5/(1._r8+alph3*gh)<a name='3387'>
               sm    = (alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4*gh)<a name='3388'>
               ricll = min(-(sm/sh)*(bprod(i,pver+1)/sprod(i,pver+1)),ricrit)<a name='3389'>
<a name='3390'>
               <font color=#447700>! Calculate surface interfacial layer contribution to CL internal<a name='3391'></font>
               <font color=#447700>! energetics. By construction, 'dw_surf = -dl2n2_surf + ds2n2_surf'<a name='3392'></font>
               <font color=#447700>! is exactly satisfied, which corresponds to assuming turbulent<a name='3393'></font>
               <font color=#447700>! length scale of surface interfacial layer = vk * z(i,pver). Note<a name='3394'></font>
               <font color=#447700>! 'dl2n2_surf','dl2s2_surf','dw_surf' include thickness product.   <a name='3395'></font>
<a name='3396'>
               dlint_surf = z(i,pver)<a name='3397'>
               dl2n2_surf = -vk*(z(i,pver)**2)*bprod(i,pver+1)/(sh*sqrt(tkes(i)))<a name='3398'>
               dl2s2_surf =  vk*(z(i,pver)**2)*sprod(i,pver+1)/(sm*sqrt(tkes(i)))<a name='3399'>
               dw_surf    = (tkes(i)/b1)*z(i,pver) <a name='3400'>
<a name='3401'>
           else<a name='3402'>
<a name='3403'>
               <font color=#447700>! Note that this case can happen when surface is an external <a name='3404'></font>
               <font color=#447700>! interface of CL.<a name='3405'></font>
               lbulk = zi(i,kt) - z(i,pver)<a name='3406'>
<a name='3407'>
           end if<a name='3408'>
<a name='3409'>
       end if<a name='3410'>
           <a name='3411'>
       <font color=#447700>! ------------------------------------------------------ !   <a name='3412'></font>
       <font color=#447700>! Step 1: Include surface interfacial layer contribution !<a name='3413'></font>
       <font color=#447700>! ------------------------------------------------------ !<a name='3414'></font>
       <a name='3415'>
       lint = dlint_surf<a name='3416'>
       l2n2 = dl2n2_surf<a name='3417'>
       l2s2 = dl2s2_surf          <a name='3418'>
       wint = dw_surf<a name='3419'>
       if( use_dw_surf ) then<a name='3420'>
           l2n2 = 0._r8<a name='3421'>
           l2s2 = 0._r8<a name='3422'>
       else<a name='3423'>
           wint = 0._r8<a name='3424'>
       end if    <a name='3425'>
       <a name='3426'>
       <font color=#447700>! --------------------------------------------------------------------------------- !<a name='3427'></font>
       <font color=#447700>! Step 2. Include the contribution of 'pure internal interfaces' other than surface !<a name='3428'></font>
       <font color=#447700>! --------------------------------------------------------------------------------- ! <a name='3429'></font>
       <a name='3430'>
       if( kt .lt. kb - 1 ) then <font color=#447700>! The case of non-SBCL.<a name='3431'></font>
                              <a name='3432'>
           do k = kb - 1, kt + 1, -1       <a name='3433'>
              if( choice_tunl .eq. 'rampcl' ) then<a name='3434'>
                <font color=#447700>! Modification : I simply used the average tunlramp between the two limits.<a name='3435'></font>
                  tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3436'>
              elseif( choice_tunl .eq. 'rampsl' ) then<a name='3437'>
                  tunlramp = ctunl*tunl<a name='3438'>
                <font color=#447700>! tunlramp = 0.765_r8<a name='3439'></font>
              else<a name='3440'>
                  tunlramp = tunl<a name='3441'>
              endif<a name='3442'>
              if( choice_leng .eq. 'origin' ) then<a name='3443'>
                  lz = ( (vk*zi(i,k))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3444'>
                <font color=#447700>! lz = vk*zi(i,k) / (1._r8+vk*zi(i,k)/(tunlramp*lbulk))<a name='3445'></font>
              else<a name='3446'>
                  lz = min( vk*zi(i,k), tunlramp*lbulk )              <a name='3447'>
              endif<a name='3448'>
              dzinc = z(i,k-1) - z(i,k)<a name='3449'>
              l2n2  = l2n2 + lz*lz*n2(i,k)*dzinc<a name='3450'>
              l2s2  = l2s2 + lz*lz*s2(i,k)*dzinc<a name='3451'>
              lint  = lint + dzinc<a name='3452'>
           end do<a name='3453'>
<a name='3454'>
           <font color=#447700>! Calculate initial CL stability functions (gh,sh,sm) and net<a name='3455'></font>
           <font color=#447700>! internal energy of CL including surface contribution if any. <a name='3456'></font>
<a name='3457'>
         <font color=#447700>! Modification : It seems that below cannot be applied when ricrit &gt; 0.19.<a name='3458'></font>
         <font color=#447700>!                May need future generalization.<a name='3459'></font>
<a name='3460'>
           ricll = min(l2n2/max(l2s2,ntzero),ricrit) <font color=#447700>! Mean Ri of internal CL<a name='3461'></font>
           trma  = alph3*alph4*ricll+2._r8*b1*(alph2-alph4*alph5*ricll)<a name='3462'>
           trmb  = ricll*(alph3+alph4)+2._r8*b1*(-alph5*ricll+alph1)<a name='3463'>
           trmc  = ricll<a name='3464'>
           det   = max(trmb*trmb-4._r8*trma*trmc,0._r8)<a name='3465'>
           gh    = (-trmb + sqrt(det))/2._r8/trma<a name='3466'>
         <font color=#447700>! gh    = min(max(gh,-0.28_r8),0.0233_r8)<a name='3467'></font>
           gh    = min(max(gh,-3.5334_r8),0.0233_r8)<a name='3468'>
           sh    = alph5/(1._r8+alph3*gh)<a name='3469'>
           sm    = (alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4*gh)<a name='3470'>
           wint  = wint - sh*l2n2 + sm*l2s2 <a name='3471'>
<a name='3472'>
       else <font color=#447700>! The case of SBCL<a name='3473'></font>
 <a name='3474'>
           <font color=#447700>! If there is no pure internal interface, use only surface interfacial<a name='3475'></font>
           <font color=#447700>! values. However, re-set surface interfacial values such  that it can<a name='3476'></font>
           <font color=#447700>! be used in the merging tests (either based on 'wint' or 'l2n2')  and<a name='3477'></font>
           <font color=#447700>! in such that surface interfacial energy is not double-counted.<a name='3478'></font>
           <font color=#447700>! Note that regardless of the choise of 'use_dw_surf', below should be<a name='3479'></font>
           <font color=#447700>! kept as it is below, for consistent merging test of extending SBCL. <a name='3480'></font>
       <a name='3481'>
           lint = dlint_surf<a name='3482'>
           l2n2 = dl2n2_surf<a name='3483'>
           l2s2 = dl2s2_surf <a name='3484'>
           wint = dw_surf<a name='3485'>
<a name='3486'>
           <font color=#447700>! Aug.29.2006 : Only for the purpose of merging test of extending SRCL<a name='3487'></font>
           <font color=#447700>! based on 'l2n2', re-define 'l2n2' of surface interfacial layer using<a name='3488'></font>
           <font color=#447700>! 'wint'. This part is designed for similar treatment of merging as in<a name='3489'></font>
           <font color=#447700>! the original 'eddy_diff.F90' code,  where 'l2n2' of SBCL was defined<a name='3490'></font>
           <font color=#447700>! as 'l2n2 = - wint / sh'. Note that below block is used only when (1)<a name='3491'></font>
           <font color=#447700>! surface buoyancy production 'bprod(i,pver+1)' is NOT included in the<a name='3492'></font>
           <font color=#447700>! calculation of surface TKE in the initialization of 'bprod(i,pver+1)'<a name='3493'></font>
           <font color=#447700>! in the main subroutine ( even though bflxs &gt; 0 ), and (2) to force <a name='3494'></font>
           <font color=#447700>! current scheme be similar to the previous scheme in the treatment of  <a name='3495'></font>
           <font color=#447700>! extending-merging test of SBCL based on 'l2n2'. Otherwise below line<a name='3496'></font>
           <font color=#447700>! must be commented out. Note at this stage, correct non-zero value of<a name='3497'></font>
           <font color=#447700>! 'sh' has been already computed.      <a name='3498'></font>
<a name='3499'>
           if( choice_tkes .eq. 'ebprod' ) then<a name='3500'>
               l2n2 = - wint / sh <a name='3501'>
           endif<a name='3502'>
           <a name='3503'>
       endif<a name='3504'>
           <a name='3505'>
       <font color=#447700>! Set consistent upper limits on 'l2n2' and 'l2s2'. Below limits are<a name='3506'></font>
       <font color=#447700>! reasonable since l2n2 of CL interior interface is always negative.<a name='3507'></font>
<a name='3508'>
       l2n2 = -min(-l2n2, tkemax*lint/(b1*sh))<a name='3509'>
       l2s2 =  min( l2s2, tkemax*lint/(b1*sm))<a name='3510'>
       <a name='3511'>
       <font color=#447700>! Note that at this stage, ( gh, sh, sm )  are the values of surface<a name='3512'></font>
       <font color=#447700>! interfacial layer if there is no pure internal interface, while if<a name='3513'></font>
       <font color=#447700>! there is pure internal interface, ( gh, sh, sm ) are the values of<a name='3514'></font>
       <font color=#447700>! pure CL interfaces or the values that include both the CL internal<a name='3515'></font>
       <font color=#447700>! interfaces and surface interfaces, depending on the 'use_dw_surf'.       <a name='3516'></font>
       <a name='3517'>
       <font color=#447700>! ----------------------------------------------------------------------- !<a name='3518'></font>
       <font color=#447700>! Perform vertical extension-merging process                              !<a name='3519'></font>
       <font color=#447700>! ----------------------------------------------------------------------- !<a name='3520'></font>
       <font color=#447700>! During the merging process, we assumed ( lbulk, sh, sm ) of CL external !<a name='3521'></font>
       <font color=#447700>! interfaces are the same as the ones of the original merging CL. This is !<a name='3522'></font>
       <font color=#447700>! an inevitable approximation since we don't know  ( sh, sm ) of external !<a name='3523'></font>
       <font color=#447700>! interfaces at this stage.     Note that current default merging test is !<a name='3524'></font>
       <font color=#447700>! purely based on buoyancy production without including shear production, !<a name='3525'></font>
       <font color=#447700>! since we used 'l2n2' instead of 'wint' as a merging parameter. However, !<a name='3526'></font>
       <font color=#447700>! merging test based on 'wint' maybe conceptually more attractable.       !<a name='3527'></font>
       <font color=#447700>! Downward CL merging process is identical to the upward merging process, !<a name='3528'></font>
       <font color=#447700>! but when the base of extended CL reaches to the surface, surface inter  !<a name='3529'></font>
       <font color=#447700>! facial layer contribution to the energetic of extended CL must be done  !<a name='3530'></font>
       <font color=#447700>! carefully depending on the sign of surface buoyancy flux. The contribu  !<a name='3531'></font>
       <font color=#447700>! tion of surface interfacial layer energetic is included to the internal !<a name='3532'></font>
       <font color=#447700>! energetics of merging CL only when bflxs &gt; 0.                           !<a name='3533'></font>
       <font color=#447700>! ----------------------------------------------------------------------- !<a name='3534'></font>
       <a name='3535'>
       <font color=#447700>! ---------------------------- !<a name='3536'></font>
       <font color=#447700>! Step 1. Extend the CL upward !<a name='3537'></font>
       <font color=#447700>! ---------------------------- !<a name='3538'></font>
       <a name='3539'>
       extend = .false.    <font color=#447700>! This will become .true. if CL top or base is extended<a name='3540'></font>
<a name='3541'>
       <font color=#447700>! Calculate contribution of potentially incorporable CL top interface<a name='3542'></font>
<a name='3543'>
       if( choice_tunl .eq. 'rampcl' ) then<a name='3544'>
           tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3545'>
       elseif( choice_tunl .eq. 'rampsl' ) then<a name='3546'>
           tunlramp = ctunl*tunl<a name='3547'>
         <font color=#447700>! tunlramp = 0.765_r8<a name='3548'></font>
       else<a name='3549'>
           tunlramp = tunl<a name='3550'>
       endif<a name='3551'>
       if( choice_leng .eq. 'origin' ) then<a name='3552'>
           lz = ( (vk*zi(i,kt))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3553'>
         <font color=#447700>! lz = vk*zi(i,kt) / (1._r8+vk*zi(i,kt)/(tunlramp*lbulk))<a name='3554'></font>
       else<a name='3555'>
           lz = min( vk*zi(i,kt), tunlramp*lbulk )              <a name='3556'>
       endif<a name='3557'>
<a name='3558'>
       dzinc = z(i,kt-1)-z(i,kt)<a name='3559'>
       dl2n2 = lz*lz*n2(i,kt)*dzinc<a name='3560'>
       dl2s2 = lz*lz*s2(i,kt)*dzinc<a name='3561'>
       dwinc = -sh*dl2n2 + sm*dl2s2<a name='3562'>
<a name='3563'>
       <font color=#447700>! ------------ !<a name='3564'></font>
       <font color=#447700>! Merging Test !<a name='3565'></font>
       <font color=#447700>! ------------ !<a name='3566'></font>
 <a name='3567'>
     <font color=#447700>! do while (  dwinc .gt. ( rinc*dzinc*wint/(lint+(1._r8-rinc)*dzinc)) )  ! Merging test based on wint<a name='3568'></font>
     <font color=#447700>! do while ( -dl2n2 .gt. (-rinc*dzinc*l2n2/(lint+(1._r8-rinc)*dzinc)) )  ! Merging test based on l2n2 <a name='3569'></font>
#ifndef WRF_PORT<a name='3570'>
       do while ( -dl2n2 .gt. (-rinc*l2n2/(1._r8-rinc)) )                     <font color=#447700>! Integral merging test<a name='3571'></font>
#else<a name='3572'>
       do while ( -dl2n2 .gt. (-rinc*l2n2/(1._r8-rinc)) .and. kt-1 .gt. ntop_turb )                     <font color=#447700>! Integral merging test<a name='3573'></font>
#endif<a name='3574'>
<a name='3575'>
          <font color=#447700>! Add contribution of top external interface to interior energy.<a name='3576'></font>
          <font color=#447700>! Note even when we chose 'use_dw_surf='true.', the contribution<a name='3577'></font>
          <font color=#447700>! of surface interfacial layer to 'l2n2' and 'l2s2' are included<a name='3578'></font>
          <font color=#447700>! here. However it is not double counting of surface interfacial<a name='3579'></font>
          <font color=#447700>! energy : surface interfacial layer energy is counted in 'wint'<a name='3580'></font>
          <font color=#447700>! formula and 'l2n2' is just used for performing merging test in<a name='3581'></font>
          <font color=#447700>! this 'do while' loop.     <a name='3582'></font>
<a name='3583'>
          lint = lint + dzinc<a name='3584'>
          l2n2 = l2n2 + dl2n2<a name='3585'>
          l2n2 = -min(-l2n2, tkemax*lint/(b1*sh))<a name='3586'>
          l2s2 = l2s2 + dl2s2<a name='3587'>
          wint = wint + dwinc<a name='3588'>
<a name='3589'>
          <font color=#447700>! Extend top external interface of CL upward after merging<a name='3590'></font>
<a name='3591'>
          kt        = kt - 1<a name='3592'>
          extend    = .true.<a name='3593'>
          extend_up = .true.<a name='3594'>
          if( kt .eq. ntop_turb ) then<a name='3595'>
              write(iulog,*) 'zisocl: Error: Tried to extend CL to the model top'<a name='3596'>
#ifdef WRF_PORT<a name='3597'>
              call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#ZISOCL' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_551">(iulog)<a name='3598'>
#endif <a name='3599'>
              stop<a name='3600'>
          end if<a name='3601'>
<a name='3602'>
          <font color=#447700>! If the top external interface of extending CL is the same as the <a name='3603'></font>
          <font color=#447700>! top interior interface of the overlying CL, overlying CL will be<a name='3604'></font>
          <font color=#447700>! automatically merged. Then,reduce total number of CL regime by 1. <a name='3605'></font>
          <font color=#447700>! and increase 'cntu'(number of merged CLs during upward extension)<a name='3606'></font>
          <font color=#447700>! by 1.<a name='3607'></font>
 <a name='3608'>
          ktinc = kbase(i,ncv+cntu+1) - 1  <font color=#447700>! Lowest interior interface of overlying CL<a name='3609'></font>
<a name='3610'>
          if( kt .eq. ktinc ) then<a name='3611'>
<a name='3612'>
              do k = kbase(i,ncv+cntu+1) - 1, ktop(i,ncv+cntu+1) + 1, -1<a name='3613'>
<a name='3614'>
                 if( choice_tunl .eq. 'rampcl' ) then<a name='3615'>
                     tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3616'>
                 elseif( choice_tunl .eq. 'rampsl' ) then<a name='3617'>
                     tunlramp = ctunl*tunl<a name='3618'>
                   <font color=#447700>! tunlramp = 0.765_r8<a name='3619'></font>
                 else<a name='3620'>
                     tunlramp = tunl<a name='3621'>
                 endif<a name='3622'>
                 if( choice_leng .eq. 'origin' ) then<a name='3623'>
                     lz = ( (vk*zi(i,k))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3624'>
                   <font color=#447700>! lz = vk*zi(i,k) / (1._r8+vk*zi(i,k)/(tunlramp*lbulk))<a name='3625'></font>
                 else<a name='3626'>
                     lz = min( vk*zi(i,k), tunlramp*lbulk )              <a name='3627'>
                 endif<a name='3628'>
<a name='3629'>
                 dzinc = z(i,k-1)-z(i,k)<a name='3630'>
                 dl2n2 = lz*lz*n2(i,k)*dzinc<a name='3631'>
                 dl2s2 = lz*lz*s2(i,k)*dzinc<a name='3632'>
                 dwinc = -sh*dl2n2 + sm*dl2s2<a name='3633'>
<a name='3634'>
                 lint = lint + dzinc<a name='3635'>
                 l2n2 = l2n2 + dl2n2<a name='3636'>
                 l2n2 = -min(-l2n2, tkemax*lint/(b1*sh))<a name='3637'>
                 l2s2 = l2s2 + dl2s2<a name='3638'>
                 wint = wint + dwinc<a name='3639'>
<a name='3640'>
              end do <a name='3641'>
<a name='3642'>
              kt        = ktop(i,ncv+cntu+1) <a name='3643'>
              ncvfin(i) = ncvfin(i) - 1<a name='3644'>
              cntu      = cntu + 1<a name='3645'>
        <a name='3646'>
          end if<a name='3647'>
<a name='3648'>
          <font color=#447700>! Again, calculate the contribution of potentially incorporatable CL<a name='3649'></font>
          <font color=#447700>! top external interface of CL regime.<a name='3650'></font>
<a name='3651'>
          if( choice_tunl .eq. 'rampcl' ) then<a name='3652'>
              tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3653'>
          elseif( choice_tunl .eq. 'rampsl' ) then<a name='3654'>
              tunlramp = ctunl*tunl<a name='3655'>
            <font color=#447700>! tunlramp = 0.765_r8<a name='3656'></font>
          else<a name='3657'>
              tunlramp = tunl<a name='3658'>
          endif<a name='3659'>
          if( choice_leng .eq. 'origin' ) then<a name='3660'>
              lz = ( (vk*zi(i,kt))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3661'>
            <font color=#447700>! lz = vk*zi(i,kt) / (1._r8+vk*zi(i,kt)/(tunlramp*lbulk))<a name='3662'></font>
          else<a name='3663'>
              lz = min( vk*zi(i,kt), tunlramp*lbulk )              <a name='3664'>
          endif<a name='3665'>
<a name='3666'>
          dzinc = z(i,kt-1)-z(i,kt)<a name='3667'>
          dl2n2 = lz*lz*n2(i,kt)*dzinc<a name='3668'>
          dl2s2 = lz*lz*s2(i,kt)*dzinc<a name='3669'>
          dwinc = -sh*dl2n2 + sm*dl2s2<a name='3670'>
<a name='3671'>
       end do   <font color=#447700>! End of upward merging test 'do while' loop<a name='3672'></font>
<a name='3673'>
       <font color=#447700>! Update CL interface indices appropriately if any CL was merged.<a name='3674'></font>
       <font color=#447700>! Note that below only updated the interface index of merged CL,<a name='3675'></font>
       <font color=#447700>! not the original merging CL.  Updates of 'kbase' and 'ktop' of <a name='3676'></font>
       <font color=#447700>! the original merging CL  will be done after finishing downward<a name='3677'></font>
       <font color=#447700>! extension also later.<a name='3678'></font>
<a name='3679'>
       if( cntu .gt. 0 ) then<a name='3680'>
           do incv = 1, ncvfin(i) - ncv<a name='3681'>
              kbase(i,ncv+incv) = kbase(i,ncv+cntu+incv)<a name='3682'>
              ktop(i,ncv+incv)  = ktop(i,ncv+cntu+incv)<a name='3683'>
           end do<a name='3684'>
       end if<a name='3685'>
<a name='3686'>
       <font color=#447700>! ------------------------------ !<a name='3687'></font>
       <font color=#447700>! Step 2. Extend the CL downward !<a name='3688'></font>
       <font color=#447700>! ------------------------------ !<a name='3689'></font>
       <a name='3690'>
       if( kb .ne. pver + 1 ) then<a name='3691'>
<a name='3692'>
           <font color=#447700>! Calculate contribution of potentially incorporable CL base interface<a name='3693'></font>
<a name='3694'>
           if( choice_tunl .eq. 'rampcl' ) then<a name='3695'>
               tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3696'>
           elseif( choice_tunl .eq. 'rampsl' ) then<a name='3697'>
               tunlramp = ctunl*tunl<a name='3698'>
             <font color=#447700>! tunlramp = 0.765_r8<a name='3699'></font>
           else<a name='3700'>
               tunlramp = tunl<a name='3701'>
           endif<a name='3702'>
           if( choice_leng .eq. 'origin' ) then<a name='3703'>
               lz = ( (vk*zi(i,kb))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3704'>
             <font color=#447700>! lz = vk*zi(i,kb) / (1._r8+vk*zi(i,kb)/(tunlramp*lbulk))<a name='3705'></font>
           else<a name='3706'>
               lz = min( vk*zi(i,kb), tunlramp*lbulk )              <a name='3707'>
           endif<a name='3708'>
<a name='3709'>
           dzinc = z(i,kb-1)-z(i,kb)<a name='3710'>
           dl2n2 = lz*lz*n2(i,kb)*dzinc<a name='3711'>
           dl2s2 = lz*lz*s2(i,kb)*dzinc<a name='3712'>
           dwinc = -sh*dl2n2 + sm*dl2s2<a name='3713'>
<a name='3714'>
           <font color=#447700>! ------------ ! <a name='3715'></font>
           <font color=#447700>! Merging test !<a name='3716'></font>
           <font color=#447700>! ------------ ! <a name='3717'></font>
<a name='3718'>
           <font color=#447700>! In the below merging tests, I must keep '.and.(kb.ne.pver+1)',   <a name='3719'></font>
           <font color=#447700>! since 'kb' is continuously updated within the 'do while' loop  <a name='3720'></font>
           <font color=#447700>! whenever CL base is merged.<a name='3721'></font>
<a name='3722'>
         <font color=#447700>! do while( (  dwinc .gt. ( rinc*dzinc*wint/(lint+(1._r8-rinc)*dzinc)) ) &amp;  ! Merging test based on wint<a name='3723'></font>
         <font color=#447700>! do while( ( -dl2n2 .gt. (-rinc*dzinc*l2n2/(lint+(1._r8-rinc)*dzinc)) ) &amp;  ! Merging test based on l2n2<a name='3724'></font>
         <font color=#447700>!             .and.(kb.ne.pver+1))<a name='3725'></font>
           do while( ( -dl2n2 .gt. (-rinc*l2n2/(1._r8-rinc)) ) &amp;                     <font color=#447700>! Integral merging test<a name='3726'></font>
                       .and.(kb.ne.pver+1))<a name='3727'>
<a name='3728'>
              <font color=#447700>! Add contributions from interfacial layer kb to CL interior <a name='3729'></font>
<a name='3730'>
              lint = lint + dzinc<a name='3731'>
              l2n2 = l2n2 + dl2n2<a name='3732'>
              l2n2 = -min(-l2n2, tkemax*lint/(b1*sh))<a name='3733'>
              l2s2 = l2s2 + dl2s2<a name='3734'>
              wint = wint + dwinc<a name='3735'>
<a name='3736'>
              <font color=#447700>! Extend the base external interface of CL downward after merging<a name='3737'></font>
<a name='3738'>
              kb        =  kb + 1<a name='3739'>
              extend    = .true.<a name='3740'>
              extend_dn = .true.<a name='3741'>
<a name='3742'>
              <font color=#447700>! If the base external interface of extending CL is the same as the <a name='3743'></font>
              <font color=#447700>! base interior interface of the underlying CL, underlying CL  will<a name='3744'></font>
              <font color=#447700>! be automatically merged. Then, reduce total number of CL by 1. <a name='3745'></font>
              <font color=#447700>! For a consistent treatment with 'upward' extension,  I should use<a name='3746'></font>
              <font color=#447700>! 'kbinc = kbase(i,ncv-1) - 1' instead of 'ktop(i,ncv-1) + 1' below.<a name='3747'></font>
              <font color=#447700>! However, it seems that these two methods produce the same results.<a name='3748'></font>
              <font color=#447700>! Note also that in contrast to upward merging, the decrease of ncv<a name='3749'></font>
              <font color=#447700>! should be performed here.<a name='3750'></font>
              <font color=#447700>! Note that below formula correctly works even when upperlying CL <a name='3751'></font>
              <font color=#447700>! regime incorporates below SBCL.<a name='3752'></font>
<a name='3753'>
              kbinc = 0<a name='3754'>
              if( ncv .gt. 1 ) kbinc = ktop(i,ncv-1) + 1<a name='3755'>
              if( kb .eq. kbinc ) then<a name='3756'>
<a name='3757'>
                  do k =  ktop(i,ncv-1) + 1, kbase(i,ncv-1) - 1<a name='3758'>
<a name='3759'>
                     if( choice_tunl .eq. 'rampcl' ) then<a name='3760'>
                         tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3761'>
                     elseif( choice_tunl .eq. 'rampsl' ) then<a name='3762'>
                         tunlramp = ctunl*tunl<a name='3763'>
                       <font color=#447700>! tunlramp = 0.765_r8<a name='3764'></font>
                     else<a name='3765'>
                         tunlramp = tunl<a name='3766'>
                     endif<a name='3767'>
                     if( choice_leng .eq. 'origin' ) then<a name='3768'>
                         lz = ( (vk*zi(i,k))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3769'>
                       <font color=#447700>! lz = vk*zi(i,k) / (1._r8+vk*zi(i,k)/(tunlramp*lbulk))<a name='3770'></font>
                     else<a name='3771'>
                         lz = min( vk*zi(i,k), tunlramp*lbulk )              <a name='3772'>
                     endif<a name='3773'>
<a name='3774'>
                     dzinc = z(i,k-1)-z(i,k)<a name='3775'>
                     dl2n2 = lz*lz*n2(i,k)*dzinc<a name='3776'>
                     dl2s2 = lz*lz*s2(i,k)*dzinc<a name='3777'>
                     dwinc = -sh*dl2n2 + sm*dl2s2<a name='3778'>
<a name='3779'>
                     lint = lint + dzinc<a name='3780'>
                     l2n2 = l2n2 + dl2n2<a name='3781'>
                     l2n2 = -min(-l2n2, tkemax*lint/(b1*sh))<a name='3782'>
                     l2s2 = l2s2 + dl2s2<a name='3783'>
                     wint = wint + dwinc<a name='3784'>
<a name='3785'>
                  end do <a name='3786'>
<a name='3787'>
                  <font color=#447700>! We are incorporating interior of CL ncv-1, so merge<a name='3788'></font>
                  <font color=#447700>! this CL into the current CL.<a name='3789'></font>
<a name='3790'>
                  kb        = kbase(i,ncv-1)<a name='3791'>
                  ncv       = ncv - 1<a name='3792'>
                  ncvfin(i) = ncvfin(i) -1<a name='3793'>
                  cntd      = cntd + 1<a name='3794'>
<a name='3795'>
              end if<a name='3796'>
<a name='3797'>
              <font color=#447700>! Calculate the contribution of potentially incorporatable CL<a name='3798'></font>
              <font color=#447700>! base external interface. Calculate separately when the base<a name='3799'></font>
              <font color=#447700>! of extended CL is surface and non-surface.<a name='3800'></font>
             <a name='3801'>
              if( kb .eq. pver + 1 ) then <a name='3802'>
<a name='3803'>
                  if( bflxs(i) .gt. 0._r8 ) then <a name='3804'>
                      <font color=#447700>! Calculate stability functions of surface interfacial layer<a name='3805'></font>
                      gg = 0.5_r8*vk*z(i,pver)*bprod(i,pver+1)/(tkes(i)**(3._r8/2._r8))<a name='3806'>
                      gh_surf = gg/(alph5-gg*alph3)<a name='3807'>
                    <font color=#447700>! gh_surf = min(max(gh_surf,-0.28_r8),0.0233_r8)<a name='3808'></font>
                      gh_surf = min(max(gh_surf,-3.5334_r8),0.0233_r8)<a name='3809'>
                      sh_surf = alph5/(1._r8+alph3*gh_surf)<a name='3810'>
                      sm_surf = (alph1 + alph2*gh_surf)/(1._r8+alph3*gh_surf)/(1._r8+alph4*gh_surf)<a name='3811'>
                      <font color=#447700>! Calculate surface interfacial layer contribution. By construction,<a name='3812'></font>
                      <font color=#447700>! it exactly becomes 'dw_surf = -dl2n2_surf + ds2n2_surf'  <a name='3813'></font>
                      dlint_surf = z(i,pver)<a name='3814'>
                      dl2n2_surf = -vk*(z(i,pver)**2._r8)*bprod(i,pver+1)/(sh_surf*sqrt(tkes(i)))<a name='3815'>
                      dl2s2_surf =  vk*(z(i,pver)**2._r8)*sprod(i,pver+1)/(sm_surf*sqrt(tkes(i)))<a name='3816'>
                      dw_surf = (tkes(i)/b1)*z(i,pver) <a name='3817'>
                  else<a name='3818'>
                      dlint_surf = 0._r8<a name='3819'>
                      dl2n2_surf = 0._r8<a name='3820'>
                      dl2s2_surf = 0._r8<a name='3821'>
                      dw_surf = 0._r8<a name='3822'>
                  end if<a name='3823'>
                  <font color=#447700>! If (kb.eq.pver+1), updating of CL internal energetics should be <a name='3824'></font>
                  <font color=#447700>! performed here inside of 'do while' loop, since 'do while' loop<a name='3825'></font>
                  <font color=#447700>! contains the constraint of '.and.(kb.ne.pver+1)',so updating of<a name='3826'></font>
                  <font color=#447700>! CL internal energetics cannot be performed within this do while<a name='3827'></font>
                  <font color=#447700>! loop when kb.eq.pver+1. Even though I updated all 'l2n2','l2s2',<a name='3828'></font>
                  <font color=#447700>! 'wint' below, only the updated 'wint' is used in the following<a name='3829'></font>
                  <font color=#447700>! numerical calculation.                <a name='3830'></font>
                  lint = lint + dlint_surf<a name='3831'>
                  l2n2 = l2n2 + dl2n2_surf<a name='3832'>
                  l2n2 = -min(-l2n2, tkemax*lint/(b1*sh))<a name='3833'>
                  l2s2 = l2s2 + dl2s2_surf <a name='3834'>
                  wint = wint + dw_surf                <a name='3835'>
                <a name='3836'>
              else<a name='3837'>
<a name='3838'>
                  if( choice_tunl .eq. 'rampcl' ) then<a name='3839'>
                      tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3840'>
                  elseif( choice_tunl .eq. 'rampsl' ) then<a name='3841'>
                      tunlramp = ctunl*tunl<a name='3842'>
                    <font color=#447700>! tunlramp = 0.765_r8<a name='3843'></font>
                  else<a name='3844'>
                      tunlramp = tunl<a name='3845'>
                  endif<a name='3846'>
                  if( choice_leng .eq. 'origin' ) then<a name='3847'>
                      lz = ( (vk*zi(i,kb))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3848'>
                    <font color=#447700>! lz = vk*zi(i,kb) / (1._r8+vk*zi(i,kb)/(tunlramp*lbulk))<a name='3849'></font>
                  else<a name='3850'>
                      lz = min( vk*zi(i,kb), tunlramp*lbulk )              <a name='3851'>
                  endif<a name='3852'>
<a name='3853'>
                  dzinc = z(i,kb-1)-z(i,kb)<a name='3854'>
                  dl2n2 = lz*lz*n2(i,kb)*dzinc<a name='3855'>
                  dl2s2 = lz*lz*s2(i,kb)*dzinc<a name='3856'>
                  dwinc = -sh*dl2n2 + sm*dl2s2<a name='3857'>
<a name='3858'>
              end if<a name='3859'>
<a name='3860'>
          end do <font color=#447700>! End of merging test 'do while' loop<a name='3861'></font>
<a name='3862'>
          if( (kb.eq.pver+1) .and. (ncv.ne.1) ) then <a name='3863'>
               write(iulog,*) 'Major mistake zisocl: the CL based at surface is not indexed 1'<a name='3864'>
#ifdef WRF_PORT<a name='3865'>
               call <A href='../../html_code/frame/module_wrf_error.F.html#WRF_MESSAGE'>wrf_message</A><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#ZISOCL' TARGET='bottom_target'><IMG SRC="../../gif/cyan.gif" border=0></a><A NAME="WRF_MESSAGE_552">(iulog)<a name='3866'>
#endif <a name='3867'>
               stop<a name='3868'>
          end if<a name='3869'>
<a name='3870'>
       end if   <font color=#447700>! Done with bottom extension of CL <a name='3871'></font>
<a name='3872'>
       <font color=#447700>! Update CL interface indices appropriately if any CL was merged.<a name='3873'></font>
       <font color=#447700>! Note that below only updated the interface index of merged CL,<a name='3874'></font>
       <font color=#447700>! not the original merging CL.  Updates of 'kbase' and 'ktop' of <a name='3875'></font>
       <font color=#447700>! the original merging CL  will be done later below. I should <a name='3876'></font>
       <font color=#447700>! check in detail if below index updating is correct or not.   <a name='3877'></font>
<a name='3878'>
       if( cntd .gt. 0 ) then<a name='3879'>
           do incv = 1, ncvfin(i) - ncv<a name='3880'>
              kbase(i,ncv+incv) = kbase(i,ncvinit+incv)<a name='3881'>
              ktop(i,ncv+incv)  = ktop(i,ncvinit+incv)<a name='3882'>
           end do<a name='3883'>
       end if<a name='3884'>
<a name='3885'>
       <font color=#447700>! Sanity check for positive wint.<a name='3886'></font>
<a name='3887'>
       if( wint .lt. 0.01_r8 ) then<a name='3888'>
           wint = 0.01_r8<a name='3889'>
       end if<a name='3890'>
<a name='3891'>
       <font color=#447700>! -------------------------------------------------------------------------- !<a name='3892'></font>
       <font color=#447700>! Finally update CL mean internal energetics including surface contribution  !<a name='3893'></font>
       <font color=#447700>! after finishing all the CL extension-merging process.  As mentioned above, !<a name='3894'></font>
       <font color=#447700>! there are two possible ways in the treatment of surface interfacial layer, !<a name='3895'></font>
       <font color=#447700>! either through 'dw_surf' or 'dl2n2_surf and dl2s2_surf' by setting logical !<a name='3896'></font>
       <font color=#447700>! variable 'use_dw_surf' =.true. or .false.    In any cases, we should avoid !<a name='3897'></font>
       <font color=#447700>! double counting of surface interfacial layer and one single consistent way !<a name='3898'></font>
       <font color=#447700>! should be used throughout the program.                                     !<a name='3899'></font>
       <font color=#447700>! -------------------------------------------------------------------------- !<a name='3900'></font>
<a name='3901'>
       if( extend ) then<a name='3902'>
<a name='3903'>
           ktop(i,ncv)  = kt<a name='3904'>
           kbase(i,ncv) = kb<a name='3905'>
<a name='3906'>
           <font color=#447700>! ------------------------------------------------------ !   <a name='3907'></font>
           <font color=#447700>! Step 1: Include surface interfacial layer contribution !<a name='3908'></font>
           <font color=#447700>! ------------------------------------------------------ !        <a name='3909'></font>
          <a name='3910'>
           lbulk      = zi(i,kt) - zi(i,kb)<a name='3911'>
           dlint_surf = 0._r8<a name='3912'>
           dl2n2_surf = 0._r8<a name='3913'>
           dl2s2_surf = 0._r8<a name='3914'>
           dw_surf    = 0._r8<a name='3915'>
           if( kb .eq. pver + 1 ) then<a name='3916'>
               if( bflxs(i) .gt. 0._r8 ) then<a name='3917'>
                   <font color=#447700>! Calculate stability functions of surface interfacial layer<a name='3918'></font>
                   gg = 0.5_r8*vk*z(i,pver)*bprod(i,pver+1)/(tkes(i)**(3._r8/2._r8))<a name='3919'>
                   gh = gg/(alph5-gg*alph3)<a name='3920'>
                 <font color=#447700>! gh = min(max(gh,-0.28_r8),0.0233_r8)<a name='3921'></font>
                   gh = min(max(gh,-3.5334_r8),0.0233_r8)<a name='3922'>
                   sh = alph5/(1._r8+alph3*gh)<a name='3923'>
                   sm = (alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4*gh)<a name='3924'>
                   <font color=#447700>! Calculate surface interfacial layer contribution. By construction,<a name='3925'></font>
                   <font color=#447700>! it exactly becomes 'dw_surf = -dl2n2_surf + ds2n2_surf'  <a name='3926'></font>
                   dlint_surf = z(i,pver)<a name='3927'>
                   dl2n2_surf = -vk*(z(i,pver)**2._r8)*bprod(i,pver+1)/(sh*sqrt(tkes(i)))<a name='3928'>
                   dl2s2_surf =  vk*(z(i,pver)**2._r8)*sprod(i,pver+1)/(sm*sqrt(tkes(i)))<a name='3929'>
                   dw_surf    = (tkes(i)/b1)*z(i,pver) <a name='3930'>
               else<a name='3931'>
                   lbulk = zi(i,kt) - z(i,pver)<a name='3932'>
               end if<a name='3933'>
           end if<a name='3934'>
           lint = dlint_surf<a name='3935'>
           l2n2 = dl2n2_surf<a name='3936'>
           l2s2 = dl2s2_surf<a name='3937'>
           wint = dw_surf<a name='3938'>
           if( use_dw_surf ) then<a name='3939'>
               l2n2 = 0._r8<a name='3940'>
               l2s2 = 0._r8<a name='3941'>
           else<a name='3942'>
               wint = 0._r8<a name='3943'>
           end if   <a name='3944'>
       <a name='3945'>
           <font color=#447700>! -------------------------------------------------------------- !<a name='3946'></font>
           <font color=#447700>! Step 2. Include the contribution of 'pure internal interfaces' !<a name='3947'></font>
           <font color=#447700>! -------------------------------------------------------------- ! <a name='3948'></font>
          <a name='3949'>
           do k = kt + 1, kb - 1<a name='3950'>
              if( choice_tunl .eq. 'rampcl' ) then<a name='3951'>
                  tunlramp = 0.5_r8*(1._r8+ctunl)*tunl<a name='3952'>
              elseif( choice_tunl .eq. 'rampsl' ) then<a name='3953'>
                  tunlramp = ctunl*tunl<a name='3954'>
                <font color=#447700>! tunlramp = 0.765_r8<a name='3955'></font>
              else<a name='3956'>
                  tunlramp = tunl<a name='3957'>
              endif<a name='3958'>
              if( choice_leng .eq. 'origin' ) then<a name='3959'>
                  lz = ( (vk*zi(i,k))**(-cleng) + (tunlramp*lbulk)**(-cleng) )**(-1._r8/cleng)<a name='3960'>
                <font color=#447700>! lz = vk*zi(i,k) / (1._r8+vk*zi(i,k)/(tunlramp*lbulk))<a name='3961'></font>
              else<a name='3962'>
                  lz = min( vk*zi(i,k), tunlramp*lbulk )              <a name='3963'>
              endif<a name='3964'>
              dzinc = z(i,k-1) - z(i,k)<a name='3965'>
              lint = lint + dzinc<a name='3966'>
              l2n2 = l2n2 + lz*lz*n2(i,k)*dzinc<a name='3967'>
              l2s2 = l2s2 + lz*lz*s2(i,k)*dzinc<a name='3968'>
           end do<a name='3969'>
<a name='3970'>
           ricll = min(l2n2/max(l2s2,ntzero),ricrit)<a name='3971'>
           trma = alph3*alph4*ricll+2._r8*b1*(alph2-alph4*alph5*ricll)<a name='3972'>
           trmb = ricll*(alph3+alph4)+2._r8*b1*(-alph5*ricll+alph1)<a name='3973'>
           trmc = ricll<a name='3974'>
           det = max(trmb*trmb-4._r8*trma*trmc,0._r8)<a name='3975'>
           gh = (-trmb + sqrt(det))/2._r8/trma<a name='3976'>
         <font color=#447700>! gh = min(max(gh,-0.28_r8),0.0233_r8)<a name='3977'></font>
           gh = min(max(gh,-3.5334_r8),0.0233_r8)<a name='3978'>
           sh = alph5 / (1._r8+alph3*gh)<a name='3979'>
           sm = (alph1 + alph2*gh)/(1._r8+alph3*gh)/(1._r8+alph4*gh)<a name='3980'>
           <font color=#447700>! Even though the 'wint' after finishing merging was positive, it is <a name='3981'></font>
           <font color=#447700>! possible that re-calculated 'wint' here is negative.  In this case,<a name='3982'></font>
           <font color=#447700>! correct 'wint' to be a small positive number<a name='3983'></font>
           wint = max( wint - sh*l2n2 + sm*l2s2, 0.01_r8 )<a name='3984'>
<a name='3985'>
       end if<a name='3986'>
<a name='3987'>
       <font color=#447700>! ---------------------------------------------------------------------- !<a name='3988'></font>
       <font color=#447700>! Calculate final output variables of each CL (either has merged or not) !<a name='3989'></font>
       <font color=#447700>! ---------------------------------------------------------------------- !<a name='3990'></font>
<a name='3991'>
       lbrk(i,ncv) = lint<a name='3992'>
       wbrk(i,ncv) = wint/lint<a name='3993'>
       ebrk(i,ncv) = b1*wbrk(i,ncv)<a name='3994'>
       ebrk(i,ncv) = min(ebrk(i,ncv),tkemax)<a name='3995'>
       ricl(i,ncv) = ricll <a name='3996'>
       ghcl(i,ncv) = gh <a name='3997'>
       shcl(i,ncv) = sh<a name='3998'>
       smcl(i,ncv) = sm<a name='3999'>
<a name='4000'>
       <font color=#447700>! Increment counter for next CL. I should check if the increament of 'ncv'<a name='4001'></font>
       <font color=#447700>! below is reasonable or not, since whenever CL is merged during downward<a name='4002'></font>
       <font color=#447700>! extension process, 'ncv' is lowered down continuously within 'do' loop.<a name='4003'></font>
       <font color=#447700>! But it seems that below 'ncv = ncv + 1' is perfectly correct.<a name='4004'></font>
<a name='4005'>
       ncv = ncv + 1<a name='4006'>
<a name='4007'>
    end do                   <font color=#447700>! End of loop over each CL regime, ncv.<a name='4008'></font>
<a name='4009'>
    <font color=#447700>! ---------------------------------------------------------- !<a name='4010'></font>
    <font color=#447700>! Re-initialize external interface indices which are not CLs !<a name='4011'></font>
    <font color=#447700>! ---------------------------------------------------------- !<a name='4012'></font>
<a name='4013'>
    do ncv = ncvfin(i) + 1, ncvmax<a name='4014'>
       ktop(i,ncv)  = 0<a name='4015'>
       kbase(i,ncv) = 0<a name='4016'>
    end do<a name='4017'>
<a name='4018'>
    <font color=#447700>! ------------------------------------------------ !<a name='4019'></font>
    <font color=#447700>! Update CL interface identifiers, 'belongcv'      !<a name='4020'></font>
    <font color=#447700>! CL external interfaces are also identified as CL !<a name='4021'></font>
    <font color=#447700>! ------------------------------------------------ !<a name='4022'></font>
<a name='4023'>
    do k = 1, pver + 1<a name='4024'>
       belongcv(i,k) = .false.<a name='4025'>
    end do<a name='4026'>
<a name='4027'>
    do ncv = 1, ncvfin(i)<a name='4028'>
       do k = ktop(i,ncv), kbase(i,ncv)<a name='4029'>
          belongcv(i,k) = .true.<a name='4030'>
       end do<a name='4031'>
    end do<a name='4032'>
<a name='4033'>
    return<a name='4034'>
<a name='4035'>
    end subroutine zisocl<a name='4036'>
<a name='4037'>
<A NAME='COMPUTE_CUBIC'><A href='../../html_code/phys/module_cam_bl_eddy_diff.F.html#COMPUTE_CUBIC' TARGET='top_target'><IMG SRC="../../gif/bar_green.gif" border=0></A><a name='4038'>
    real(r8) <font color=#993300>function </font><font color=#cc0000>compute_cubic</font>(a,b,c) <A href='../../call_to/COMPUTE_CUBIC.html' TARGET='index'>3</A><a name='4039'>
    <font color=#447700>! ------------------------------------------------------------------------- !<a name='4040'></font>
    <font color=#447700>! Solve canonical cubic : x^3 + a*x^2 + b*x + c = 0,  x = sqrt(e)/sqrt(&lt;e&gt;) !<a name='4041'></font>
    <font color=#447700>! Set x = max(xmin,x) at the end                                            ! <a name='4042'></font>
    <font color=#447700>! ------------------------------------------------------------------------- !<a name='4043'></font>
    implicit none<a name='4044'>
    real(r8), intent(in)     :: a, b, c<a name='4045'>
    real(r8)  qq, rr, dd, theta, aa, bb, x1, x2, x3<a name='4046'>
    real(r8), parameter      :: xmin = 1.e-2_r8<a name='4047'>
    <a name='4048'>
    qq = (a**2-3._r8*b)/9._r8 <a name='4049'>
    rr = (2._r8*a**3 - 9._r8*a*b + 27._r8*c)/54._r8<a name='4050'>
    <a name='4051'>
    dd = rr**2 - qq**3<a name='4052'>
    if( dd .le. 0._r8 ) then<a name='4053'>
        theta = acos(rr/qq**(3._r8/2._r8))<a name='4054'>
        x1 = -2._r8*sqrt(qq)*cos(theta/3._r8) - a/3._r8<a name='4055'>
        x2 = -2._r8*sqrt(qq)*cos((theta+2._r8*3.141592)/3._r8) - a/3._r8<a name='4056'>
        x3 = -2._r8*sqrt(qq)*cos((theta-2._r8*3.141592)/3._r8) - a/3._r8<a name='4057'>
        compute_cubic = max(max(max(x1,x2),x3),xmin)        <a name='4058'>
        return<a name='4059'>
    else<a name='4060'>
        if( rr .ge. 0._r8 ) then<a name='4061'>
            aa = -(sqrt(rr**2-qq**3)+rr)**(1._r8/3._r8)<a name='4062'>
        else<a name='4063'>
            aa =  (sqrt(rr**2-qq**3)-rr)**(1._r8/3._r8)<a name='4064'>
        endif<a name='4065'>
        if( aa .eq. 0._r8 ) then<a name='4066'>
            bb = 0._r8<a name='4067'>
        else<a name='4068'>
            bb = qq/aa<a name='4069'>
        endif<a name='4070'>
        compute_cubic = max((aa+bb)-a/3._r8,xmin) <a name='4071'>
        return<a name='4072'>
    endif<a name='4073'>
<a name='4074'>
    return<a name='4075'>
    end function compute_cubic<a name='4076'>
<a name='4077'>
END MODULE eddy_diff<a name='4078'>
</pre></body></html>